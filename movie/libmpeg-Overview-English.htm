<html lang="en">
<head>
<title>libmpeg-Overview</title>
<meta http-equiv="Content-Type" content= text/html; charset=iso-8859-1>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&trade; Programmer Tool Runtime Library Release 6.3.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
libmpeg Overview
</h1></center>
</a>
<!-- sce_hd1 -->

<!-- sce_hd3 -->
<a name="Heading3_1">
<h2>
 1 <!-- hp --><b>libmpeg Overview</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_1_1">
<h3>
<a href="#Heading3_1"> 1. </a>1 
<!-- hp1 --><b>Functions</b><br>
</a>
</h3>
<div style="margin-left:50px;">libmpeg is a library that can be used for demultiplexing a PSP&trade; Movie Format (for game) stream (hereafter, PSMF stream), and decoding the demultiplexed video and audio streams.<br><br></div>

<div align=center>
<p>
<img src="gif/libmpeg-Overview-English001.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 1 libmpeg Functions and Data Flow</b><br>
</div>
<br>
<div style="margin-left:50px;">PSMF is based on the MPEG2 program stream, and multiplexes together multiple video, audio, and user data streams into a single stream. For the video stream, we use MPEG4 AVC (or simply &quot;AVC&quot;); for the audio stream, we use ATRAC3plus&trade; and PCM. For the user data stream, you can use any arbitrary format. With libmpeg, you can extract a video, audio, or user data stream corresponding to a given ID from the multiplexed PSMF stream, and decode each video or audio stream's extracted data into individual access units.<br>The PSP&trade; includes dedicated hardware for decoding AVC and ATRAC3plus&trade;, so decoding can be done quickly.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_1_2">
<h3>
<a href="#Heading3_1"> 1. </a>2 
<!-- hp1 --><b>Configuration</b><br>
</a>
</h3>
<div style="margin-left:50px;">libmpeg is configured as shown here.<br><br></div>

<div align=center>
<p>
<img src="gif/libmpeg-Overview-English002.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 2 libmpeg Configuration</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_3">
<h3>
<a href="#Heading3_1"> 1. </a>3 
<!-- hp1 --><b>Related files</b><br>
</a>
</h3>
<div style="margin-left:50px;">The following files are required to use libmpeg.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Category</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Filename</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Header file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;libmpeg.h&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Stub library file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;mpeg_stub.a&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;weak import stub library file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;mpeg_stub_weak.a&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>
<div style="margin-left:50px;">Also, you must use a utility function to load the libmpeg module and other modules related to libmpeg processing. For details, refer to the "Utility Services Overview" document.<br>In addition, we have provided two tools for creating PSMF data: the UMD&trade; Stream Composer (for Game Movie) (referred to below as the Stream Composer) and the PSMF Composer.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_1_4">
<h3>
<a href="#Heading3_1"> 1. </a>4 
<!-- hp1 --><b>Related Documents</b><br>
</a>
</h3>
<div style="margin-left:40px;"><ul>
<li> Introduction to Movie Creation and Playback<br>Explanatory document giving an overview of material data, techniques for creating PSMF data, and use of libmpeg for playing back PSMF data.
<li> UMD&trade; Stream Composer (for Game Movie) User's manual<br>Explanatory document showing how to use the Stream Encoder tool to create PSMF data.
<li> PSMF Composer User's manual<br>Explanatory document showing how to use the PSMF Composer tool to create PSMF data.
<li> Utility Services Overview document &quot;Module Utility&quot; chapter <br>Explanatory document related to utility functions showing how to load other modules besides the libmpeg module.
</ul></div>
<div style="margin-left:67px;"><br></div>

<!-- sce_hd3 -->
<a name="Heading3_2">
<h2>
 2 <!-- hp --><b>Usage Procedure</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_2_1">
<h3>
<a href="#Heading3_2"> 2. </a>1 
<!-- hp1 --><b>Video Playback Flow</b><br>
</a>
</h3>
<div style="margin-left:67px;">The diagram below shows the specific function and structure names involved in the dataflow shown in Figure 1.<br><br></div>

<div align=center>
<p>
<img src="gif/libmpeg-Overview-English003.gif">
</div>
<br>
<div style="margin-left:67px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 3 Dataflow</b><br>
</div>
<br>
<div style="margin-left:67px;">The overall flow of movie playback processing using these functions and structures is shown below.<br></div>

<div align=center>
<p>
<img src="gif/libmpeg-Overview-English004.gif">
</div>
<br>
<div style="margin-left:67px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 4 Movie Playback Processing Flow</b><br>
</div>
<br>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1_1"><h4>
(1)&nbsp;<b>Initialization</b><br></h4>
</a></div>
<div style="margin-left:67px;">First, call <a href="../movie/libmpeg-Reference-English.htm#sceMpegInit">sceMpegInit</a>(). Then, call <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferConstruct">sceMpegRingbufferConstruct</a>() to initialize a <a href="../movie/libmpeg-Reference-English.htm#SceMpegRingbuffer">SceMpegRingbuffer</a> structure for managing the PSMF stream. At the same time, set the callback function that will be called from <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>() to read data into the ring buffer. <br></div>
<div style="margin-left:67px;">Next, call <a href="../movie/libmpeg-Reference-English.htm#sceMpegCreate">sceMpegCreate</a>() to initialize a <a href="../movie/libmpeg-Reference-English.htm#SceMpeg">SceMpeg</a> structure which will be used for overall libmpeg management. <br>Next, use <a href="../movie/libmpeg-Reference-English.htm#sceMpegRegistStream">sceMpegRegistStream</a>() to set the stream IDs of the AVC, ATRAC3plus&trade;, PCM, and user data streams that will be used by the user program.<br>After that, allocate decode buffers to hold the demultiplexed elementary streams. For the video stream, use <a href="../movie/libmpeg-Reference-English.htm#sceMpegMallocAvcEsBuf">sceMpegMallocAvcEsBuf</a>() to allocate the buffer. For the audio stream, use <a href="../movie/libmpeg-Reference-English.htm#sceMpegQueryAtracEsSize">sceMpegQueryAtracEsSize</a>()/<a href="../movie/libmpeg-Reference-English.htm#sceMpegQueryPcmEsSize">sceMpegQueryPcmEsSize</a>() to find the required size of the buffer (<i>iEsSize</i>) and allocate that amount of memory. Also, for the user data stream, use <a href="../movie/libmpeg-Reference-English.htm#sceMpegQueryUserdataEsSize">sceMpegQueryUserdataEsSize</a>() to allocate the required buffer size (<i>iEsSize</i>). After that, set  the <i>pEsBuf</i> member of the <a href="../movie/libmpeg-Reference-English.htm#SceMpegAu">SceMpegAu</a> structure and call <a href="../movie/libmpeg-Reference-English.htm#sceMpegInitAu">sceMpegInitAu</a>() to initialize the <a href="../movie/libmpeg-Reference-English.htm#SceMpegAu">SceMpegAu</a> structure, which is used to manage the demultiplexed stream data.<br>Next, skip over the PSMF file header and find the start of the PSMF stream.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1_2"><h4>
(2)&nbsp;<b>Read data into ring buffer</b><br></h4>
</a></div>
<div style="margin-left:67px;">Use <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>() to write the PSMF data into the ring buffer that is being managed by the <a href="../movie/libmpeg-Reference-English.htm#SceMpegRingbuffer">SceMpegRingbuffer</a> structure. libmpeg will demultiplex data that is read into this ring buffer. The PSMF stream handles 1 pack of MPEG2 program stream data as 2048 bytes, so always perform individual write operations with a data size that is a multiple of 2048 bytes.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1_3"><h4>
(3)&nbsp;<b>Extract elementary streams (demultiplex)</b><br></h4>
</a></div>
<div style="margin-left:67px;">To extract one access unit's worth of a stream from the PSMF data in the ring buffer, you must use a separate function for each type of stream. Specifically, use <a href="../movie/libmpeg-Reference-English.htm#sceMpegGetAvcAu">sceMpegGetAvcAu</a>()for the video stream, use <a href="../movie/libmpeg-Reference-English.htm#sceMpegGetAtracAu">sceMpegGetAtracAu</a>() or <a href="../movie/libmpeg-Reference-English.htm#sceMpegGetPcmAu">sceMpegGetPcmAu</a>() for the audio stream, and use <a href="../movie/libmpeg-Reference-English.htm#sceMpegGetUserdataAu">sceMpegGetUserdataAu</a>() for the user data stream. If a time stamp (PTS or DTS) can be obtained when these functions are called, the relevant information is also obtained.<br>If the PSMF data in the ring buffer is not sufficient to fill one access unit when one of the foregoing demultiplexing functions is called, <a href="../movie/libmpeg-Reference-English.htm#SCE_MPEG_ERROR_NOT_COMPLETED">SCE_MPEG_ERROR_NOT_COMPLETED</a> is returned. In this case, return to step 2 to read PSMF data into the ring buffer using <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>(), and once again call the respective function to extract the continuation of the previously extracted elementary stream.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1_4"><h4>
(4)&nbsp;<b>Decoding video, audio, and user data streams</b><br></h4>
</a></div>
<div style="margin-left:67px;">Use <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecode">sceMpegAvcDecode</a> () to decode the video stream. The decoded results will be an image in RGBA (32-bit) format raster scanned from the upper left corner down to the lower right corner. A function is also available for obtaining the decoded results in YCbCr format, however, its explanation is omitted here.<br>Use <a href="../movie/libmpeg-Reference-English.htm#sceMpegAtracDecode">sceMpegAtracDecode</a>() to decode the ATRAC3plus&trade; audio stream. The decoded results will be 44.1 kHz/16-bit PCM sound data with 2048 samples per channel, and either one or two channels. Raw PCM data can be obtained by using <a href="../movie/libmpeg-Reference-English.htm#sceMpegGetPcmAu">sceMpegGetPcmAu</a>(). The data will have 80 samples per channel.<br>A user-provided method should be used to decode user data.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1_5"><h4>
(5)&nbsp;<b>Outputting video, audio, and user data</b><br></h4>
</a></div>
<div style="margin-left:67px;">The libmpeg library does not itself support the output of decoded video, audio and user data to the LCD and audio device, so these functions need to be performed separately.<br>After outputting the decoded video and audio data, return to step 3, extract the continuation of the elementary stream, decode it, output it, and repeat.<br>When no more PSMF stream can be read by <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>(), and when none of the demultiplexing functions such as <a href="../movie/libmpeg-Reference-English.htm#sceMpegGetAvcAu">sceMpegGetAvcAu</a>() can extract an access unit, then proceed to the end (step 6).<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1_6"><h4>
(6)&nbsp;<b>End</b><br></h4>
</a></div>
<div style="margin-left:67px;">Because the last frame of the video stream's reference image will remain in the AVC decoder, call <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeStop">sceMpegAvcDecodeStop</a>() to read the remaining data.<br>Next, free the decode buffers that had been allocated to store the demultiplexed elementary streams. The video stream's decode buffer is freed using <a href="../movie/libmpeg-Reference-English.htm#sceMpegFreeAvcEsBuf">sceMpegFreeAvcEsBuf</a>(). The  decode buffers for the audio stream and user data stream should be freed in a manner appropriate to the way they were allocated.<br>Next, discard each stream ID using <a href="../movie/libmpeg-Reference-English.htm#sceMpegUnRegistStream">sceMpegUnRegistStream</a>(). Discard the <a href="../movie/libmpeg-Reference-English.htm#SceMpeg">SceMpeg</a> structure using <a href="../movie/libmpeg-Reference-English.htm#sceMpegDelete">sceMpegDelete</a>(), and destroy the contents of the ring buffer using <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferDestruct">sceMpegRingbufferDestruct</a>(). Finally, call <a href="../movie/libmpeg-Reference-English.htm#sceMpegFinish">sceMpegFinish</a>() to end.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_2">
<h3>
<a href="#Heading3_2"> 2. </a>2 
<!-- hp1 --><b>Correspondence between Stream types and Stream IDs</b><br>
</a>
</h3>
<div style="margin-left:50px;">Stream IDs correspond to individual stream types, are 8 bits of data, and are assigned as follows:<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Elementary Stream</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Stream Type</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Stream ID</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Private Stream ID</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Stream channel</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;MPEG4 AVC&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;SCE_MPEG_STREAM_M4AVC&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;'1110 xxxxb'&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;none&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0-15&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;ATRAC3plus&trade;&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;SCE_MPEG_STREAM_ATRAC&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;'1011 1101b'&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;'0000 xxxxb'&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0-15&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;PCM&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;SCE_MPEG_STREAM_PCM&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;'1011 1101b'&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;'0001 xxxxb'&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0-15&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;USER DATA&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;SCE_MPEG_STREAM_DATA&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;'1011 1101b'&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;'0010 xxxxb'&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0-15&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>
<div style="margin-left:50px;">As can be seen, up to 16 video streams of AVC data can be used together with up to 32(*) audio streams, consisting of up to 16 audio streams of ATRAC3plus&trade; data and 16 audio streams of PCM data, and up to 16 user data streams .<br>(*) Note that for PCM, this is a logical value that can be handled by demultiplexing, but actually creating this number is impossible considering the multiplexing rate.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_3">
<h3>
<a href="#Heading3_2"> 2. </a>3 
<!-- hp1 --><b>Allocating Buffers</b><br>
</a>
</h3>
<div style="margin-left:50px;">You must allocate the following buffers when using libmpeg:<br></div>
</ul>
<div style="margin-left:65px;"><ol type="a">
<li VALUE=1> A ring buffer for PSMF input;</li>
<li VALUE=2> Decode buffers to store the demultiplexed elementary streams</li>
<li VALUE=3> Buffers to store the results of decoding</li>
</ol></div>
<div style="margin-left:50px;">The amount of memory required for the ring buffer can be obtained using <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferQueryMemSize">sceMpegRingbufferQueryMemSize</a>(). Pass the function the number of packs required to hold the PSMF stream data to be read or pass it a number of packs large enough for the multiplex rate that was set in StreamComposer multiplied by the STD delay. Then, allocate an amount of memory equal to the size that was returned. The amount of memory for the standard setting in StreamComposer is multiplex rate (10 Mbps) x STD Delay (1 sec) = approximately 1.19 Mbytes or 611 packs. However, this is just the minimum required value for ideal demultiplexing, which varies according to the buffering structure in the AVC/ATRAC3plus&trade;/user data decoders during their latter stages, for programs that play back video, audio and user data synchronously.<br>To perform this kind of playback, we recommend allocating at least 960 packs (approx.), which is the same as what is set for the sample programs.<br>Note that the minimum required number of packs also varies according to the stream. To set a smaller value than the recommended value when you absolutely need to limit memory usage, you must confirm it with the stream that will ultimately be used.<br>Use <a href="../movie/libmpeg-Reference-English.htm#sceMpegMallocAvcEsBuf">sceMpegMallocAvcEsBuf</a>() to allocate the memory for the video stream's decode buffer. To decode video data in RGBA format, the buffer to store the decoding results must be iFrameWidth x vertical pixel count x 4 (RGBA) bytes in size and should always be allocated on a 16-byte boundary.<br>The decode buffer for the audio stream should be of size <i>iEsSize</i> as returned by <a href="../movie/libmpeg-Reference-English.htm#sceMpegQueryAtracEsSize">sceMpegQueryAtracEsSize</a>()/<a href="../movie/libmpeg-Reference-English.htm#sceMpegQueryPcmEsSize">sceMpegQueryPcmEsSize</a>(), and should be allocated on a 64-byte boundary. The buffer to store the results of audio decoding should be of size <i>iOutSize</i> as returned by <a href="../movie/libmpeg-Reference-English.htm#sceMpegQueryAtracEsSize">sceMpegQueryAtracEsSize</a>()/<a href="../movie/libmpeg-Reference-English.htm#sceMpegQueryPcmEsSize">sceMpegQueryPcmEsSize</a>(), and also should be allocated on a 64-byte boundary.<br>The demultiplexing buffer for the user data stream should be allocated on a 64-byte boundary, and should either be of size <i>iEsSize</i> as returned by <a href="../movie/libmpeg-Reference-English.htm#sceMpegQueryUserdataEsSize">sceMpegQueryUserdataEsSize</a>(), or the size of the maximum data value if that size is known beforehand.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_4">
<h3>
<a href="#Heading3_2"> 2. </a>4 
<!-- hp1 --><b>Reducing the Amount of Ring Buffer Memory When Playing a Movie</b><br>
</a>
</h3>
<div style="margin-left:50px;">The ring buffer size is the amount of memory used when playing a movie. The standard setting for the ring buffer size for buffering the PSMF stream is 611 packs. This is the minimum size required for the quantity of data corresponding to the multiplexing rate (10 Mbps) x the STD Delay (1 sec) = approximately 1.19 MB. However, the required size can be reduced by changing the Stream Composer multiplexing rate and STD Delay time settings used to create the PSMF file.<br>The minimum values for these settings in Stream Composer are a multiplexing rate of 2.5 Mbps x a STD Delay of 0.5 sec. However, these minimum settings will not allow any Stream Composer rate control margin, so the ring buffer should theoretically be set to approximately 155 KB which adds one additional pack (2048 bytes). Since the minimum number of packs in this case is 78, call <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferQueryMemSize">sceMpegRingbufferQueryMemSize</a>() with 78 packs as the argument and allocate memory equal to the returned memory size.<br>Of course, when the file size is less than 78 packs, no problems will occur if a ring buffer is allocated that is sufficient for the file size.<br>Note that problems will occur if a PSMF file is created with a bit rate high enough to exceed the maximum multiplexing rate of 2.5 Mbps. However, no problems will occur even at this multiplexing rate if the default bit rate (AVC average 1 Mbps, ATRAC3plus&trade; 128 kbps) is used with one video and one audio stream at a time.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_5">
<h3>
<a href="#Heading3_2"> 2. </a>5 
<!-- hp1 --><b>Writing Data to the Ring Buffer</b><br>
</a>
</h3>
<div style="margin-left:50px;">Reading PSMF data and writing it to the ring buffer is always handled with <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>(). When <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>() is called, the callback function indicated by the <i>callback</i> argument of <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferConstruct">sceMpegRingbufferConstruct</a>() is called. The callback function should read the PSMF file in pack (2048 byte) increments, and return the number of packs read as the return value.<br>Also, before calling <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>(), always check the free space in the ring buffer using <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferAvailableSize">sceMpegRingbufferAvailableSize</a>(), and make sure to write data to the ring buffer using <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>() only up to the amount of free space. It should go without saying that you must write stream data in the ring buffer after the previously written PSMF stream data.<br>You can use a function such as sceIoRead() inside the callback function to perform reading without any problems, however, if you use a function such as memcpy() which reads data via the data cache, be sure to write the data back from the cache to main memory using a function such as <a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackInvalidateRange">sceKernelDcacheWritebackInvalidateRange</a>().<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_6">
<h3>
<a href="#Heading3_2"> 2. </a>6 
<!-- hp1 --><b>Decoded Video Data</b><br>
</a>
</h3>
<div style="margin-left:50px;">Video data decoded by <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecode">sceMpegAvcDecode</a>() and <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeStop">sceMpegAvcDecodeStop</a>() is in 32-bit RGBA format, raster scanned from the upper left corner to the lower right corner. The alpha value is always set to 0.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_7">
<h3>
<a href="#Heading3_2"> 2. </a>7 
<!-- hp1 --><b>Precaution Related to Decoding Video Streams</b><br>
</a>
</h3>
<div style="margin-left:50px;">After decoding the final access unit from the elementary video stream, the reference frame may still be left in the AVC decoder. Always call <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeStop">sceMpegAvcDecodeStop</a>() to make sure that the reference frame has been output.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_8">
<h3>
<a href="#Heading3_2"> 2. </a>8 
<!-- hp1 --><b>Precaution Related to Decoding Video Streams With YCbCr Data</b><br>
</a>
</h3>
<div style="margin-left:50px;"><a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeYCbCr">sceMpegAvcDecodeYCbCr</a>() and <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeStopYCbCr">sceMpegAvcDecodeStopYCbCr</a>() are the YCbCr output version APIs of <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecode">sceMpegAvcDecode</a>() and <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeStop">sceMpegAvcDecodeStop</a>(). They operate in the same way except for outputting YCbCr instead of RGBA.<br>To use these functions, first allocate memory for the YCbCr output buffer with the size that was returned by <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcQueryYCbCrSize">sceMpegAvcQueryYCbCrSize</a>(). The buffer should be 16-byte aligned. Then, call <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcInitYCbCr">sceMpegAvcInitYCbCr</a>() to initialize the buffer.<br>Frame data that was output using YCbCr is color converted from YCbCr to RGBA by <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcCsc">sceMpegAvcCsc</a>(), and the resultant image is raster scanned from the upper left to the lower right in RGBA (32 bit) format. The &alpha; value is always zero.<br><a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcCsc">sceMpegAvcCsc</a>() can be used to specify the range for performing CSC. However, a value that is divisible by 16 must be specified for the horizontal direction. Note that when the number of pixels in the vertical direction differs from the number of pixels in the AVC decoder output, the speed of CSC will drop.<br>The size of the buffer for saving CSC results must be at least <i>iFrameWidth</i> x Number of pixels in vertical direction x 4 (RGBA) bytes. Be sure to allocate the buffer with 16-byte alignment.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_9">
<h3>
<a href="#Heading3_2"> 2. </a>9 
<!-- hp1 --><b>Operations on Video Streams with YCbCr Data</b><br>
</a>
</h3>
<div style="margin-left:50px;">Please do not access the YCbCr memory area handled by the <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeYCbCr">sceMpegAvcDecodeYCbCr</a>(), <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeStopYCbCr">sceMpegAvcDecodeStopYCbCr</a>(), and <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcCopyYCbCr">sceMpegAvcCopyYCbCr</a>() functions. Either use a function such as <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcCsc">sceMpegAvcCsc</a>() to output an RGBA image before operating on the data or use <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcConvertToYuv420">sceMpegAvcConvertToYuv420</a>() to convert the data and operate on the resulting YUV420 YCbCr rasterized data.<br>The YCbCr data that is converted by <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcConvertToYuv420">sceMpegAvcConvertToYuv420</a>() is stored as a top left to bottom right raster scanned image in separate frame buffer areas for Y, Cb, and Cr, respectively, as 255-level, color space sampled 420 format data. The frame buffer sizes are in units of 16 pixels. The color space sampling ratios are 4:2:0. Also, the frame buffers of the various dimensions are precisely arranged without gaps in Y, Cb, Cr order. For example, when 480x272 AVC Decode results are converted, 130560 (= 480x272) bytes comprise the Y frame buffer, the next 32640 (= 240x136) bytes following the Y frame buffer are the Cb frame buffer, and the next 32640 bytes after the Cb frame buffer are the Cr frame buffer.<br>The YCbCr data that is converted with <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcConvertToYuv420">sceMpegAvcConvertToYuv420</a>() can be color converted to RGBA using <a href="../still/JPEGDEC-Reference-English.htm#sceJpegCsc">sceJpegCsc</a>(). If SCE_CSC_BILINEAR_ENABLE is specified for the option argument, upsampling will be applied to the color components (Cb/Cr) during color conversion according to the bilinear filter, and this will produce a display with minimal color bleeding.<br>Try this technique for the video stream if you are concerned about color bleeding, since the picture quality should improve along edges where the spatial frequency is high. However, the following limitations will apply. <br></div>
</ol>
<div style="margin-left:40px;"><ul>
<li> Color conversion processing takes longer
<li> The area in the Graphic engine eDRAM that can be obtained by <a href="../graphics/GE-Reference-English.htm#sceGeEdramGetAddr">sceGeEdramGetAddr</a>() cannot be specified as the write destination (where RGBA format data is placed)
<li> Since the color conversion coefficients are different for the AVC decoder and JPEG decoder, there will be a slight difference in hue as well (for details on how to prevent this, see the following section, "Color Bleeding When Playing Video on a PSP&trade; ").
</ul></div>
<div style="margin-left:50px;">The size of the output buffer of <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeYCbCr">sceMpegAvcDecodeYCbCr</a>() must be at least the number of horizontal pixels of the frame buffer to be converted x the number of vertical pixels x 1.5 bytes. Calculate the required size by setting SCE_MPEG_AVC_YCBCR_YUV420 in the <i>iYCbCrMode</i> argument of <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcQueryYCbCrSize">sceMpegAvcQueryYCbCrSize</a>(). Be sure to allocate this output buffer with 64-byte alignment.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_10">
<h3>
<a href="#Heading3_2"> 2. </a>10 
<!-- hp1 --><b>Color Bleeding When Playing Video on a PSP&trade; </b><br>
</a>
</h3>
<div style="margin-left:50px;">When working with a movie that has sharp edges in the picture, color bleeding may occur in some cases and the expected display result may not be obtained. One possible cause of this is interpolation accuracy on the PSP&trade; when video is AVC decoded, and colors are converted from YUV to RGBA.<br>This problem occurs during interpolation when the AVC video stream is converted to RGBA, if the stream has been recorded in YUV420 and the color components (Cb/Cr) have 1/4 the number of pixels as in RGBA. Blindly increasing the bit rate at the encoding side will not fix this problem (it may even cause it to worsen). Also, the problem may not be noticeable when playing back video in a non-PSP&trade; environment (such as with playback software on a PC) because the interpolation method is different.<br>This problem can be mitigated by using the <a href="../still/JPEGDEC-Reference-English.htm#sceJpegCsc">sceJpegCsc</a>() function to perform color conversion using bilinear interpolation of the color components (for details, see the latter part of the previous section, "Operations on Video Streams with YCbCr Data"). Also, you can check whether this problem is important by executing the mpegstr_gu sample with the -modeyuv420 option on a PSP&trade; to play the video stream in question.<br>However, when encoding, set the Stream composer Brightness Scale to 16-235 (ITU-R601), since the CSC calculation performed by <a href="../still/JPEGDEC-Reference-English.htm#sceJpegCsc">sceJpegCsc</a>() uses the JFIF coefficients. (This is so that the YUV-RGBA conversion coefficients for 0-255 become 1.0 instead of 16-235, which is the expanded range of ITU-R601). <br>If the Brightness Scale is set to the default setting of 0-255, the expected coloration will not be obtained since the stream will have been processed as ITU-R601-format color which is used by the normal MPEG library system. However, if the normal MPEG library CSC functions <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcCsc">sceMpegAvcCsc</a>() or <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecode">sceMpegAvcDecode</a>() are mistakenly used for a PSMF file encoded as 16-235 (ITU-R601), the display may become corrupted, as described in technical bulletin 200504-01.<br>For a general 480x272-pixel, 30fps video, which is mainly used in a PSMF stream, the AVC bit rate is sufficient at an average of approximately 1 Mbps, which is the Stream Composer default setting. Of course, raising the bit rate further might improve color bleeding, but if not, try using the above method.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_11">
<h3>
<a href="#Heading3_2"> 2. </a>11 
<!-- hp1 --><b>Decoded Audio Data</b><br>
</a>
</h3>
<div style="margin-left:50px;">Audio data decoded by <a href="../movie/libmpeg-Reference-English.htm#sceMpegAtracDecode">sceMpegAtracDecode</a>() is 16-bit PCM with a sampling frequency of 44.1 kHz. There are 2048 samples per channel. Audio data that can be obtained by <a href="../movie/libmpeg-Reference-English.htm#sceMpegGetPcmAu">sceMpegGetPcmAu</a>() will have 80 samples per channel. Either one or two channels can be selected.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_12">
<h3>
<a href="#Heading3_2"> 2. </a>12 
<!-- hp1 --><b>Precautions Related to Decoding ATRAC3plus&trade; Streams</b><br>
</a>
</h3>
<div style="margin-left:50px;">The decoding of the ATRAC3plus&trade; elementary stream should always be handled by <a href="../movie/libmpeg-Reference-English.htm#sceMpegAtracDecode">sceMpegAtracDecode</a>(). <br>Furthermore, when you begin decoding a new PSMF stream, start by initializing the ATRAC3plus&trade; decoder. You can do this by setting the <i>iInitFlag</i> argument of <a href="../movie/libmpeg-Reference-English.htm#sceMpegAtracDecode">sceMpegAtracDecode</a>() to 1 (in which case, no PCM data is output). Conversely, if you are continuing to decode an ATRAC3plus&trade; stream from the same PSMF stream, the <i>iInitFlag</i> variable should be set to 0.<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_3">
<h2>
 3 <!-- hp --><b>Precautions</b>
<hr noshade>
</h2>

<div style="margin-left:50px;">Please observe the following precautions when using libmpeg.<br></div>
<div style="margin-left:40px;"><ul>
<li> You cannot create more than one <a href="../movie/libmpeg-Reference-English.htm#SceMpeg">SceMpeg</a> structure for a program overall. Correct operation is not guaranteed if you create more than one.
<li> Although libmpeg can handle a PSMF stream in which multiple AVC and ATRAC3plus&trade; elementary streams were multiplexed, only one AVC and ATRAC3plus&trade; stream can be decoded at a time.
<li> After decoding a stream, if you want to switch to another stream during input, you should release and initialize the pointer to the <a href="../movie/libmpeg-Reference-English.htm#SceMpegStream">SceMpegStream</a> structure. This structure is used to manage the demultiplexing buffer and stream ID.
<li> The ring buffer used for PSMF input should always be allocated to be greater than or equal to the number of packs needed for the multiplex rate that was set in StreamComposer multiplied by the STD delay (where 1 pack = 2048 bytes). If the PSMF stream is smaller than this amount, then it is not a problem to have a pack size sufficient to hold the entire PSMF stream. If the ring buffer does not satisfy these requirements, it may be impossible to get the sync times (PTS) from the demultiplexed video, audio and user data outputs.
<li> Functions that handle the STC, which accesses the PTS/DTS time stamps, are not supported. However, you can obtain the PTS/DTS stored in the PSMF.
<li> Always use PSMF files that were created using the Stream Composer and PSMF Composer. PSMF files created by anything other than these special-purpose tools are not guaranteed to decode or demultiplex correctly. 
<li> In the implementation of the MPEG ring buffer callback function that is called from <a href="../movie/libmpeg-Reference-English.htm#sceMpegRingbufferPut">sceMpegRingbufferPut</a>(), a function such as sceIoRead() can be used for reading without any problem. However, when a function such as memcpy() that reads data via the data cache is used, be sure to call a function such as <a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackInvalidateRange">sceKernelDcacheWritebackInvalidateRange</a>() so that data will be written back from the data cache to main memory.
<li> If there is data in memory before or after the area where the decoded video stream output is located, and that data gets overwritten by the CPU, be sure to write back the data cache to main memory before performing video decoding. Although the decoded video stream output must be aligned on a 16-byte boundary due to hardware constraints, the CPU writes data from the data cache to main memory with 64-byte alignment. Therefore, if there were data in memory before or after the decoded video stream output memory area, the decoded output results might get overwritten. To avoid this, either allocate the decoded output memory area with 64-byte alignment or use a function such as <a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackInvalidateRange">sceKernelDcacheWritebackInvalidateRange</a>() to write the data cache back to main memory before performing video decoding.
<li> Do not access the YCbCr memory area handled by the <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeYCbCr">sceMpegAvcDecodeYCbCr</a>(), <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcDecodeStopYCbCr">sceMpegAvcDecodeStopYCbCr</a>(), and <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcCopyYCbCr">sceMpegAvcCopyYCbCr</a>() functions. Either use a function such as <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcCsc">sceMpegAvcCsc</a>() to output an RGBA image before operating on the data or use <a href="../movie/libmpeg-Reference-English.htm#sceMpegAvcConvertToYuv420">sceMpegAvcConvertToYuv420</a>() to convert the data and operate on the resulting YUV420 YCbCr rasterized data.
</ul></div>

<!-- sce_hd4 -->
<a name="Heading4_3_1">
<h3>
<a href="#Heading3_3"> 3. </a>1 
<!-- hp1 --><b>Stack Size</b><br>
</a>
</h3>
<div style="margin-left:50px;">libmpeg API calls require a minimum stack size of 1024 bytes. Be sure to allocate a stack size greater than this.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_2">
<h3>
<a href="#Heading3_3"> 3. </a>2 
<!-- hp1 --><b>Termination Processing</b><br>
</a>
</h3>
<div style="margin-left:50px;">libmpeg internally calls the Media Engine's CPU functions and uses semaphores for exclusive processing of the Media Engine's internal resources. <br>If a thread that is calling libmpeg is forcibly deleted by using <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateThread">sceKernelTerminateThread</a>() and <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateDeleteThread">sceKernelTerminateDeleteThread</a>() before the thread transitions to DORMANT state while a libmpeg function is being executed, then depending on the timing, the thread may end up being deleted while it continues to hold internal resources. As a result, there is a risk that another library that is using the Media Engine's CPU functions such as libmpeg may no longer work properly.<br><br>To terminate a thread, make sure the following actions are taken (the samples that use libmpeg are also constructed in this way):<br></div>
<div style="margin-left:40px;"><ul>
<li> The side that requests the thread to terminate uses a shared variable or event flag to communicate its request to the thread.
<li> The thread that is to be terminated periodically monitors this flag to determine whether a termination request was issued. If a request was issued, the thread first verifies that libmpeg is not currently running and then it calls <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitThread">sceKernelExitThread</a>() to terminate itself.
</ul></div>
<div style="margin-left:50px;"><br><br></div>
<p><p><hr>
<div ALIGN="right">
    &copy;2009 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
