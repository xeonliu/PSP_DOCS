<html lang="en">
<head>
<title>Thread_Manager-Reference</title>
<meta http-equiv="Content-Type" content= text/html; charset=iso-8859-1>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&trade; Programmer Tool Runtime Library Release 6.3.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
PSP&trade; Thread Manager Specifications Reference
</h1></center>
</a>
<!-- sce_hd1 -->
<div style="margin-left:50px;"><br></div>
<div style="margin-left:50px;"><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelThreadInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelThreadInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right> Thread status <br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelThreadInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt <i>attr;</i>
	int <i>status</i>;
	void <i>*entry</i>;
	void <i>*stack</i>;
	int <i>stackSize</i>;
	void <i>*gpReg</i>;
	int <i>initPriority;</i>
	int <i>currentPriority</i>;
	int <i>waitType</i>;
	SceUID <i>waitId;</i>
	int <i>wakeupCount</i>;
	int <i>exitStatus;</i>
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> <i>runClocks;</i>
	SceUInt <i>intrPreemptCount</i>;
	SceUInt <i>threadPreemptCount;</i>
	SceUInt <i>releaseCount;</i>
	int <i>notifycallback</i>;
} <b>SceKernelThreadInfo</b>;
</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;size&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Set&nbsp;this&nbsp;member&nbsp;to&nbsp;sizeof(SceKernelThreadInfo)&nbsp;when&nbsp;calling&nbsp;this&nbsp;function.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;specified&nbsp;by&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Thread&nbsp;attribute&nbsp;that&nbsp;was&nbsp;set&nbsp;by&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>status</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Thread&nbsp;status&nbsp;is&nbsp;represented&nbsp;by&nbsp;the&nbsp;following&nbsp;values&nbsp;&nbsp;&nbsp;<br>&nbsp;0x01&nbsp;SCE_KERNEL_THS_RUN&nbsp;&nbsp;RUN&nbsp;state&nbsp;&nbsp;<br>&nbsp;0x02&nbsp;SCE_KERNEL_THS_READY&nbsp;&nbsp;READY&nbsp;state&nbsp;<br>&nbsp;0x04&nbsp;SCE_KERNEL_THS_WAIT&nbsp;&nbsp;WAIT&nbsp;state&nbsp;&nbsp;<br>&nbsp;0x08&nbsp;SCE_KERNEL_THS_SUSPEND&nbsp;&nbsp;SUSPEND&nbsp;state&nbsp;&nbsp;<br>&nbsp;0x0c&nbsp;SCE_KERNEL_THS_WAITSUSPEND&nbsp;&nbsp;WAIT-SUSPEND&nbsp;state&nbsp;<br>&nbsp;0x10&nbsp;SCE_KERNEL_THS_DORMANT&nbsp;&nbsp;DORMANT&nbsp;state&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>entry</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Entry&nbsp;address&nbsp;that&nbsp;was&nbsp;set&nbsp;by&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>stack</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Starting&nbsp;address&nbsp;of&nbsp;stack&nbsp;area&nbsp;that&nbsp;was&nbsp;reserved&nbsp;by&nbsp;kernel&nbsp;when&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>()&nbsp;was&nbsp;executed&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>stackSize</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Stack&nbsp;size&nbsp;that&nbsp;was&nbsp;set&nbsp;by&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>()&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>gpReg</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Initial&nbsp;value&nbsp;of&nbsp;gp&nbsp;register&nbsp;when&nbsp;the&nbsp;thread&nbsp;was&nbsp;started&nbsp;up&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>initPriority</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Thread&nbsp;startup&nbsp;priority&nbsp;that&nbsp;was&nbsp;set&nbsp;by&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>()&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>currentPriority</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Current&nbsp;priority&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td rowspan= 25  valign="top">&nbsp;<i>waitType</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Indicates&nbsp;the&nbsp;type&nbsp;of&nbsp;wait&nbsp;state&nbsp;when&nbsp;the&nbsp;thread&nbsp;is&nbsp;in&nbsp;WAIT&nbsp;state.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_SLEEP&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_DELAY&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_SEMA&nbsp;</td>
<td valign="top">&nbsp;Semaphore&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSema">sceKernelWaitSema</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_MUTEX&nbsp;</td>
<td valign="top">&nbsp;Mutex&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelLockMutex">sceKernelLockMutex</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_LWMUTEX&nbsp;</td>
<td valign="top">&nbsp;Lightweight&nbsp;mutex&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelLockLwMutex">sceKernelLockLwMutex</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_EVENTFLAG&nbsp;</td>
<td valign="top">&nbsp;Event&nbsp;flag&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitEventFlag">sceKernelWaitEventFlag</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_MBX&nbsp;</td>
<td valign="top">&nbsp;Message&nbsp;box&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMbx">sceKernelReceiveMbx</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_VPL&nbsp;</td>
<td valign="top">&nbsp;Variable-length&nbsp;memory&nbsp;pool&nbsp;&nbsp;<br>&nbsp;acquisition&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelAllocateVpl">sceKernelAllocateVpl</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_FPL&nbsp;</td>
<td valign="top">&nbsp;Fixed-length&nbsp;memory&nbsp;block&nbsp;&nbsp;<br>&nbsp;acquisition&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelAllocateFpl">sceKernelAllocateFpl</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_MPP&nbsp;</td>
<td valign="top">&nbsp;Message&nbsp;pipe&nbsp;wait&nbsp;state&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_WAITTHEND&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEnd">sceKernelWaitThreadEnd</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_RELTHEVH&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseThreadEventHandler">sceKernelReleaseThreadEventHandler</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_DELCALLBACK&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDeleteCallback">sceKernelDeleteCallback</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_SLEEP_CB&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThreadCB">sceKernelSleepThreadCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_DELAY_CB&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThreadCB">sceKernelDelayThreadCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_SEMA_CB&nbsp;</td>
<td valign="top">&nbsp;Semaphore&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSemaCB">sceKernelWaitSemaCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_MUTEX_CB&nbsp;</td>
<td valign="top">&nbsp;Mutex&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelLockMutexCB">sceKernelLockMutexCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_LWMUTEX_CB&nbsp;</td>
<td valign="top">&nbsp;Lightweight&nbsp;mutex&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelLockLwMutexCB">sceKernelLockLwMutexCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_EVENTFLAG_CB&nbsp;</td>
<td valign="top">&nbsp;Event&nbsp;flag&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitEventFlagCB">sceKernelWaitEventFlagCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_MBX_CB&nbsp;</td>
<td valign="top">&nbsp;Message&nbsp;box&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMbxCB">sceKernelReceiveMbxCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_VPL_CB&nbsp;</td>
<td valign="top">&nbsp;Variable-length&nbsp;memory&nbsp;pool&nbsp;&nbsp;<br>&nbsp;acquisition&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelAllocateVplCB">sceKernelAllocateVplCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_FPL_CB&nbsp;</td>
<td valign="top">&nbsp;Fixed-length&nbsp;memory&nbsp;block&nbsp;&nbsp;<br>&nbsp;acquisition&nbsp;wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelAllocateFplCB">sceKernelAllocateFplCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_MPP_CB&nbsp;</td>
<td valign="top">&nbsp;Message&nbsp;pipe&nbsp;wait&nbsp;state&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSW_WAITTHEND_CB&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;state&nbsp;due&nbsp;to&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEndCB">sceKernelWaitThreadEndCB</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>waitId</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;ID&nbsp;of&nbsp;wait&nbsp;target&nbsp;of&nbsp;above&nbsp;waitType&nbsp;(such&nbsp;as&nbsp;event&nbsp;flag&nbsp;ID)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>wakeupCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Unprocessed&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>()&nbsp;count&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>exitStatus</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Exit&nbsp;status&nbsp;of&nbsp;the&nbsp;thread&nbsp;(same&nbsp;as&nbsp;the&nbsp;return&nbsp;value&nbsp;of&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetThreadExitStatus">sceKernelGetThreadExitStatus</a>())&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>runClocks</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Amount&nbsp;of&nbsp;CPU&nbsp;system&nbsp;time&nbsp;used&nbsp;by&nbsp;the&nbsp;thread&nbsp;(in&nbsp;microseconds).&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>intrPreemptCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Number&nbsp;of&nbsp;times&nbsp;CPU&nbsp;execution&nbsp;right&nbsp;was&nbsp;taken&nbsp;away&nbsp;from&nbsp;the&nbsp;&nbsp;<br>&nbsp;thread&nbsp;due&nbsp;to&nbsp;interrupts.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>threadPreemptCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Number&nbsp;of&nbsp;times&nbsp;CPU&nbsp;execute&nbsp;right&nbsp;was&nbsp;taken&nbsp;from&nbsp;the&nbsp;thread&nbsp;<br>&nbsp;because&nbsp;other&nbsp;threads&nbsp;were&nbsp;manipulated&nbsp;by&nbsp;service&nbsp;calls&nbsp;such&nbsp;as&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSignalSema">sceKernelSignalSema</a>()/<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetEventFlag">sceKernelSetEventFlag</a>().&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>releaseCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Number&nbsp;of&nbsp;times&nbsp;the&nbsp;thread&nbsp;relinquished&nbsp;the&nbsp;CPU&nbsp;execute&nbsp;right&nbsp;<br>&nbsp;because&nbsp;of&nbsp;service&nbsp;calls&nbsp;such&nbsp;as&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSema">sceKernelWaitSema</a>()/<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitEventFlag">sceKernelWaitEventFlag</a>().&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>notifycallback</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Indicates&nbsp;if&nbsp;a&nbsp;callback&nbsp;was&nbsp;reported&nbsp;by&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelNotifyCallback">sceKernelNotifyCallback</a>()&nbsp;but&nbsp;<br>&nbsp;the&nbsp;callback&nbsp;function&nbsp;has&nbsp;not&nbsp;been&nbsp;called&nbsp;yet.&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the status of threads with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadStatus">sceKernelReferThreadStatus</a>(). <br><br></div>

<!-- See Also  -->
<div style="margin-left:10px;"><b>See Also </b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadStatus">sceKernelReferThreadStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelThreadRunStatus"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelThreadRunStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Thread run status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelThreadRunStatus {
	SceSize <i>size</i>;
	int<i> status;</i>
	int <i>currentPriority</i>;
	int <i>waitType</i>;
	int <i>waitId;</i>
	int<i> wakeupCount;</i>
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> <i>runClocks</i>;
	SceUInt <i>intrPreemptCount</i>;
	SceUInt <i>threadPreemptCount;</i>
	SceUInt <i>releaseCount;</i>
int <i>notifycallback</i>;
} <b>SceKernelThreadRunStatus</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelThreadRunStatus) when &nbsp;&nbsp;<br>&nbsp;&nbsp;calling this function.  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>status</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Status of the thread (This is the same as status of &nbsp;&nbsp;<br>&nbsp;&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>currentPriority</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Current priority (This is the same as currentPriority of &nbsp;&nbsp;<br>&nbsp;&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>waitType</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Wait type state (This is the same as waitType of <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>waitId</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Wait ID (This is the same as waitID of <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>wakeupCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Unprocessed <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>() count&nbsp;&nbsp;<br>&nbsp;&nbsp;(This is the same as wakeupCount of <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>runClocks</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Amount of CPU system time used by the thread &nbsp;&nbsp;<br>&nbsp;&nbsp;(This is the same as runClocks of <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>intrPreemptCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of times CPU execution right was taken away from the thread due to interrupts. &nbsp;&nbsp;<br>&nbsp;&nbsp;(This is the same as initPreemptCount of <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>threadPreemptCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of times CPU execute right was taken from the thread&nbsp;&nbsp;<br>&nbsp;&nbsp;because other threads were manipulated by service calls &nbsp;&nbsp;<br>&nbsp;&nbsp;(This is the same as threadPreemptCount of <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>releaseCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of times the thread relinquished the CPU execute right because of service calls &nbsp;&nbsp;<br>&nbsp;&nbsp;(This is the same as releaseCount of <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>notifycallback</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Indicates if the callback function has not been called. (Same as notifycallback in the <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> structure)&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the run state of the thread with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadRunStatus">sceKernelReferThreadRunStatus</a>().<br><br></div>

<!-- See Also  -->
<div style="margin-left:10px;"><b>See Also </b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadRunStatus">sceKernelReferThreadRunStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelSemaInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelSemaInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Semaphore status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelSemaInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt <i>attr</i>;
	int <i>initCount</i>;
	int <i>currentCount</i>;
	int <i>maxCount</i>;
	int <i>numWaitThreads</i>;
} <b>SceKernelSemaInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelSemaInfo) when calling this function.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name that was specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateSema">sceKernelCreateSema</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Semaphore attribute that was set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateSema">sceKernelCreateSema</a>() &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>initCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Initial value of semaphore that was set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateSema">sceKernelCreateSema</a>() &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>currentCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Current value of semaphore &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>maxCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Maximum value of semaphore that was set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateSema">sceKernelCreateSema</a>() &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads waiting for the semaphore &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the status of semaphores with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferSemaStatus">sceKernelReferSemaStatus</a>().  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferSemaStatus">sceKernelReferSemaStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelEventFlagInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelEventFlagInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Event flag status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelEventFlagInfo {
	SceSize<i> size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt <i>attr</i>;
	SceUInt<i> initPattern</i>;
	SceUInt <i>currentPattern</i>;
	int <i>numWaitThreads</i>;
} <b>SceKernelEventFlagInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelEventFlagInfo) when calling this function.  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name that was specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateEventFlag">sceKernelCreateEventFlag</a>() &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Event flag attribute that was set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateEventFlag">sceKernelCreateEventFlag</a>()  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>initPattern</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Initial value of event flag&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>currentPattern</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Current value of event flag&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads waiting for event flag&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the status of the event flag with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferEventFlagStatus">sceKernelReferEventFlagStatus</a>().<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferEventFlagStatus">sceKernelReferEventFlagStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelMutexInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelMutexInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Mutex status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelMutexInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt <i>attr</i>;
	int <i>initCount</i>;
	int <i>currentCount</i>;
	int <i>numWaitThreads</i>;
} <b>SceKernelMutexInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of this structure (sizeof(SceKernelMutexInfo))&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMutex">sceKernelCreateMutex</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Mutex attribute set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMutex">sceKernelCreateMutex</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>initCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Mutex initial value set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMutex">sceKernelCreateMutex</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>currentCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Current lock count of mutex&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads that are waiting for mutex&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferMutexStatus">sceKernelReferMutexStatus</a>() for referencing the mutex status.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferMutexStatus">sceKernelReferMutexStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelLwMutexInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelLwMutexInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Lightweight mutex status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelLwMutexInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt <i>attr</i>;
	SceUID <i>uid</i>;
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexWork">SceKernelLwMutexWork</a> <i>branch</i>;
	int <i>initCount</i>;
	int <i>currentCount</i>;
	int <i>numWaitThreads</i>;
} <b>SceKernelLwMutexInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of this structure (sizeof(SceKernelLwMutexInfo) value)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateLwMutex">sceKernelCreateLwMutex</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Lightweight mutex attribute set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateLwMutex">sceKernelCreateLwMutex</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>uid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Primitive ID of lightweight mutex&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>branch</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Work address of lightweight mutex set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateLwMutex">sceKernelCreateLwMutex</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>initCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Lightweight mutex initial value set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateLwMutex">sceKernelCreateLwMutex</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>currentCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Current lock count of lightweight mutex&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads that are waiting for lightweight mutex&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferLwMutexStatus">sceKernelReferLwMutexStatus</a>() for referencing the lightweight mutex status.<br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferLwMutexStatus">sceKernelReferLwMutexStatus</a>()<br><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferLwMutexStatusById">sceKernelReferLwMutexStatusById</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelMbxInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelMbxInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Message box status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelMbxInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt <i>attr</i>;
	int <i>numWaitThreads</i>;
	int <i>numMessage</i>;
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMsgPacket">SceKernelMsgPacket</a> <i>*topPacket</i>;
} <b>SceKernelMbxInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelMbxInfo) when calling this function. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMbx">sceKernelCreateMbx</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;message box attribute set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMbx">sceKernelCreateMbx</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads waiting for messages  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numMessage</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of messages remaining in message box waiting to be received &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>topPacket</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;First message waiting to be received  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the status of message boxes with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferMbxStatus">sceKernelReferMbxStatus</a>(). <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferMbxStatus">sceKernelReferMbxStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelMppInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelMppInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Message pipe status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct <b>SceKernelMppInfo</b> {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt <i>attr;</i>
	int <i>bufSize</i>;
	int <i>freeSize;</i>
	int <i>numSendWaitThreads;</i>
	int <i>numReceiveWaitThreads</i>;
} SceKernelMppInfo;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set sizeof(SceKernelMppInfo) when calling this function &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMsgPipe">sceKernelCreateMsgPipe</a>() &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Message pipe attribute set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMsgPipe">sceKernelCreateMsgPipe</a>() &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>bufSize</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Buffer size of message pipe (bytes)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>freeSize</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Free size of message pipe buffer (bytes)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numSendWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads waiting to send message &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numReceiveWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads waiting to receive message&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the status of message pipes with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferMsgPipeStatus">sceKernelReferMsgPipeStatus</a>().<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferMsgPipeStatus">sceKernelReferMsgPipeStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelVplInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelVplInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Variable-length memory pool status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct <b>SceKernelVplInfo</b> {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt <i>attr</i>;
	int <i>poolSize</i>;
	int <i>freeSize</i>;
	int <i>numWaitThreads</i>;
} <b>SceKernelVplInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelVplInfo) when calling this function&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateVpl">sceKernelCreateVpl</a>()    &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Variable length memory pool attribute set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateVpl">sceKernelCreateVpl</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>poolSize</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Maximum number of bytes that can be acquired from the memory pool. &nbsp;&nbsp;<br>&nbsp;&nbsp;This value will be the size of the memory pool specified when &nbsp;&nbsp;<br>&nbsp;&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateVpl">sceKernelCreateVpl</a>() was called minus the size of the memory pool's &nbsp;&nbsp;<br>&nbsp;&nbsp;management area.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>freeSize</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of memory bytes not used in the memory pool&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads waiting to acquire memory   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the status of the variable length memory pool with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferVplStatus">sceKernelReferVplStatus</a>().  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferVplStatus">sceKernelReferVplStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelFplInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelFplInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Fixed-length memory pool status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelFplInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt<i> attr</i>;
	int <i>blockSize</i>;
	int <i>numBlocks</i>;
	int <i>freeBlocks;</i>
	int <i>numWaitThreads</i>;
} <b>SceKernelFplInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelFplInfo) when calling this function. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateFpl">sceKernelCreateFpl</a>()  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Fixed length memory pool attribute set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateFpl">sceKernelCreateFpl</a>() &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>blockSize</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Memory block size (number of bytes) set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateFpl">sceKernelCreateFpl</a>()  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numBlocks</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of memory blocks set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateFpl">sceKernelCreateFpl</a>() &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>freeBlocks</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of unused blocks in memory pool &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads waiting to acquire memory &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the status of fixed length memory pools with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferFplStatus">sceKernelReferFplStatus</a>().  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferFplStatus">sceKernelReferFplStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelTlsplInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelTlsplInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>TLS memory pool status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelTlsplInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUInt<i> attr</i>;
	int <i>blockSize</i>;
	int <i>numBlocks</i>;
	int <i>freeBlocks;</i>
	int <i>numWaitThreads</i>;
} <b>SceKernelTlsplInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelTlsplInfo) when calling this function.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateTlspl">sceKernelCreateTlspl</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>attr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;TLS memory pool attribute set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateTlspl">sceKernelCreateTlspl</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>blockSize</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;TLS memory block size (number of bytes) set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateTlspl">sceKernelCreateTlspl</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numBlocks</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of TLS memory blocks set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateTlspl">sceKernelCreateTlspl</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>freeBlocks</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of unused blocks in TLS memory pool&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of threads waiting to acquire memory&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the status of TLS memory pools with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferTlsplStatus">sceKernelReferTlsplStatus</a>().<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferTlsplStatus">sceKernelReferTlsplStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelThreadEventHandlerInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelThreadEventHandlerInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Thread event handler status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct<b> </b>SceKernelThreadEventHandlerInfo {
	SceSize<i> size;</i>
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUID <i>threadId</i>;
	int <i>mask</i>;
	int (*<i>handler</i>)(int, SceUID, void *);
	void *<i>common</i>;
} <b>SceKernelThreadEventHandlerInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of this structure (value of sizeof(SceKernelThreadEventHandlerInfo))&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified in <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>threadId</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target thread specified in <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mask</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Event mask specified in <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>handler</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Handler specified in <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;common argument specified in <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>()&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadEventHandlerStatus">sceKernelReferThreadEventHandlerStatus</a>() function to reference the thread event handler status.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadEventHandlerStatus">sceKernelReferThreadEventHandlerStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelCallbackInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelCallbackInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Callback status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelCallbackInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	SceUID <i>threadId</i>;
	int (*<i>callback</i>)(int, int, void *);
	void *<i>common</i>;
	int <i>notifyCount</i>;
	int <i>notifyArg</i>;
} <b>SceKernelCallbackInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size </i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of this structure (value of sizeof(SceKernelCallbackInfo))&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified in <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateCallback">sceKernelCreateCallback</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>threadId</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of thread to be notified by this callback&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>callback</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Callback function that was registered by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateCallback">sceKernelCreateCallback</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Common arguments that were registered by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateCallback">sceKernelCreateCallback</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>notifyCount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of times <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelNotifyCallback">sceKernelNotifyCallback</a>() was delayed without calling &nbsp;&nbsp;<br>&nbsp;&nbsp;the callback function for this callback ID&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>notifyArg</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Arguments provided by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelNotifyCallback">sceKernelNotifyCallback</a>() for this callback ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferCallbackStatus">sceKernelReferCallbackStatus</a>() function for referencing the callback status.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferCallbackStatus">sceKernelReferCallbackStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelAlarmInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelAlarmInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Alarm status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelAlarmInfo {
	SceSize<i> size</i>;
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> <i>schedule</i>;
	SceUInt (*<i>handler</i>)(void *);
 	void *<i>common</i>;
} <b>SceKernelAlarmInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of this structure (value of sizeof(SceKernelAlarmInfo))&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>schedule</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Scheduled system time for calling this alarm handler&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>handler</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to alarm handler that has been set&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;common argument specified in <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetAlarm">sceKernelSetAlarm</a>()&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferAlarmStatus">sceKernelReferAlarmStatus</a>() function for referencing the alarm status.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferAlarmStatus">sceKernelReferAlarmStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelVTimerInfo"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelVTimerInfo<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Virtual timer status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelVTimerInfo {
	SceSize <i>size</i>;
	char <i>name</i>[SceUID_NAME_MAX + 1];
	int <i>active</i>;
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> <i>base;</i>
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> <i>current</i>;
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> <i>schedule</i>;
	int (*<i>handler</i>)(SceUID, <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *, <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *, void *);
	void <i>*common</i>;
} <b>SceKernelVTimerInfo</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of this structure (value of sizeof(SceKernelVTimerInfo))&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name specified in <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateVTimer">sceKernelCreateVTimer</a>()&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>active</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1 if virtual timer is running; 0 if it is stopped&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>base</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Base time of virtual timer&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>current</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Current time of virtual timer&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>schedule</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Scheduled time for starting virtual timer handler&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>handler</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to virtual timer handler function&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;common argument that is passed to the virtual timer handler function&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferVTimerStatus">sceKernelReferVTimerStatus</a>() function for referencing the virtual handler status.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferVTimerStatus">sceKernelReferVTimerStatus</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelSystemStatus"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelSystemStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>System status<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelSystemStatus {
	SceSize<i> size</i>;
	SceUInt <i>status</i>;
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> <i>idleClocks</i>;
	SceUInt <i>comesOutOfIdleCount</i>;
	SceUInt<i> threadSwitchCount</i>;
	SceUInt <i>vfpuSwitchCount</i>;
} <b>SceKernelSystemStatus</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>size</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Set&nbsp;this&nbsp;member&nbsp;to&nbsp;sizeof(SceKernelSystemStatus)&nbsp;when&nbsp;calling&nbsp;this&nbsp;function.&nbsp;</td>
</tr>
<tr>
<td rowspan= 5  valign="top">&nbsp;<i>status</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;System&nbsp;status&nbsp;represented&nbsp;as&nbsp;one&nbsp;of&nbsp;the&nbsp;following.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSS_THREAD&nbsp;</td>
<td valign="top">&nbsp;Thread&nbsp;executing,&nbsp;dispatching&nbsp;enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSS_DISABLEDISPATCH&nbsp;</td>
<td valign="top">&nbsp;Thread&nbsp;executing,&nbsp;dispatching&nbsp;&nbsp;<br>&nbsp;disabled,&nbsp;interrupts&nbsp;enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSS_DISABLEINTR&nbsp;</td>
<td valign="top">&nbsp;Thread&nbsp;executing,&nbsp;dispatching&nbsp;&nbsp;<br>&nbsp;disabled,&nbsp;interrupts&nbsp;disabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TSS_NOTHREAD&nbsp;</td>
<td valign="top">&nbsp;Thread-independent&nbsp;part&nbsp;is&nbsp;&nbsp;<br>&nbsp;executing&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>idleClocks</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Accumulated&nbsp;system&nbsp;time&nbsp;when&nbsp;threads&nbsp;are&nbsp;not&nbsp;executing&nbsp;(in&nbsp;&nbsp;<br>&nbsp;microseconds).&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>comesOutOfIdleCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Number&nbsp;of&nbsp;transitions&nbsp;from&nbsp;state&nbsp;in&nbsp;which&nbsp;the&nbsp;system&nbsp;has&nbsp;no&nbsp;&nbsp;<br>&nbsp;executing&nbsp;threads&nbsp;to&nbsp;state&nbsp;with&nbsp;executing&nbsp;threads.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>threadSwitchCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Total&nbsp;number&nbsp;of&nbsp;times&nbsp;the&nbsp;system&nbsp;performed&nbsp;context&nbsp;switches&nbsp;for&nbsp;&nbsp;<br>&nbsp;threads.&nbsp;(including&nbsp;the&nbsp;above-mentioned&nbsp;comesOutOfIdleCount)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>vfpuSwitchCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Total&nbsp;number&nbsp;of&nbsp;times&nbsp;the&nbsp;system&nbsp;did&nbsp;a&nbsp;VFPU&nbsp;context&nbsp;switch.&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used to reference the system status with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferSystemStatus">sceKernelReferSystemStatus</a>().  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferSystemStatus">sceKernelReferSystemStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelSysClock"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelSysClock<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>System clock structure <br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelSysClock {
	SceUInt <i>low</i>;
	SceUInt <i>hi</i>;
} <b>SceKernelSysClock</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Low-order 32-bits of the system time&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;High-order 32-bits of the system time&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores system clock.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelThreadOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelThreadOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Thread optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelThreadOptParam  {
	SceSize <i>size</i>;
} <b>SceKernelThreadOptParam</b>;


</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelThreadOptParam) when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>() generates a thread.  <br>It is provided for future expansion.  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelSemaOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelSemaOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Semaphore optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelSemaOptParam {
	SceSize <i>size</i>;
} <b>SceKernelSemaOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelSemaOptParam) when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when semaphore is generated with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateSema">sceKernelCreateSema</a>(). <br>It is provided for future expansion.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateSema">sceKernelCreateSema</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelEventFlagOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelEventFlagOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Event flag Optional data <br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct <b>SceKernelEventFlagOptParam</b> {
	SceSize <i>size</i>;
} SceKernelEventFlagOptParam;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelEventFlagOptParam) &nbsp;&nbsp;<br>&nbsp;&nbsp;when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when an event flag is generated with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateEventFlag">sceKernelCreateEventFlag</a>().  <br>It is provided for future expansion.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateEventFlag">sceKernelCreateEventFlag</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelMutexOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelMutexOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Mutex optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelMutexOptParam {
	SceSize <i>size</i>;
} <b>SceKernelMutexOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of this structure (sizeof(SceKernelMutexOptParam))&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when a mutex is created with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMutex">sceKernelCreateMutex</a>().  <br>It is provided for future expansion.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMutex">sceKernelCreateMutex</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelLwMutexWork"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelLwMutexWork<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Lightweight mutex work area<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelLwMutexWork {
	<a href="../kernel/Types-Reference-English.htm#SceUInt32">SceUInt32</a> <i>opaque</i>[8];
} <b>SceKernelLwMutexWork</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>opaque</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Lightweight mutex work area&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure maintains the work area used by a lightweight mutex. The lightweight mutex work area must be allocated in user memory. All operations for the lightweight mutex are performed via the SceKernelLwMutexWork structure.<br><br>Since the kernel uses this structure as a work area, if <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateLwMutex">sceKernelCreateLwMutex</a>() is used to create a lightweight mutex, a user program must not directly reference or manipulate the contents of this structure until the lightweight mutex is deleted by calling <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDeleteLwMutex">sceKernelDeleteLwMutex</a>(). Also, the memory address of this structure cannot be changed.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateLwMutex">sceKernelCreateLwMutex</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelLwMutexOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelLwMutexOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Lightweight mutex optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelLwMutexOptParam {
	SceSize <i>size</i>;
} <b>SceKernelLwMutexOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of this structure (sizeof(SceKernelLwMutexOptParam) value)&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when a lightweight mutex is created with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateLwMutex">sceKernelCreateLwMutex</a>().  <br>It is provided for future expansion.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateLwMutex">sceKernelCreateLwMutex</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelMbxOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelMbxOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Message box optional data <br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelMbxOptParam {
	SceSize <i>size</i>;
} <b>SceKernelMbxOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelMbxOptParam) when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when message box is generated with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMbx">sceKernelCreateMbx</a>().  <br>It is provided for future expansion.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMbx">sceKernelCreateMbx</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelMsgPacket"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelMsgPacket<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Message packet header structure<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelMsgPacket {
	struct SceKernelMsgPacket *<i>next</i>;
	SceUChar <i>msgPriority</i>;
	SceUChar <i>dummy</i>[3];
} <b>SceKernelMsgPacket</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>next</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to the next message packet &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>msgPriority</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Priority of message&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>dummy</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Reserved for system&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure is used for the header of message packet of message box.<br>The application program sends/receives message packets after adding a message body to this structure.  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSendMbx">sceKernelSendMbx</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMbx">sceKernelReceiveMbx</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelPollMbx">sceKernelPollMbx</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelMppOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelMppOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Message pipe optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelMppOptParam {
	SceSize <i>size</i>;
} <b>SceKernelMppOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelMppOptParam) when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores additional data which is provided when a message pipe is generated with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMsgPipe">sceKernelCreateMsgPipe</a>().  <br>It is provided for future expansion.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateMsgPipe">sceKernelCreateMsgPipe</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelVplOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelVplOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Variable-length memory pool optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelVplOptParam {
	SceSize <i>size</i>;
} <b>SceKernelVplOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelVplOptParam) when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when a variable length memory pool is generated with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateVpl">sceKernelCreateVpl</a>().  <br>It is provided for future expansion.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateVpl">sceKernelCreateVpl</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelFplOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelFplOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Fixed-length memory pool optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelFplOptParam {
	SceSize <i>size</i>;
	SceSize <i>alignment;</i>
} <b>SceKernelFplOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelFplOptParam) when calling this function. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>alignment</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Alignment of fixed length memory pool to be created.&nbsp;&nbsp;<br>&nbsp;&nbsp;If 0 is specified, it is handled as if there is no alignment specification, but in &nbsp;&nbsp;<br>&nbsp;&nbsp;such cases a minimum 4-byte alignment is guaranteed.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when fixed length memory pool is generated with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateFpl">sceKernelCreateFpl</a>().  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateFpl">sceKernelCreateFpl</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelTlsplOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelTlsplOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>TLS memory pool optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelTlsplOptParam {
	SceSize <i>size</i>;
	SceSize <i>alignment;</i>
} <b>SceKernelTlsplOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(sizeof(SceKernelTlsplOptParam) when calling this function.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>alignment</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Alignment of TLS memory pool to be created.&nbsp;&nbsp;<br>&nbsp;&nbsp;If 0 is specified, it is handled as if there is no alignment &nbsp;&nbsp;<br>&nbsp;&nbsp;specification, but in such cases a minimum 4-byte alignment &nbsp;&nbsp;<br>&nbsp;&nbsp;is guaranteed.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when a TLS memory pool is created with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateTlspl">sceKernelCreateTlspl</a>().<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateTlspl">sceKernelCreateTlspl</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="SceKernelVTimerOptParam"></a>
<table width="100%"><td width="70%"><font size=6>SceKernelVTimerOptParam<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Structure]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Virtual timer optional data<br></div><br>

<!-- Structure -->
<div style="margin-left:10px;"><b>Structure</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
typedef struct SceKernelVTimerOptParam {
	SceSize <i>size</i>;
} <b>SceKernelVTimerOptParam</b>;

</font></pre></div>

<!-- Members -->
<div style="margin-left:10px;"><b>Members</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set this member to sizeof(SceKernelVTimerOptParam)when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This structure stores optional data which is provided when a virtual timer is generated with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateVTimer">sceKernelCreateVTimer</a>().  <br>It is provided for future expansion.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateVTimer">sceKernelCreateVTimer</a>()<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateThread</b>( 
	const char *<i>name</i>,
	int (*<i>entry</i>)(SceSize, void *),
	int <i>initPriority</i>,
	SceSize <i>stackSize</i>,
	SceUInt <i>attr</i>,
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadOptParam">SceKernelThreadOptParam</a> *<i>optParam</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;thread.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;operator&nbsp;for&nbsp;visual&nbsp;<br>&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;<br>&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>entry</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Entry&nbsp;address&nbsp;of&nbsp;the&nbsp;thread.&nbsp;The&nbsp;function&nbsp;that&nbsp;will&nbsp;be&nbsp;used&nbsp;as&nbsp;the&nbsp;entry&nbsp;point&nbsp;<br>&nbsp;of&nbsp;the&nbsp;thread&nbsp;can&nbsp;receive&nbsp;memory&nbsp;block&nbsp;data&nbsp;in&nbsp;two&nbsp;arguments.&nbsp;The&nbsp;<br>&nbsp;arguments&nbsp;are&nbsp;provided&nbsp;by&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartThread">sceKernelStartThread</a>(),&nbsp;which&nbsp;is&nbsp;described&nbsp;later.&nbsp;<br>&nbsp;A&nbsp;thread&nbsp;ends&nbsp;by&nbsp;returning&nbsp;from&nbsp;this&nbsp;function,&nbsp;and&nbsp;the&nbsp;return&nbsp;value&nbsp;of&nbsp;the&nbsp;<br>&nbsp;function&nbsp;is&nbsp;the&nbsp;ending&nbsp;status&nbsp;of&nbsp;the&nbsp;thread.&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>initPriority</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Priority&nbsp;when&nbsp;the&nbsp;thread&nbsp;is&nbsp;started&nbsp;up&nbsp;(<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartThread">sceKernelStartThread</a>()).&nbsp;<br>&nbsp;Smaller&nbsp;numbers&nbsp;correspond&nbsp;to&nbsp;higher&nbsp;priorities.&nbsp;The&nbsp;range&nbsp;from&nbsp;<br>&nbsp;SCE_KERNEL_USER_LOWEST_PRIORITY(=111)&nbsp;to&nbsp;<br>&nbsp;SCE_KERNEL_USER_HIGHEST_PRIORITY(=16)&nbsp;can&nbsp;be&nbsp;used.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>stackSize</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Stack&nbsp;size&nbsp;required&nbsp;by&nbsp;the&nbsp;thread&nbsp;in&nbsp;bytes.&nbsp;Since&nbsp;the&nbsp;argument&nbsp;block&nbsp;<br>&nbsp;provided&nbsp;by&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartThread">sceKernelStartThread</a>()&nbsp;is&nbsp;copied&nbsp;to&nbsp;the&nbsp;stack,&nbsp;allow&nbsp;for&nbsp;this&nbsp;<br>&nbsp;amount&nbsp;of&nbsp;margin&nbsp;when&nbsp;specifying&nbsp;the&nbsp;stack&nbsp;size.&nbsp;If&nbsp;a&nbsp;stack&nbsp;size&nbsp;of&nbsp;less&nbsp;than&nbsp;<br>&nbsp;512&nbsp;bytes&nbsp;is&nbsp;specified,&nbsp;an&nbsp;error&nbsp;will&nbsp;occur.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Multiple&nbsp;attributes&nbsp;can&nbsp;be&nbsp;specified&nbsp;by&nbsp;logically&nbsp;ORing&nbsp;them&nbsp;together.&nbsp;&nbsp;<br>&nbsp;Currently,&nbsp;the&nbsp;following&nbsp;attributes&nbsp;are&nbsp;defined.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;&nbsp;&nbsp;</td>
<td valign="top">&nbsp;SCE_KERNEL_TH_CLEAR_STACK&nbsp;</td>
<td valign="top">&nbsp;Specifies&nbsp;that&nbsp;the&nbsp;stack&nbsp;area&nbsp;<br>&nbsp;should&nbsp;be&nbsp;cleared&nbsp;to&nbsp;0&nbsp;when&nbsp;the&nbsp;<br>&nbsp;thread&nbsp;is&nbsp;deleted.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;&nbsp;&nbsp;</td>
<td valign="top">&nbsp;SCE_KERNEL_TH_LOW_STACK&nbsp;</td>
<td valign="top">&nbsp;Specifies&nbsp;that&nbsp;the&nbsp;stack&nbsp;area&nbsp;is&nbsp;&nbsp;<br>&nbsp;allocated&nbsp;from&nbsp;the&nbsp;lower&nbsp;(smaller)&nbsp;<br>&nbsp;addresses&nbsp;in&nbsp;the&nbsp;memory,&nbsp;not&nbsp;the&nbsp;<br>&nbsp;higher&nbsp;(larger)&nbsp;addresses.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;&nbsp;&nbsp;</td>
<td valign="top">&nbsp;SCE_KERNEL_TH_USE_VFPU&nbsp;</td>
<td valign="top">&nbsp;Specifies&nbsp;that&nbsp;the&nbsp;VFPU&nbsp;is&nbsp;accessible.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;This&nbsp;is&nbsp;reserved&nbsp;for&nbsp;future&nbsp;expansion.&nbsp;Specify&nbsp;NULL.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;thid(thid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE">SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PRIORITY">SCE_KERNEL_ERROR_ILLEGAL_PRIORITY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ENTRY">SCE_KERNEL_ERROR_ILLEGAL_ENTRY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a thread. Allocates thread management area for the thread to be created, performs its initial settings, and reserves stack area. Information about the thread to be created is specified in the arguments, and the function returns the thread's ID. The created thread will be placed in DORMANT state. <br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadOptParam">SceKernelThreadOptParam</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteThread </b>(
	SceUID <i>thid</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the thread to be deleted.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_DORMANT">SCE_KERNEL_ERROR_NOT_DORMANT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the thread specified by <i>thid</i>. When the specified thread is deleted, the stack area and thread management area are freed. The specified thread must be in DORMANT state. The calling thread cannot be specified as the thread to delete since it cannot be in DORMANT state (an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_DORMANT">SCE_KERNEL_ERROR_NOT_DORMANT</a> error will occur). To delete the calling thread, use <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitDeleteThread">sceKernelExitDeleteThread</a>(). <br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelStartThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelStartThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Start thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelStartThread </b>(
	SceUID <i>thid</i>,
	SceSize <i>argSize</i>,
	const void *<i>argBlock</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the thread to be started. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>argSize</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of the arguments to be passed to the thread. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>argBlock</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Argument data to be passed to the thread. This data is copied to the thread's stack.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a>(SCE_KERNEL_TH_SELF cannot be specified)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_DORMANT">SCE_KERNEL_ERROR_NOT_DORMANT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Starts execution of the thread specified by thid, then places it in READY state. An argument block specified by argSize and argBlock is copied to the thread's stack, argSize is directly passed in the first argument of the thread's entry function, and the address of the argument block that was copied to the stack is passed in the second argument. The priority specified by initPriority when the thread was created will be used as the priority of the thread. <br>No start request queuing is performed for this service call. In other words, if the target thread is not in DORMANT state, this service call is ignored, and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_DORMANT">SCE_KERNEL_ERROR_NOT_DORMANT</a> error is returned to the issuing thread. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelExitThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelExitThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Exit this thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelExitThread </b>(
	int <i>exitStatus</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in an interrupt-enabled state)<br>Multithread safe<br>Dispatching must be enabled<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>exitStatus</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specifies a value (positive value) to be set for the termination status of the &nbsp;&nbsp;<br>&nbsp;&nbsp;calling thread. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a> <br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CPUDI">SCE_KERNEL_ERROR_CPUDI</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Causes the calling thread to terminate itself normally, and transition to DORMANT state. If a thread is terminated while a mutex is locked, the mutex is automatically unlocked.<br>sceKernelExitThread() is a service call that does not return to the issuing context. <br>Note that resources (such as memory and semaphores) that were acquired by the thread to be terminated are not automatically released. <br>If the terminated thread is restarted by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartThread">sceKernelStartThread</a>(), the information contained in the thread management area, such as the thread priority, is set again. This information is not inherited when the thread is terminated. <br>When the thread terminates, <i>exitStatus</i> will be used as the termination status for that thread. If a thread is terminated by returning from the entry function without using sceKernelExitThread(), the return value of the entry function will be used as the termination status. Only a positive value can be specified for the termination status. If a negative value is specified, when the thread terminates, the termination status will be set to <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT">SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT</a>.<br>The termination status of a thread can be obtained by using <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetThreadExitStatus">sceKernelGetThreadExitStatus</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadStatus">sceKernelReferThreadStatus</a>(), and if another thread is waiting for that thread to terminate because of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEnd">sceKernelWaitThreadEnd</a>(), the termination status can be obtained from the return value.<br>Although the termination status of a thread is saved when the thread terminates and is in DORMANT state, the value is lost when the thread is restarted by using <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartThread">sceKernelStartThread</a>() or if the thread is deleted.<br> <br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEnd">sceKernelWaitThreadEnd</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetThreadExitStatus">sceKernelGetThreadExitStatus</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelExitDeleteThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelExitDeleteThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Exit and delete this thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelExitDeleteThread </b>(
	int <i>exitStatus</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in an interrupt-enabled state)<br>Multithread safe<br>Dispatching must be enabled<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>exitStatus</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specifies a value (positive value) to be set for the termination status of the &nbsp;&nbsp;<br>&nbsp;&nbsp;calling thread. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CPUDI">SCE_KERNEL_ERROR_CPUDI</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Causes the calling thread to terminate itself normally, then deletes the thread. sceKernelExitDeleteThread() is a service call that does not return to the issuing context. <br>Note that resources (such as memory and semaphores) that were acquired by the thread to be terminated are not automatically released. However, in the case of a mutex, if a thread is terminated while a mutex is locked, the mutex is automatically unlocked. Note that in this case, the mutex is only unlocked and is not deleted.<br>When a thread terminates, <i>exitStatus</i> is used as the termination status of that thread.<br>Only a positive value can be specified for the termination status. If a negative value is specified, when the thread terminates, the termination status will be set to <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT">SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT</a>.<br>Since sceKernelExitDeleteThread() deletes a thread immediately without having the thread transition to DORMANT state, the termination status of a thread that was terminated by this service call cannot be obtained by using <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetThreadExitStatus">sceKernelGetThreadExitStatus</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadStatus">sceKernelReferThreadStatus</a>(). The termination status can be obtained from the return value only when <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEnd">sceKernelWaitThreadEnd</a>() is used to wait for the termination of the thread. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEnd">sceKernelWaitThreadEnd</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelTerminateThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelTerminateThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Forcibly terminate another thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelTerminateThread </b>(
	SceUID <i>thid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in an interrupt-enabled state)<br>Multithread safe<br>Dispatching must be enabled<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of thread to be forcibly terminated&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CPUDI">SCE_KERNEL_ERROR_CPUDI</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a> (Specified thread was the calling thread)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Forcibly terminates the thread specified by <i>thid</i> and places it in DORMANT state. <br>Even if the thread to be terminated was in WAIT state (including SUSPEND state), the wait will be canceled and the thread will transition to DORMANT state. Also, if the thread were waiting in a queue for some reason (such as waiting for a semaphore), it will be deleted from that queue. <br><i>thid</i> cannot specify the calling thread. Otherwise, an error will occur. <br>Note that resources (such as memory and semaphores) that were acquired by the thread to be terminated are not automatically released. However, in the case of a mutex, if a thread is terminated while a mutex is locked, the mutex is automatically unlocked. Note that in this case, the mutex is only unlocked and is not deleted.<br>If the terminated thread is restarted by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartThread">sceKernelStartThread</a>(), the information contained in the thread management area, such as the thread priority, is set again. This information is not inherited when the thread is terminated. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEnd">sceKernelWaitThreadEnd</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelTerminateDeleteThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelTerminateDeleteThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Forcibly terminate and delete another thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelTerminateDeleteThread </b>(
	SceUID <i>thid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in an interrupt-enabled state)<br>Multithread safe<br>Dispatching must be enabled<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of thread to be forcibly terminated &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CPUDI">SCE_KERNEL_ERROR_CPUDI</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a> (Specified thread was the calling thread)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Forcibly terminates another thread specified by <i>thid</i> and then deletes it. If the thread specified by <i>thid</i> is already in DORMANT state, this function only deletes it. If a thread is terminated while a mutex is locked, the mutex is automatically unlocked.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEnd">sceKernelWaitThreadEnd</a>()<br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSuspendDispatchThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSuspendDispatchThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Save dispatching state and suspend dispatch thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSuspendDispatchThread </b>(
	void
);
</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in an interrupt-enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Previous state<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CPUDI">SCE_KERNEL_ERROR_CPUDI</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Suspends thread switching and returns the dispatchability state before switching was suspended as the return value. After this function is executed, thread switching is suspended and the calling thread will no longer switch from RUN state to READY state until <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelResumeDispatchThread">sceKernelResumeDispatchThread</a>() is executed. In addition, the thread will not be allowed to transition to WAIT state. Interrupts are not suspended even in a thread switching suspended state. An interrupt will be accepted in the normal way, and control will switch to the interrupt routine. <br>The following operations occur in thread switching suspended state. <br></div>
</ol>
<div style="margin-left:35px;"><ul>
<li> A service call that was issued from an interrupt handler or a thread that is being executed (a thread that executed sceKernelSuspendDispatchThread()) will not cause switching to a new thread that should be executed even if the CPU usage right should be taken away from the thread that is being executed.<br>Switching to a new thread that should be executed will be delayed until the switching suspended state is canceled by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelResumeDispatchThread">sceKernelResumeDispatchThread</a>(). 
<li> When <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSuspendThread">sceKernelSuspendThread</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateThread">sceKernelTerminateThread</a>() is issued for a thread that is being executed (a thread that executed sceKernelSuspendDispatchThread()) from within an interrupt handler that was started while in switching suspended state, the transition of the thread state is delayed until the switching suspended state is canceled. 
<li> When the thread that executed sceKernelSuspendDispatchThread() issues a service call (such as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSema">sceKernelWaitSema</a>()) that can switch the calling thread to WAIT state, an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a> error will occur. 
<li> Since neither the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitThread">sceKernelExitThread</a>() nor <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitDeleteThread">sceKernelExitDeleteThread</a>() service calls return to their original context, when the thread that executed sceKernelSuspendDispatchThread() issues either of these service calls, an error is displayed on the console, and the thread switching suspended state is canceled. 
</ul></div>
<div style="margin-left:50px;">If sceKernelSuspendDispatchThread() is issued while interrupts and thread switching have been suspended by <a href="../kernel/Interrupt_Manager-Reference-English.htm#sceKernelCpuSuspendIntr">sceKernelCpuSuspendIntr</a>(), an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CPUDI">SCE_KERNEL_ERROR_CPUDI</a> error will occur. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelResumeDispatchThread">sceKernelResumeDispatchThread</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelResumeDispatchThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelResumeDispatchThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Resume dispatching state<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelResumeDispatchThread </b>(
	int <i>olddisp</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in an interrupt-enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>olddisp</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Passes the previous dispatchability state, which was acquired by &nbsp;&nbsp;<br>&nbsp;&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSuspendDispatchThread">sceKernelSuspendDispatchThread</a>().   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CPUDI">SCE_KERNEL_ERROR_CPUDI</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns to the state in effect before the thread switchability state was saved in <i>olddisp</i>. <br>This function is used together with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSuspendDispatchThread">sceKernelSuspendDispatchThread</a>() as follows. <br><br></div>
        <div style="margin-left:50px;"><pre><font size=3>int <i>olddisp</i>;
<i>olddisp</i> = <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSuspendDispatchThread">sceKernelSuspendDispatchThread</a>();
/* Dispatching suspended period */
sceKernelResumeDispatchThread( <i>olddisp</i> );

</font></pre></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSuspendDispatchThread">sceKernelSuspendDispatchThread</a>()

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelChangeCurrentThreadAttr"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelChangeCurrentThreadAttr<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Change thread attribute<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelChangeCurrentThreadAttr </b>(
	SceUInt <i>clearAttr</i>,
	SceUInt <i>setAttr</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler.<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clearAttr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specify the attribute to be cleared.  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>setAttr</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specify the attribute to be set.   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Changes the attributes of the currently executing thread that were specified when the thread was created. Currently, only the VFPU access right (SCE_KERNEL_TH_USE_VFPU) can be changed.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelChangeThreadPriority"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelChangeThreadPriority<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Change thread priority<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelChangeThreadPriority </b>(
	SceUID <i>thid</i>,
	int <i>priority</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of the thread for which the priority is to be changed. The calling thread can be specified by SCE_KERNEL_TH_SELF(=0). &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>priority</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;New priority (after the change). Smaller numbers correspond to higher thread priorities. The range from &nbsp;&nbsp;<br>&nbsp;&nbsp;SCE_KERNEL_USER_LOWEST_PRIORITY(=111) to &nbsp;&nbsp;<br>&nbsp;&nbsp;SCE_KERNEL_USER_HIGHEST_PRIORITY(=16) can be used. The current &nbsp;&nbsp;<br>&nbsp;&nbsp;priority of the calling thread can be specified by specifying &nbsp;&nbsp;<br>&nbsp;&nbsp;SCE_KERNEL_TPRI_RUN(=0).&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PRIORITY">SCE_KERNEL_ERROR_ILLEGAL_PRIORITY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Changes the priority of the thread specified by <i>thid</i> to <i>priority</i>. <br>The new priority set by this service call is valid unless it is changed again, before the thread is terminated. If the thread is in DORMANT state, the priority of the thread when it was terminated will be discarded, and the priority when the thread is started the next time will be the startup priority (initPriority) that was specified when the thread was created. <br>If the target thread had been enqueued in the ready queue or some wait queue, the queue order may change due to this service call. If sceKernelChangeThreadPriority() is executed for a thread in the ready queue (including threads in RUN state) or for a thread in a priority-order wait queue, the target thread will be moved to the very end of that part of the queue corresponding to the target priority. Even if the new priority is the same the old priority before sceKernelChangeThreadPriority() is executed, the thread will still be moved in a similar manner to the end of that part of the queue corresponding to that priority. Therefore, the execution right of the calling thread can be relinquished by issuing sceKernelChangeThreadPriority() for the calling thread with the same priority as the current priority. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetThreadCurrentPriority">sceKernelGetThreadCurrentPriority</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRotateThreadReadyQueue">sceKernelRotateThreadReadyQueue</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelRotateThreadReadyQueue"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelRotateThreadReadyQueue<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Rotate thread ready queue<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelRotateThreadReadyQueue </b>(
	int <i>priority</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>priority</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Priority at which queue rotation is to be performed. Smaller numbers &nbsp;&nbsp;<br>&nbsp;&nbsp;correspond to higher thread priorities. The range from &nbsp;&nbsp;<br>&nbsp;&nbsp;SCE_KERNEL_USER_LOWEST_PRIORITY(=111) to &nbsp;&nbsp;<br>&nbsp;&nbsp;SCE_KERNEL_USER_HIGHEST_PRIORITY(=16) can be used. The &nbsp;&nbsp;<br>&nbsp;&nbsp;current priority of the calling thread can be specified by specifying &nbsp;&nbsp;<br>&nbsp;&nbsp;SCE_KERNEL_TPRI_RUN(=0).&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PRIORITY">SCE_KERNEL_ERROR_ILLEGAL_PRIORITY</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Rotates that part of the ready queue corresponding to the priority specified by <i>priority</i>. The thread enqueued at the beginning of that part of the ready queue corresponding to the specified <i>priority</i> is moved to the end of that part of the ready queue, and execution is switched to a thread of the same priority. <br>The part of the ready queue corresponding to the priority of the calling thread can be rotated by specifying SCE_KERNEL_TPRI_RUN(=0) for <i>priority</i> when sceKernelRotateThreadReadyQueue() is called from a thread part. <br>If SCE_KERNEL_TPRI_RUN or the priority of the calling thread is specified for priority in sceKernelRotateThreadReadyQueue(), the calling thread will be rotated to the very end of that part of the ready queue. In other words, sceKernelRotateThreadReadyQueue() can be issued to relinquish a thread's own execution right. The term "ready queue" in the description of this service call is considered to also include threads in RUN state. <br>If there is no thread in the part of the ready queue for the specified priority, no processing is performed and no error will occur. <br>sceKernelRotateThreadReadyQueue(SCE_KERNEL_TPRI_RUN) can also be issued from a thread-independent part such as a timer handler. In this case, the part of the ready queue that contains threads that are executing, or the part of the ready queue that contains the highest priority threads, can be rotated. Normally, these two parts of the ready queue are the same. However, they may be different if thread dispatching is delayed. In this case, the part of the ready queue that contains the highest priority threads will be rotated. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelChangeThreadPriority">sceKernelChangeThreadPriority</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReleaseWaitThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReleaseWaitThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Forcibly cancel WAIT state of another thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>include &lt;kernel.h&gt;
int <b>sceKernelReleaseWaitThread </b>(
	SceUID <i>thid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of the thread for which the WAIT state is to be forcibly canceled. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_WAIT">SCE_KERNEL_ERROR_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a> (calling thread was specified)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">When the thread specified by <i>thid</i> is in a WAIT state, this function forcibly cancels the WAIT state. The thread for which the WAIT state was canceled returns from the service call that placed it in the WAIT state (such as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitEventFlag">sceKernelWaitEventFlag</a>(), or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSema">sceKernelWaitSema</a>()), and the error code <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a> is returned to the caller. <br>sceKernelReleaseWaitThread() does not perform queuing of WAIT state cancellation requests. In other words, if the thread specified by thid is already in a WAIT state, that WAIT state is canceled. However, if the target thread is not in a WAIT state, the error code <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_WAIT">SCE_KERNEL_ERROR_NOT_WAIT</a> is returned to the caller. <br>sceKernelReleaseWaitThread() does not cancel SUSPEND state. If sceKernelReleaseWaitThread() is issued for a thread in a dual wait state (WAIT-SUSPEND), the target thread will be placed in SUSPEND state. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetThreadId"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetThreadId<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get thread ID of this thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelGetThreadId</b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;thid (thid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the ID of this thread. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetThreadCurrentPriority"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetThreadCurrentPriority<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get current priority of this thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetThreadCurrentPriority </b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;thpri(thpri&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread priority&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the current priority of this thread. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelChangeThreadPriority">sceKernelChangeThreadPriority</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetThreadExitStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetThreadExitStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get exit status of a thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetThreadExitStatus </b>(
	SceUID <i>thid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of thread for which the exit status is to be obtained.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;status(status&gt;=0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Exit status of thread&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a> (Target thread has not been started)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_DORMANT">SCE_KERNEL_ERROR_NOT_DORMANT</a> (Target thread has not been terminated)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_THREAD_TERMINATED">SCE_KERNEL_ERROR_THREAD_TERMINATED</a> (Target thread was forcibly terminated)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT">SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT</a> (Target thread terminated and a negative value was specified for the termination status)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This service call gets the ending status of the thread specified by <i>thid</i>.<br>The ending status can be obtained only for threads that were started, ended normally, and transitioned back to DORMANT state. <br>If the target thread has not been started since it was created, <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a> is returned. If the target thread has not ended yet, <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_DORMANT">SCE_KERNEL_ERROR_NOT_DORMANT</a> is returned. If the target thread was forcibly terminated by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateThread">sceKernelTerminateThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_THREAD_TERMINATED">SCE_KERNEL_ERROR_THREAD_TERMINATED</a> is returned.<br>If the target thread was terminated by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitThread">sceKernelExitThread</a>() but a negative value was specified for the termination status, <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT">SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT</a> is returned.<br>If the relevant thread was terminated by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitDeleteThread">sceKernelExitDeleteThread</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateDeleteThread">sceKernelTerminateDeleteThread</a>(), since the thread is also deleted at the same time it is terminated, the ending status cannot be obtained by using sceKernelGetThreadExitStatus().<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitThread">sceKernelExitThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitDeleteThread">sceKernelExitDeleteThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateThread">sceKernelTerminateThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateDeleteThread">sceKernelTerminateDeleteThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitThreadEnd">sceKernelWaitThreadEnd</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferThreadStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferThreadStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get thread status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferThreadStatus </b>(
	SceUID <i>thid</i>,
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of the thread for which the status is to be obtained. The calling thread can &nbsp;&nbsp;<br>&nbsp;&nbsp;be specified with SCE_KERNEL_TH_SELF(=0).  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the thread status. Be sure to assign &nbsp;&nbsp;<br>&nbsp;&nbsp;sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadInfo">SceKernelThreadInfo</a>) to info-&gt;size when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_SIZE">SCE_KERNEL_ERROR_ILLEGAL_SIZE</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of a thread. <br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferThreadRunStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferThreadRunStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get thread run status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferThreadRunStatus </b>(
	SceUID <i>thid</i>,
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadRunStatus">SceKernelThreadRunStatus</a> *<i>stat</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of the thread for which the status is to be obtained The calling thread &nbsp;&nbsp;<br>&nbsp;&nbsp;can be specified with SCE_KERNEL_TH_SELF(=0).   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>stat</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the thread status. Be sure to assign &nbsp;&nbsp;<br>&nbsp;&nbsp;sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadRunStatus">SceKernelThreadRunStatus</a>) to stat-&gt;size when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value  -->
<div style="margin-left:10px;"><b>Return Value </b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the run status of a thread. <br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br>The difference between this service call and <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadStatus">sceKernelReferThreadStatus</a>() is that this service call only returns information that changes when the thread is running. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelExtendThreadStack"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelExtendThreadStack<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Extend thread stack temporarily<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelExtendThreadStack</b> (
	SceSize <i>stackSize</i>,
	int (*<i>func</i>)(void *),
	void *<i>common</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>stackSize</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size (in bytes) of stack to be temporarily extended &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>func</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to function that is executed when the stack is extended&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Argument that is passed to the function specified by <i>func</i>&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;&gt;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Return value of function specified by <i>func</i> &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE">SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Allocates new memory of the size specified by <i>stackSize</i> and uses it as a temporary stack. The function specified by <i>func</i> is executed while the stack is extended. After this function ends, the memory used for the temporary stack is automatically released, and the sceKernelExtendThreadStack() function ends.<br><i>common</i> is used as an argument of the function specified by <i>func</i>, which is executed while the stack is temporarily extended.<br><br>The remaining stack size that was available prior to the thread stack being temporarily extended is not inherited as the stack of the function that is executed after the stack is extended. Only the size specified by <i>stackSize</i> will be used as the new stack size when the stack is extended.<br><br></div>

<!-- sce_title -->
<a Name ="HeadingT_2_1">
<div style="margin-left:40px;"><h4><b>Note</b><br><br></h4></div></a>

<div style="margin-left:50px;">If the longjmp() function is executed, or if an explicit throw or implicitly generated exception is used while the stack is extended, the context may transition without releasing the stack that was allocated by the sceKernelExtendThreadStack() function. Since this will cause a memory leak, do not use setjmp(), longjmp, try, catch, or throw at the same time that a stack extension is used.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCheckThreadStack"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCheckThreadStack<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get remaining stack size of thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCheckThreadStack </b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Remaining stack size of thread (in bytes)<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Calculates the current amount of free space available in the calling thread's stack based on the sp register value. <br>This is a support function for determining the required stack size of a thread. When the calculation result clearly indicates that a stack overflow will occur, a warning is displayed and then the thread is stopped. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetThreadStackFreeSize"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetThreadStackFreeSize<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get unused stack size of thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetThreadStackFreeSize </b>(
	SceUID <i>thid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the thread for which the unused stack size is to be obtained.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;size(size&gt;=0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of unused portion of thread's stack&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the size of the unused portion of the stack from the time the thread was created up to the present time. <br>This is a support function for determining the required stack size of a thread. <br>This function differs from <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCheckThreadStack">sceKernelCheckThreadStack</a>() in that it calculates the unused size by scanning the stack area. Although more processing time is required for this operation, the unused size can be obtained based on the maximum amount of stack used from the time the thread was created up to the present time regardless of the current sp register value. <br>Cases in which the thread is deleted while the stack size is being measured by this function are not taken into account. Be sure to use this function at times when the thread will not be deleted. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelRegisterThreadEventHandler"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelRegisterThreadEventHandler<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Register thread event handler<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelRegisterThreadEventHandler</b>( 
	const char *<i>name</i>,
	SceUID <i>thid</i>,
	int <i>mask</i>,
	int (*<i>handler</i>)(int, SceUID, void *),
	void *<i>common</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;thread&nbsp;event&nbsp;handler.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;operator&nbsp;&nbsp;<br>&nbsp;for&nbsp;visual&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;to&nbsp;&nbsp;<br>&nbsp;determine&nbsp;if&nbsp;the&nbsp;name&nbsp;is&nbsp;unique.&nbsp;&nbsp;</td>
</tr>
<tr>
<td rowspan= 5  valign="top">&nbsp;<i>thid</i>&nbsp;<br>&nbsp;&nbsp;&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Thread&nbsp;ID&nbsp;for&nbsp;which&nbsp;the&nbsp;thread&nbsp;event&nbsp;handler&nbsp;is&nbsp;to&nbsp;be&nbsp;called.&nbsp;The&nbsp;following&nbsp;<br>&nbsp;values&nbsp;can&nbsp;also&nbsp;be&nbsp;used.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TH_SELF&nbsp;(=0)&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;thread&nbsp;event&nbsp;handler&nbsp;is&nbsp;to&nbsp;be&nbsp;called&nbsp;for&nbsp;<br>&nbsp;this&nbsp;thread.&nbsp;In&nbsp;this&nbsp;case,&nbsp;only&nbsp;<br>&nbsp;SCE_KERNEL_TE_EXIT&nbsp;can&nbsp;be&nbsp;specified&nbsp;<br>&nbsp;for&nbsp;the&nbsp;mask&nbsp;argument.&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TH_USER&nbsp;&nbsp;<br>&nbsp;&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;thread&nbsp;event&nbsp;handler&nbsp;is&nbsp;to&nbsp;be&nbsp;called&nbsp;for&nbsp;<br>&nbsp;all&nbsp;user&nbsp;threads.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TH_KERNEL&nbsp;<br>&nbsp;&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;thread&nbsp;event&nbsp;handler&nbsp;is&nbsp;to&nbsp;be&nbsp;called&nbsp;for&nbsp;<br>&nbsp;all&nbsp;kernel&nbsp;threads.&nbsp;Only&nbsp;a&nbsp;kernel&nbsp;thread&nbsp;<br>&nbsp;can&nbsp;specify&nbsp;this&nbsp;argument.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TH_ALL&nbsp;&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;thread&nbsp;event&nbsp;handler&nbsp;is&nbsp;to&nbsp;be&nbsp;called&nbsp;for&nbsp;<br>&nbsp;all&nbsp;threads.&nbsp;Only&nbsp;a&nbsp;kernel&nbsp;thread&nbsp;can&nbsp;<br>&nbsp;specify&nbsp;this&nbsp;argument.&nbsp;&nbsp;</td>
</tr>
<tr>
<td rowspan= 6  valign="top">&nbsp;<i>mask</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;The&nbsp;thread&nbsp;events&nbsp;for&nbsp;which&nbsp;the&nbsp;thread&nbsp;event&nbsp;handler&nbsp;is&nbsp;to&nbsp;be&nbsp;called&nbsp;is&nbsp;&nbsp;<br>&nbsp;specified&nbsp;by&nbsp;the&nbsp;logical&nbsp;OR&nbsp;of&nbsp;the&nbsp;following&nbsp;values.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TE_CREATE&nbsp;</td>
<td valign="top">&nbsp;A&nbsp;thread&nbsp;was&nbsp;created&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TE_DELETE&nbsp;</td>
<td valign="top">&nbsp;A&nbsp;thread&nbsp;was&nbsp;deleted&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TE_START&nbsp;</td>
<td valign="top">&nbsp;A&nbsp;thread&nbsp;was&nbsp;started&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TE_EXIT&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;thread&nbsp;has&nbsp;been&nbsp;terminated.&nbsp;</td>
</tr>
<tr>
<td colspan= 2  valign="top">&nbsp;Specifying&nbsp;SCE_KERNEL_TE_ALL&nbsp;will&nbsp;cause&nbsp;the&nbsp;thread&nbsp;event&nbsp;handler&nbsp;to&nbsp;<br>&nbsp;be&nbsp;called&nbsp;for&nbsp;all&nbsp;thread&nbsp;events.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>handler</i>&nbsp;&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;the&nbsp;thread&nbsp;event&nbsp;handler.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>common</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Third&nbsp;argument&nbsp;to&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;thread&nbsp;event&nbsp;handler.&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;teid(teid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the thread event handler&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MASK">SCE_KERNEL_ERROR_ILLEGAL_MASK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Registers a thread event handler. The thread events for which the thread event handler is to be called can be specified by <i>mask</i>. <br>The UID of the registered thread event handler is returned by the function.  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseThreadEventHandler">sceKernelReleaseThreadEventHandler</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReferThreadEventHandlerStatus">sceKernelReferThreadEventHandlerStatus</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#threadeventhandler">threadeventhandler</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReleaseThreadEventHandler"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReleaseThreadEventHandler<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Release thread event handler<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReleaseThreadEventHandler </b>( 
	SceUID <i>teid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in an interrupt-enabled state)<br>Multithread safe<br>Dispatching must be enabled<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>teid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of thread event handler returned by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>() &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_TEID">SCE_KERNEL_ERROR_UNKNOWN_TEID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Releases a thread event handler that had been previously registered. If the thread event handler that is to be released was being executed by another thread, this function enters a wait state until execution ends. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#threadeventhandler">threadeventhandler</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="threadeventhandler"></a>
<table width="100%"><td width="70%"><font size=6>threadeventhandler<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Thread event handler prototype<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>threadeventhandler</b>( 
	int <i>type</i>, 
	SceUID <i>thid</i>, 
	void *<i>common</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Called in the context of the thread that registered the thread event handler with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>().<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td rowspan= 5  valign="top">&nbsp;<i>type</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;The&nbsp;cause&nbsp;of&nbsp;the&nbsp;thread&nbsp;event&nbsp;handler&nbsp;call&nbsp;is&nbsp;passed.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TE_CREATE&nbsp;</td>
<td valign="top">&nbsp;Thread&nbsp;was&nbsp;created&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TE_DELETE&nbsp;</td>
<td valign="top">&nbsp;Thread&nbsp;was&nbsp;deleted&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TE_START&nbsp;</td>
<td valign="top">&nbsp;Thread&nbsp;was&nbsp;started&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TE_EXIT&nbsp;</td>
<td valign="top">&nbsp;Thread&nbsp;was&nbsp;terminated&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>thid</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;ID&nbsp;of&nbsp;the&nbsp;thread&nbsp;that&nbsp;caused&nbsp;the&nbsp;thread&nbsp;event&nbsp;handler&nbsp;to&nbsp;be&nbsp;called&nbsp;is&nbsp;passed.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>common</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;The&nbsp;<i>common</i>&nbsp;argument&nbsp;that&nbsp;was&nbsp;specified&nbsp;by&nbsp;&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>()&nbsp;is&nbsp;passed.&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Result</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Normal termination&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;This thread event handler will be released&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">A thread event handler is called when the multithread manager performs operations for creating, starting, stopping, or deleting threads. <br><br>Note: Since a thread event handler is normally executed in a thread context, in a handler, it's possible that it may cause a wait state to be entered. In addition, the use of the thread event handler may be restricted by some APIs of the multithread manager. Specifically, usage is restricted for the following APIs.<br></div>
<div style="margin-left:35px;"><ul>
<li> APIs that generate thread events<br>(<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDeleteThread">sceKernelDeleteThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartThread">sceKernelStartThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitThread">sceKernelExitThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateThread">sceKernelTerminateThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitDeleteThread">sceKernelExitDeleteThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateDeleteThread">sceKernelTerminateDeleteThread</a>())
<li> APIs that register or release a thread event handler (<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseThreadEventHandler">sceKernelReleaseThreadEventHandler</a>())
</ul></div>
<div style="margin-left:50px;">A thread event handler can release its own registration by returning a non-zero value.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseThreadEventHandler">sceKernelReleaseThreadEventHandler</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferThreadEventHandlerStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferThreadEventHandlerStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get thread event handler status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferThreadEventHandlerStatus </b>(
	SceUID <i>teid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadEventHandlerInfo">SceKernelThreadEventHandlerInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>teid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of thread event handler for which status is to be obtained&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specifies a pointer to a structure variable for receiving the thread event handler &nbsp;&nbsp;<br>&nbsp;&nbsp;status. Call this function after assigning &nbsp;&nbsp;<br>&nbsp;&nbsp;sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadEventHandlerInfo">SceKernelThreadEventHandlerInfo</a>) to info-&gt;size.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_TEID">SCE_KERNEL_ERROR_UNKNOWN_TEID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the thread event handler status.<br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelRegisterThreadEventHandler">sceKernelRegisterThreadEventHandler</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#threadeventhandler">threadeventhandler</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelThreadEventHandlerInfo">SceKernelThreadEventHandlerInfo</a><br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateCallback"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateCallback<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create callback<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateCallback</b>( 
	const char *<i>name</i>, 
	int (*<i>callback</i>)(int, int, void *), 
	void *<i>common</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name of the callback. Since the name is used by an operator for visual &nbsp;&nbsp;<br>&nbsp;&nbsp;identification during debugging, no specific check is done to determine if the &nbsp;&nbsp;<br>&nbsp;&nbsp;name is unique. The name can have a maximum length of 31 bytes.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>callback</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to the callback function.   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Argument to be passed to the callback function.   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;cbid(cbid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Callback ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a callback. The UID of the created callback is returned by the function. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#callbackfunction">callbackfunction</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteCallback"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteCallback<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete callback<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteCallback </b>(
	SceUID <i>cbid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in interrupt-enabled state)<br>Multithread safe<br>Dispatching must be enabled<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>cbid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the callback to be deleted. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_CBID">SCE_KERNEL_ERROR_UNKNOWN_CBID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the callback indicated by <i>cbid</i>. If another thread is executing the callback that you want to delete, this thread is placed in a WAIT state until the other thread finishes executing. <br>The sceKernelDeleteCallback() function cannot be used by a callback function while it is executing. Although a callback function can delete itself by returning a value of 1, it is not possible for an executing callback function to delete another callback SceUID.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="callbackfunction"></a>
<table width="100%"><td width="70%"><font size=6>callbackfunction<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Callback function prototype<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>int <b>callbackfunction </b>(
	int <i>count</i>, 
	int <i>arg</i>, 
	void *<i>common</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Called in the context of the thread that created the callback with <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateCallback">sceKernelCreateCallback</a>().<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>count</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Passes the number of times <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelNotifyCallback">sceKernelNotifyCallback</a>() was executed until this &nbsp;&nbsp;<br>&nbsp;&nbsp;callback function is called. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>arg</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Passes the argument provided by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelNotifyCallback">sceKernelNotifyCallback</a>().   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Passes the argument provided by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateCallback">sceKernelCreateCallback</a>().  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Result</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Normal termination &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The callback is deleted&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">After the occurrence of a callback is reported by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelNotifyCallback">sceKernelNotifyCallback</a>(), a callback function is called by confirming that notification using <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCheckCallback">sceKernelCheckCallback</a>() or by executing an API such as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSemaCB">sceKernelWaitSemaCB</a>() that waits and checks for the occurrence of a particular notification. <br>By returning a value other than 0, the callback function can cancel its own registration. <br><br></div>

<!-- sce_title -->
<a Name ="HeadingT_3_2">
<div style="margin-left:40px;"><h4><b>Note</b><br><br></h4></div></a>

<div style="margin-left:50px;">The callback function is called in the context of the thread that created the callback. In other words, only a callback that was created by the calling thread can generate a callback function call either by an explicit callback check according to <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCheckCallback">sceKernelCheckCallback</a>() <br>or by a wait function with a callback check such as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSemaCB">sceKernelWaitSemaCB</a>(). <br>To receive the callback notification, the thread that created the callback must use functions such as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCheckCallback">sceKernelCheckCallback</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSemaCB">sceKernelWaitSemaCB</a>().<br>The <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCheckCallback">sceKernelCheckCallback</a>() and <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDeleteCallback">sceKernelDeleteCallback</a>() functions cannot be used within a callback function.<br>Also, if a wait function with callback such as the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSemaCB">sceKernelWaitSemaCB</a>() function is called within a callback function, nesting will occur and this may cause a stack overflow. Do not perform processing within a callback function that causes an additional callback wait.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateCallback">sceKernelCreateCallback</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelNotifyCallback"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelNotifyCallback<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Report callback<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelNotifyCallback </b>( 
	SceUID <i>cbid</i>, 
	int <i>arg</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>cbid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the callback to be reported.   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>arg</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Argument to be passed to the callback function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_CBID">SCE_KERNEL_ERROR_UNKNOWN_CBID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Reports the occurrence of the callback indicated by <i>cbid</i>. The actual call of the associated callback function is delayed until either the thread that generated the callback confirms the callback notification by calling <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCheckCallback">sceKernelCheckCallback</a>() or until a wait API such as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSemaCB">sceKernelWaitSemaCB</a>() is called that checks the validity of the notification. <br>If the callback is reported multiple times before the callback function is called, the number of times it was reported up to the time that is called and the argument provided by the last sceKernelNotifyCallback() are passed to the callback function.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelCallback"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelCallback<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel callback notification<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCancelCallback </b>( 
	SceUID <i>cbid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>cbid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the callback for which notifications are to be canceled. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_CBID">SCE_KERNEL_ERROR_UNKNOWN_CBID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels all notifications that were reported for the callback indicated by <i>cbid</i>. <br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetCallbackCount"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetCallbackCount<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get callback notification count<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetCallbackCount </b>( 
	SceUID <i>cbid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>cbid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the callback for which the callback notification count is to be obtained.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;count(count&gt;=0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Callback notification count&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_CBID">SCE_KERNEL_ERROR_UNKNOWN_CBID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns the number of times a callback notification has been delayed while the callback function still has not been called for the callback indicated by <i>cbid</i>.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCheckCallback"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCheckCallback<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Check for existence of callback notification<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCheckCallback </b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in interrupt-enabled state)<br>Multithread safe<br>Dispatching must be enabled<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;No callback was reported&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The callback was reported and the callback function was executed&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Checks whether or not the occurrence of the callback has been reported for a callback created by the calling thread. If there is a callback that was reported by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelNotifyCallback">sceKernelNotifyCallback</a>(), the callback function registered for that callback is called. If no callback was reported, this function returns without doing anything. <br>The sceKernelCheckCallback() function cannot be called from within a callback function.<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferCallbackStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferCallbackStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get callback status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferCallbackStatus </b>( 
	SceUID <i>cbid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelCallbackInfo">SceKernelCallbackInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>cbid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Callback ID for which status is to be obtained&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specifies a pointer to a structure variable for receiving the callback status. Call this &nbsp;&nbsp;<br>&nbsp;&nbsp;function after assigning sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelCallbackInfo">SceKernelCallbackInfo</a>) to info-&gt;size.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_CBID">SCE_KERNEL_ERROR_UNKNOWN_CBID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the callback status.<br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelCallbackInfo">SceKernelCallbackInfo</a><br><br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSleepThread"></a><a name="sceKernelSleepThreadCB"></a>
<a name="sceKernelSleepThread / sceKernelSleepThreadCB"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSleepThread / sceKernelSleepThreadCB<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Switch this thread to wakeup-wait state<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSleepThread </b>(
	void
);
int <b>sceKernelSleepThreadCB </b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;sceKernelSleepThread&nbsp;</td>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;<br>&nbsp;Can&nbsp;be&nbsp;called&nbsp;from&nbsp;a&nbsp;thread&nbsp;(must&nbsp;be&nbsp;called&nbsp;in&nbsp;an&nbsp;&nbsp;<br>&nbsp;interrupt-enabled&nbsp;state)&nbsp;<br>&nbsp;Multithread&nbsp;safe&nbsp;<br>&nbsp;Dispatching&nbsp;must&nbsp;be&nbsp;enabled&nbsp;</td>
</tr>
<tr>
<td rowspan= 5  valign="top">&nbsp;sceKernelSleepThreadCB&nbsp;</td>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Can&nbsp;be&nbsp;called&nbsp;from&nbsp;a&nbsp;thread&nbsp;(must&nbsp;be&nbsp;called&nbsp;in&nbsp;an&nbsp;&nbsp;<br>&nbsp;interrupt-enabled&nbsp;state)&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Multithread&nbsp;safe&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Dispatching&nbsp;must&nbsp;be&nbsp;enabled&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Puts the calling thread into wakeup-wait state (WAIT state). <br>After entering wakeup-wait state, the thread can return from WAIT state by calling <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDonateWakeupThread">sceKernelDonateWakeupThread</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseWaitThread">sceKernelReleaseWaitThread</a>(). <br>If <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>() had previously been issued by another thread when sceKernelSleepThread() is issued, the wakeup request count will only be decremented, and control will return from sceKernelSleepThread() without the thread being placed in WAIT state. For details, see the description of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>() and <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDonateWakeupThread">sceKernelDonateWakeupThread</a>(). <br>sceKernelSleepThreadCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelSleepThread(). <br>If a callback notification is received for the calling thread while the thread is waiting for wakeup, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelWakeupThread">sceKernelCancelWakeupThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDonateWakeupThread">sceKernelDonateWakeupThread</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelWakeupThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelWakeupThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Wake up another thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelWakeupThread </b>( 
	SceUID <i>thid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the thread to be awakened. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the wakeup-wait state of the thread specified by <i>thid</i>. If the target thread is not in a WAIT state waiting for a wakeup, that is, if <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>() has not been executed, sceKernelWakeupThread() will increment the wakeup request count. <br>Even if the target thread issues <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>(), it will not transition to a WAIT state until <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>() is issued the number of times equal to the wakeup request count. <br>When this function is executed from a thread, dispatching must be enabled. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThreadCB">sceKernelSleepThreadCB</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelWakeupThread">sceKernelCancelWakeupThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDonateWakeupThread">sceKernelDonateWakeupThread</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelWakeupThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelWakeupThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel thread wakeup requests<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCancelWakeupThread </b>( 
	SceUID <i>thid</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the thread for which the wakeup requests are to be canceled. The calling &nbsp;&nbsp;<br>&nbsp;&nbsp;thread can be specified by SCE_KERNEL_TH_SELF(=0). &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;count(count&gt;=0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Wakeup request count&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Reads the wakeup request count for the thread indicated by <i>thid</i> and cancels all wakeup requests. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThreadCB">sceKernelSleepThreadCB</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDonateWakeupThread">sceKernelDonateWakeupThread</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDonateWakeupThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDonateWakeupThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transfer wakeup request count of calling thread to another thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDonateWakeupThread </b>(
	SceUID <i>thid</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in an interrupt-enabled, dispatch-enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of the thread to which the calling thread's wakeup request count is &nbsp;&nbsp;<br>&nbsp;&nbsp;to be transferred.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function transfers the calling thread's wakeup request count to the thread specified by <i>thid</i>. The calling thread's wakeup request count will be set to 0 and the thread will enter a WAIT state waiting for a wakeup. <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>(), sceKernelDonateWakeupThread(), or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseWaitThread">sceKernelReleaseWaitThread</a>() can be used to cause the thread to exit from the wakeup WAIT state.<br>sceKernelDonateWakeupThread() atomically performs the functions of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>() for the other thread, and the functions of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelWakeupThread">sceKernelCancelWakeupThread</a>() and <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>() for the calling thread. It transfers the wakeup count of the calling thread to the other thread and places the calling thread in a wakeup WAIT state.<br>Synchronization between threads that use functions which manipulate the thread wakeup counter such as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelWakeupThread">sceKernelCancelWakeupThread</a>(), and sceKernelDonateWakeupThread(), is limited to situations in which there is proper agreement between the manipulating thread and the thread whose wakeup counter is to be manipulated. To perform synchronization with other threads, each thread should use a synchronization primitive such as a semaphore or event flag, and not use sceKernelDonateWakeupThread(), so that the calling thread can freely use the wakeup counter.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWakeupThread">sceKernelWakeupThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelWakeupThread">sceKernelCancelWakeupThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThreadCB">sceKernelSleepThreadCB</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSuspendThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSuspendThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Switch another thread to SUSPEND state<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSuspendThread </b>( 
	SceUID <i>thid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of the thread to be switched to SUSPEND state. The calling thread &nbsp;&nbsp;<br>&nbsp;&nbsp;cannot be specified.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a> (Calling thread was specified)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_SUSPEND">SCE_KERNEL_ERROR_SUSPEND</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Switches the thread specified by <i>thid</i> to SUSPEND state and suspends execution of the thread. SUSPEND state is canceled by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelResumeThread">sceKernelResumeThread</a>(). <br>If the thread to be switched to a SUSPEND state by sceKernelSuspendThread() was already in a WAIT state, it will enter WAIT-SUSPEND state in which WAIT state and SUSPEND state are combined. If this thread's WAIT cancellation condition is subsequently satisfied, it will be switched to SUSPEND state. <br>However, if <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelResumeThread">sceKernelResumeThread</a>() is issued for this thread that is in WAIT-SUSPEND state, it will be returned to the same WAIT state in which it had previously been. <br>SUSPEND state is a state in which execution is suspended by a service call issued by another thread. Therefore, the calling thread cannot be specified in this service call. <br>If sceKernelSuspendThread() is issued multiple times for a given thread, an error will occur for the second and subsequent sceKernelSuspendThread(). <br>If this service call puts a thread in SUSPEND state that is making a device access, a system deadlock may occur.<br>This service call should only be used to support debugging.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelResumeThread"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelResumeThread<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Resume thread in SUSPEND state<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelResumeThread </b>( 
	SceUID <i>thid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Thread ID of the thread for which SUSPEND state is to be canceled.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a> (Calling thread was specified)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NOT_SUSPEND">SCE_KERNEL_ERROR_NOT_SUSPEND</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the SUSPEND state of the thread specified by <i>thid</i>. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelWaitThreadEnd"></a><a name="sceKernelWaitThreadEndCB"></a>
<a name="sceKernelWaitThreadEnd / sceKernelWaitThreadEndCB"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelWaitThreadEnd / sceKernelWaitThreadEndCB<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Wait for end of another thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelWaitThreadEnd </b>(
	SceUID <i>thid</i>,
	SceUInt *<i>timeout</i>
);
int <b>sceKernelWaitThreadEndCB </b>(
	SceUID <i>thid</i>,
	SceUInt *<i>timeout</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelWaitThreadEnd&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelWaitThreadEndCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
</table>
</div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>thid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the thread for which termination is to be awaited. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>timeout</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a variable of type SceUInt where the upper bound of the wait time &nbsp;&nbsp;<br>&nbsp;&nbsp;specified in microseconds is stored. When NULL is specified, waiting will &nbsp;&nbsp;<br>&nbsp;&nbsp;continue indefinitely. When the wait condition is satisfied, the remaining time is &nbsp;&nbsp;<br>&nbsp;&nbsp;returned by the function.   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;status(status&gt;=0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The target thread terminated normally&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_THREAD_TERMINATED">SCE_KERNEL_ERROR_THREAD_TERMINATED</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a> (Calling thread was specified)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT">SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT</a> (Target thread terminated and a negative value was specified for the termination status)<br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">These service calls wait for the end of the other thread specified by <i>thid</i>. When the thread completes normally, the return value of the thread's entry function or the end status provided as the argument to <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitThread">sceKernelExitThread</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitDeleteThread">sceKernelExitDeleteThread</a>() is returned as the return value. <br><br>sceKernelWaitThreadEndCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelWaitThreadEnd().<br>If a callback notification is received for the calling thread while the thread is waiting for the end of a thread, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitThread">sceKernelExitThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelExitDeleteThread">sceKernelExitDeleteThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateThread">sceKernelTerminateThread</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelTerminateDeleteThread">sceKernelTerminateDeleteThread</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateSema"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateSema<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create semaphore<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateSema</b>( 
	const char *<i>name</i>, 
	SceUInt <i>attr</i>, 
	int <i>initCount</i>, 
	int <i>maxCount</i>, 
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSemaOptParam">SceKernelSemaOptParam</a> *<i>optParam</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;semaphore.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;operator&nbsp;for&nbsp;visual&nbsp;<br>&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;<br>&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td rowspan= 3  valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Semaphore&nbsp;attribute.&nbsp;Specify&nbsp;either&nbsp;of&nbsp;the&nbsp;following&nbsp;values.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_SA_THFIFO&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;FIFO.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_SA_THPRI&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;the&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>initCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Initial&nbsp;value&nbsp;of&nbsp;semaphore&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>maxCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Maximum&nbsp;value&nbsp;of&nbsp;semaphore&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Reserved&nbsp;for&nbsp;future&nbsp;expansion.&nbsp;Specify&nbsp;NULL.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;semid(semid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Semaphore ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a semaphore. The ID of the semaphore is returned by the function. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSemaOptParam">SceKernelSemaOptParam</a><br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteSema"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteSema<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete semaphore<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteSema </b>( 
	SceUID <i>semid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>semid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the semaphore to be deleted. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_SEMID">SCE_KERNEL_ERROR_UNKNOWN_SEMID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the semaphore indicated by <i>semid</i>. An error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>) is returned for a thread that had already been registered in the semaphore wait queue. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSignalSema"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSignalSema<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Return semaphore resources<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSignalSema </b>( 
	SceUID <i>semid</i>, 
	int <i>signalcount</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>semid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of semaphore for which resources are to be returned  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>signalcount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of resources to be returned &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_SEMID">SCE_KERNEL_ERROR_UNKNOWN_SEMID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_SEMA_OVF">SCE_KERNEL_ERROR_SEMA_OVF</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Performs operations for returning the number of resources equal to <i>signalcount</i> to the semaphore indicated by <i>semid</i>. However, if the count has already reached the maximum value, the count value will not change and an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_SEMA_OVF">SCE_KERNEL_ERROR_SEMA_OVF</a>) will occur. <br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelWaitSema"></a><a name="sceKernelWaitSemaCB"></a><a name="sceKernelPollSema"></a>
<a name="sceKernelWaitSema / sceKernelWaitSemaCB / sceKernelPollSema"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelWaitSema / sceKernelWaitSemaCB / sceKernelPollSema<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Acquire semaphore resources<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelWaitSema </b>( 
	SceUID <i>semid</i>, 
	int <i>needcount</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelWaitSemaCB </b>( 
	SceUID <i>semid</i>, 
	int <i>needcount</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelPollSema </b>( 
	SceUID <i>semid</i>, 
	int <i>needcount</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelWaitSema&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelWaitSemaCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelPollSema&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Can be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (does not depend on interrupt-enabled or -disabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;</td>
</tr>
</table>
</div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>semid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of semaphore for which resources are to be acquired  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>needcount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of resources to be acquired   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>timeout</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a variable of type SceUInt where the upper bound of the wait time&nbsp;&nbsp;<br>&nbsp;&nbsp;specified in microseconds is stored. When <i>NULL</i> is specified, waiting will&nbsp;&nbsp;<br>&nbsp;&nbsp;continue indefinitely. When the resources are acquired, the remaining time is&nbsp;&nbsp;<br>&nbsp;&nbsp;returned by the function.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_COUNT">SCE_KERNEL_ERROR_ILLEGAL_COUNT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_SEMID">SCE_KERNEL_ERROR_UNKNOWN_SEMID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_SEMA_ZERO">SCE_KERNEL_ERROR_SEMA_ZERO</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Performs operations for acquiring the number of resources equal to <i>needcount</i> from the semaphore indicated by <i>semid</i>. If <i>timeout</i> is specified, a timeout will be set with a value in microseconds. If <i>timeout</i> is NULL, no timeout operation will be performed.<br>Note that when <i>timeout</i> is specified, the value indicated by <i>timeout</i> is updated when the service call ends. If the desired condition was met within the timeout period, the value will be updated with the time remaining. If the desired condition was not met, <i>timeout</i> will be set to 0, and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a> error will be returned.<br>sceKernelWaitSemaCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelWaitSema(). <br>If a callback notification is received for the calling thread while the thread is waiting for a semaphore, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br>The sceKernelPollSema() service call is equivalent to sceKernelWaitSema with the function for entering the WAIT state removed. It differs from sceKernelWaitSema in that when the count value of the target semaphore is less than <i>needcount</i>, it returns the error <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_SEMA_ZERO">SCE_KERNEL_ERROR_SEMA_ZERO</a>.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelSema"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelSema<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel semaphore resources<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCancelSema </b>( 
	SceUID <i>semid</i>, 
	int <i>setcount</i>, 
	int *<i>numWaitThreads</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>semid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Semaphore ID  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>setcount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Semaphore count value specification (if -1 is specified, the initial&nbsp;&nbsp;<br>&nbsp;&nbsp;value of the semaphore is used)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to the variable for receiving the number of threads for which&nbsp;&nbsp;<br>&nbsp;&nbsp;the wait state was canceled &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_SEMID">SCE_KERNEL_ERROR_UNKNOWN_SEMID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_COUNT">SCE_KERNEL_ERROR_ILLEGAL_COUNT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the wait state of a thread that is waiting for the semaphore specified by <i>semid</i>. The thread for which the wait state was canceled can determine that it was canceled from the return value of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSema">sceKernelWaitSema</a>(). Subsequently, the count value specified by <i>setcount</i> is set for the semaphore. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferSemaStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferSemaStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get semaphore status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
<i>int</i> <b>sceKernelReferSemaStatus </b>( 
	SceUID <i>semid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSemaInfo">SceKernelSemaInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>semid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of semaphore for which status is to be obtained   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the semaphore status. &nbsp;&nbsp;<br>&nbsp;&nbsp;Be sure to assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSemaInfo">SceKernelSemaInfo</a>) to info-&gt;size when calling this function.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_SEMID">SCE_KERNEL_ERROR_UNKNOWN_SEMID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of a semaphore.<br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSemaInfo">SceKernelSemaInfo</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateEventFlag"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateEventFlag<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create event flag<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateEventFlag </b>( 
	const char *<i>name</i>, 
	SceUInt <i>attr</i>, 
	SceUInt initPattern, 
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelEventFlagOptParam">SceKernelEventFlagOptParam</a> *<i>optParam</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;event&nbsp;flag.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;operator&nbsp;for&nbsp;visual&nbsp;<br>&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;<br>&nbsp;name&nbsp;is&nbsp;unique.&nbsp;&nbsp;</td>
</tr>
<tr>
<td rowspan= 3  valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Event&nbsp;flag&nbsp;attribute.&nbsp;Specify&nbsp;either&nbsp;of&nbsp;the&nbsp;following&nbsp;values.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_EA_SINGLE&nbsp;</td>
<td valign="top">&nbsp;It&nbsp;is&nbsp;not&nbsp;permitted&nbsp;to&nbsp;wait&nbsp;for&nbsp;multiple&nbsp;threads&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_EA_MULTI&nbsp;</td>
<td valign="top">&nbsp;It&nbsp;is&nbsp;permitted&nbsp;to&nbsp;wait&nbsp;for&nbsp;multiple&nbsp;threads&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>initPattern</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Specifies&nbsp;the&nbsp;initial&nbsp;value&nbsp;of&nbsp;the&nbsp;event&nbsp;flag.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Reserved&nbsp;for&nbsp;future&nbsp;expansion.&nbsp;Specify&nbsp;NULL.&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;evfid(evfid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Event flag ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates an event flag and sets its initial value. The ID of the created event flag is returned by the function. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelEventFlagOptParam">SceKernelEventFlagOptParam</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteEventFlag"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteEventFlag<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete event flag<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteEventFlag </b>( 
	SceUID <i>evfid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>evfid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the event flag to be deleted.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_EVFID">SCE_KERNEL_ERROR_UNKNOWN_EVFID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the event flag specified by <i>evfid</i>. An error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>) will be returned for a thread that is waiting for a condition to be satisfied for the target event flag. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSetEventFlag"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSetEventFlag<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Set event flag<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSetEventFlag </b>( 
	SceUID <i>evfid</i>, 
	SceUInt <i>bitpattern</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>evfid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the event flag to be manipulated. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>bitpattern</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Set the bits indicated by <i>bitpattern</i> for the event flag. In other words, the&nbsp;&nbsp;<br>&nbsp;&nbsp;new value of the event flag will result from the logical OR of the current&nbsp;&nbsp;<br>&nbsp;&nbsp;event flag and <i>bitpattern</i>. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_EVFID">SCE_KERNEL_ERROR_UNKNOWN_EVFID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sets bits of the event flag indicated by <i>evfid</i>. If the new value of the event flag satisfies a wait condition, the WAIT state will be canceled for the associated thread.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelClearEventFlag"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelClearEventFlag<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Clear event flag<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelClearEventFlag </b>( 
	SceUID <i>evfid</i>, 
	SceUInt <i>bitpattern</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>evfid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the event flag to be manipulated.   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>bitpattern</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Clears the event flag value corresponding to the bits that are 0 in <i>bitpattern</i>.&nbsp;&nbsp;<br>&nbsp;&nbsp;In other words, the new value of the event flag will result from the logical&nbsp;&nbsp;<br>&nbsp;&nbsp;AND of the current event flag and <i>bitpattern</i>. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_EVFID">SCE_KERNEL_ERROR_UNKNOWN_EVFID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Clears bits of the event flag indicated by <i>evfid</i>. The WAIT state of a thread waiting for the event will not be canceled due to this service call. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelWaitEventFlag"></a><a name="sceKernelWaitEventFlagCB"></a><a name="sceKernelPollEventFlag"></a>
<a name="sceKernelWaitEventFlag / sceKernelWaitEventFlagCB / sceKernelPollEventFlag"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelWaitEventFlag / <br>sceKernelWaitEventFlagCB / <br>sceKernelPollEventFlag<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Wait for event flag<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelWaitEventFlag </b>( 
	SceUID <i>evfid</i>, 
	SceUInt <i>bitpattern</i>, 
	int <i>waitmode</i>, 
	SceUInt *<i>resultpat</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelWaitEventFlagCB </b>( 
	SceUID <i>evfid</i>, 
	SceUInt <i>bitpattern</i>, 
	int <i>waitmode</i>, 
	SceUInt *<i>resultpat</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelPollEventFlag </b>( 
	SceUID <i>evfid</i>, 
	SceUInt <i>bitpattern</i>, 
	int <i>waitmode</i>, 
	SceUInt *<i>resultpat</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelWaitEventFlag&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelWaitEventFlagCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelPollEventFlag&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Can be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (does not depend on interrupt-disabled or -enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>evfid</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;ID&nbsp;of&nbsp;the&nbsp;event&nbsp;flag&nbsp;to&nbsp;be&nbsp;manipulated.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>bitpattern</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Value&nbsp;to&nbsp;be&nbsp;compared&nbsp;with&nbsp;the&nbsp;event&nbsp;flag.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td rowspan= 6  valign="top">&nbsp;<i>waitmode</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Wait&nbsp;mode.&nbsp;Specify&nbsp;either&nbsp;of&nbsp;the&nbsp;following&nbsp;values.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_EW_AND&nbsp;</td>
<td valign="top">&nbsp;AND&nbsp;wait&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_EW_OR&nbsp;</td>
<td valign="top">&nbsp;OR&nbsp;wait&nbsp;</td>
</tr>
<tr>
<td colspan= 2  valign="top">&nbsp;Also,&nbsp;as&nbsp;an&nbsp;option,&nbsp;either&nbsp;one&nbsp;of&nbsp;the&nbsp;following&nbsp;specifications&nbsp;can&nbsp;be&nbsp;added&nbsp;by&nbsp;logically&nbsp;<br>&nbsp;ORing&nbsp;them&nbsp;with&nbsp;the&nbsp;wait&nbsp;mode.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_EW_CLEAR_ALL&nbsp;</td>
<td valign="top">&nbsp;Clear&nbsp;all&nbsp;bits&nbsp;after&nbsp;wait&nbsp;condition&nbsp;is&nbsp;satisfied&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_EW_CLEAR_PAT&nbsp;</td>
<td valign="top">&nbsp;Clear&nbsp;bits&nbsp;specified&nbsp;by&nbsp;<i>bitpattern</i>&nbsp;after&nbsp;wait&nbsp;condition&nbsp;is&nbsp;satisfied&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>resultpat</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;the&nbsp;variable&nbsp;for&nbsp;receiving&nbsp;the&nbsp;event&nbsp;flag&nbsp;value&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>timeout</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;a&nbsp;variable&nbsp;of&nbsp;type&nbsp;SceUInt&nbsp;where&nbsp;the&nbsp;upper&nbsp;bound&nbsp;of&nbsp;the&nbsp;wait&nbsp;<br>&nbsp;time&nbsp;specified&nbsp;in&nbsp;microseconds&nbsp;is&nbsp;stored.&nbsp;When&nbsp;NULL&nbsp;is&nbsp;specified,&nbsp;waiting&nbsp;<br>&nbsp;will&nbsp;continue&nbsp;indefinitely.&nbsp;When&nbsp;the&nbsp;wait&nbsp;condition&nbsp;is&nbsp;satisfied,&nbsp;the&nbsp;<br>&nbsp;remaining&nbsp;time&nbsp;is&nbsp;returned&nbsp;by&nbsp;the&nbsp;function.&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MODE">SCE_KERNEL_ERROR_ILLEGAL_MODE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_EVFID">SCE_KERNEL_ERROR_UNKNOWN_EVFID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_EVF_COND">SCE_KERNEL_ERROR_EVF_COND</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_EVF_MULTI">SCE_KERNEL_ERROR_EVF_MULTI</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_EVF_ILPAT">SCE_KERNEL_ERROR_EVF_ILPAT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">sceKernelWaitEventFlag() is a service call that waits for the event flag indicated by evfid to be set according to the wait cancellation condition indicated by <i>waitmode</i>. If the event flag indicated by <i>evfid</i> already satisfies the wait cancellation condition indicated by <i>waitmode</i>, the issuing thread continues executing without entering a wait state. <br><br>If SCE_KERNEL_EW_AND is specified for <i>waitmode</i>, the service call waits until all bits indicated by <i>bitpattern</i> become 1. If SCE_KERNEL_EW_OR is specified for <i>waitmode</i>, the service call waits until any of the bits indicated by <i>bitpattern</i> becomes 1. <br>If SCE_KERNEL_EW_CLEAR_ALL is also specified for <i>waitmode</i>, all bits of the event flag are cleared to 0 when the cancellation condition is satisfied and the wait is canceled for this thread. If SCE_KERNEL_EW_CLEAR_PAT is also specified for <i>waitmode</i>, the bits specified by <i>bitpattern</i> are cleared to 0 when the cancellation condition is satisfied and the wait is canceled for this thread. <br><br>The following cases indicate the event flag values that are returned in resultpat. NULL can be specified when a value isn't needed. <br></div>
<div style="margin-left:35px;"><ul>
<li> When a wait cancellation condition is satisfied (when <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a> is returned), immediately thereafter, the event flag value before the clear is performed, as determined by the SCE_KERNEL_EW_CLEAR_ALL and SCE_KERNEL_EW_CLEAR_PAT specifications, is returned. 
<li> When leaving a wait state for some reason other than a wait cancellation condition being satisfied (such as when one of the following errors is returned: <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a>, <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>, <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a>, <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_EVF_COND">SCE_KERNEL_ERROR_EVF_COND</a>, <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a>), the event flag value present immediately before leaving the wait is returned. If a cancel is performed by calling <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelEventFlag">sceKernelCancelEventFlag</a>(), the event flag value that had been previously set is returned. 
</ul></div>
<div style="margin-left:50px;"><br>If <i>timeout</i> is specified, a timeout will be set with a value in microseconds. If <i>timeout</i> is NULL, no timeout operation will be performed.<br>Note that when <i>timeout</i> is specified, the value indicated by <i>timeout</i> is updated when the service call ends. If the desired condition was met within the timeout period, the value will be updated with the time remaining. If the desired condition was not met, <i>timeout</i> will be set to 0, and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a> error will be returned.<br><br>sceKernelWaitEventFlagCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelWaitEventFlag(). <br>If a callback notification is received for the calling thread while the thread is waiting for an event flag, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br><br><br>sceKernelPollEventFlag() is a service call that is equivalent to sceKernelWaitEventFlag() except that the function for entering the wait state has been removed. It differs from sceKernelWaitEventFlag() in that it returns immediately with the error code <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_EVF_COND">SCE_KERNEL_ERROR_EVF_COND</a> if the wait cancellation condition is not satisfied. In this case, an SCE_KERNEL_EW_CLEAR_ALL/SCE_KERNEL_EW_CLEAR_PAT specification is ignored. <br>If a thread is already waiting for an event flag that has the SCE_KERNEL_EA_SINGLE attribute, another thread cannot execute sceKernelWaitEventFlag() or sceKernelPollEventFlag() for that event flag. In this case, control is immediately returned with an error to the thread that executed sceKernelWaitEventFlag() or sceKernelPollEventFlag() last. <br>If multiple threads enter wait states for an event flag that has the SCE_KERNEL_EA_MULTI attribute, a thread queue is created. In this case, multiple wait states may be canceled for the multiple threads by a single call to <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetEventFlag">sceKernelSetEventFlag</a>(). <br>The thread queue order will be as follows: the thread that entered the wait state first will be at the head of the queue and the subsequent threads will be arranged in the order they entered the wait state. If the queue contains a thread that has the SCE_KERNEL_EW_CLEAR_ALL or SCE_KERNEL_EW_CLEAR_PAT specification, when the wait state cancellation condition of that thread is satisfied, the event flag will be cleared at the same time that the wait state is canceled. Since threads that are behind the thread for which SCE_KERNEL_EW_CLEAR_ALL or SCE_KERNEL_EW_CLEAR_PAT were specified will see the event flag after it is cleared, there may be cases when the wait state will not be canceled. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelEventFlag"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelEventFlag<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel event flag wait<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>int <b>sceKernelCancelEventFlag </b>( 
	SceUID <i>evfid</i>, 
	SceUInt <i>setpattern</i>, 
	int *<i>numWaitThreads</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>evfid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the event flag for which the wait state is to be canceled. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>setpattern</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Value to be set for the event flag.   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to the variable for receiving the number of threads for which &nbsp;&nbsp;<br>&nbsp;&nbsp;the wait state was canceled  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_EVFID">SCE_KERNEL_ERROR_UNKNOWN_EVFID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the wait state of a thread that is waiting on the event flag specified by <i>evfid</i>. The thread for which the wait state was canceled can determine that it was canceled from the return value of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitEventFlag">sceKernelWaitEventFlag</a>(). Subsequently, the event flag value specified by <i>setpattern</i> is set in the event flag. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferEventFlagStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferEventFlagStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get event flag status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
<i>int</i> <b>sceKernelReferEventFlagStatus </b>( 
	SceUID <i>evfid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelEventFlagInfo">SceKernelEventFlagInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>evfid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of event flag for which the status is to be obtained &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to the structure variable for receiving the event flag status. Be sure to&nbsp;&nbsp;<br>&nbsp;&nbsp;assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelEventFlagInfo">SceKernelEventFlagInfo</a>) to <i>info-&gt;size</i> when calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_EVFID">SCE_KERNEL_ERROR_UNKNOWN_EVFID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of an event flag. <br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelEventFlagInfo">SceKernelEventFlagInfo</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create a mutex<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateMutex</b>(
	const char *<i>name</i>,
	SceUInt <i>attr</i>,
	int <i>initCount</i>,
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMutexOptParam">SceKernelMutexOptParam</a> *<i>optParam</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;mutex.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;operator&nbsp;for&nbsp;visual&nbsp;<br>&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;<br>&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td rowspan= 4  valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Mutex&nbsp;attribute.&nbsp;Specify&nbsp;either&nbsp;one&nbsp;of&nbsp;SCE_KERNEL_MA_THFIFO&nbsp;and&nbsp;SCE_KERNEL_MA_THPRI&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MA_THFIFO&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;FIFO.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MA_THPRI&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;the&nbsp;&nbsp;<br>&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MA_RECURSIVE&nbsp;</td>
<td valign="top">&nbsp;A&nbsp;recursive&nbsp;lock&nbsp;is&nbsp;allowed&nbsp;by&nbsp;the&nbsp;thread&nbsp;&nbsp;<br>&nbsp;that&nbsp;acquired&nbsp;the&nbsp;mutex.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>initCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Initial&nbsp;lock&nbsp;count&nbsp;of&nbsp;the&nbsp;mutex&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Reserved&nbsp;for&nbsp;future&nbsp;expansion.&nbsp;Specify&nbsp;NULL.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;mtxid (mtxid &gt; 0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Mutex ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a mutex. The ID of the mutex is returned by the function.<br>If <i>initCount</i> is a positive number, the mutex will be initially owned by the creating thread and locked <i>initCount</i> times. If <i>initCount</i> is zero, the mutex will be created in a non-acquired state.<br>A mutex can be created with <i>initCount</i> &gt;= 2 only when the SCE_KERNEL_MA_RECURSIVE attribute is also specified.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMutexOptParam">SceKernelMutexOptParam</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete a mutex<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteMutex </b>(
	SceUID <i>mtxid</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mtxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the mutex to be deleted.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MUTEXID">SCE_KERNEL_ERROR_UNKNOWN_MUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the mutex indicated by <i>mtxid</i>. An error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>) is returned for a thread that had already been registered in the mutex wait queue.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelLockMutex"></a><a name="sceKernelLockMutexCB"></a><a name="sceKernelTryLockMutex"></a>
<a name="sceKernelLockMutex / sceKernelLockMutexCB / sceKernelTryLockMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelLockMutex / sceKernelLockMutexCB / sceKernelTryLockMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Acquire mutex resource<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelLockMutex</b> (
	SceUID <i>mtxid</i>,
	int <i>lockcount</i>,
	SceUInt *<i>timeout</i>
);
int <b>sceKernelLockMutexCB</b>(
	SceUID <i>mtxid</i>,
	int <i>lockcount</i>,
	SceUInt *<i>timeout</i>
);
int <b>sceKernelTryLockMutex </b>(
	SceUID <i>mtxid</i>,
	int <i>lockcount</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td rowspan= 4  valign="top">&nbsp;sceKernelLockMutex&nbsp;</td>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Can&nbsp;be&nbsp;called&nbsp;from&nbsp;a&nbsp;thread&nbsp;(must&nbsp;be&nbsp;called&nbsp;in&nbsp;an&nbsp;&nbsp;<br>&nbsp;interrupt-enabled&nbsp;state)&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Multithread&nbsp;safe&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Dispatching&nbsp;must&nbsp;be&nbsp;enabled&nbsp;</td>
</tr>
<tr>
<td rowspan= 4  valign="top">&nbsp;sceKernelLockMutexCB&nbsp;</td>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Can&nbsp;be&nbsp;called&nbsp;from&nbsp;a&nbsp;thread&nbsp;(must&nbsp;be&nbsp;called&nbsp;in&nbsp;an&nbsp;&nbsp;<br>&nbsp;interrupt-enabled&nbsp;state)&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Multithread&nbsp;safe&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Dispatching&nbsp;must&nbsp;be&nbsp;enabled&nbsp;</td>
</tr>
<tr>
<td rowspan= 3  valign="top">&nbsp;sceKernelTryLockMutex&nbsp;</td>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Can&nbsp;be&nbsp;called&nbsp;from&nbsp;a&nbsp;thread&nbsp;&nbsp;<br>&nbsp;(does&nbsp;not&nbsp;depend&nbsp;on&nbsp;interrupt-disabled&nbsp;or&nbsp;-enabled&nbsp;state)&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Multithread&nbsp;safe&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mtxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of mutex for which resource is to be acquired&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>lockcount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of times mutex is to be locked after the &nbsp;&nbsp;<br>&nbsp;&nbsp;resource acquisition (greater than or equal to 1)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>timeout</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to an SceUInt type variable in which the maximum wait time specified in microseconds is stored.&nbsp;&nbsp;<br>&nbsp;&nbsp;If NULL is specified, waiting will continue indefinitely.&nbsp;&nbsp;<br>&nbsp;&nbsp;When the resource is acquired, the remaining time will &nbsp;&nbsp;<br>&nbsp;&nbsp;be returned.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_COUNT">SCE_KERNEL_ERROR_ILLEGAL_COUNT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MUTEXID">SCE_KERNEL_ERROR_UNKNOWN_MUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MUTEX_RECURSIVE">SCE_KERNEL_ERROR_MUTEX_RECURSIVE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MUTEX_LOCK_OVF">SCE_KERNEL_ERROR_MUTEX_LOCK_OVF</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Performs operations for acquiring the mutex indicated by <i>mtxid</i> and locking it <i>lockcount</i> times. If <i>timeout</i> is specified, a timeout will be set with a value in microseconds. If <i>timeout</i> is NULL, no timeout operation will be performed.<br>Note that when <i>timeout</i> is specified, the value indicated by <i>timeout</i> is updated when the service call ends. If the desired condition was met within the timeout period, the value will be updated with the time remaining. If the desired condition was not met, <i>timeout</i> will be set to 0, and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a> error will be returned.<br>sceKernelLockMutexCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelLockMutex(). <br>If a callback notification is received for the calling thread while the thread is waiting for a mutex, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br>The sceKernelTryLockMutex() service call is equivalent to sceKernelLockMutex() with the function for entering the WAIT state removed. It differs from sceKernelLockMutex() in that when the mutex was acquired by another thread, it returns the error <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MUTEX_FAILED_TO_OWN">SCE_KERNEL_ERROR_MUTEX_FAILED_TO_OWN</a>.  <br>To lock a mutex with a value of 2 or more specified for <i>lockCount</i>, the SCE_KERNEL_MA_RECURSIVE attribute must have been specified when the mutex was created.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelUnlockMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelUnlockMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Return mutex resource<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelUnlockMutex </b>(
	SceUID <i>mtxid</i>,
	int <i>unlockcount</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mtxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of mutex for which resource is to be returned&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>unlockcount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of times mutex is to be unlocked before resource is returned&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MUTEXID">SCE_KERNEL_ERROR_UNKNOWN_MUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MUTEX_NOT_OWNED">SCE_KERNEL_ERROR_MUTEX_NOT_OWNED</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF">SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Performs operations for unlocking the mutex indicated by <i>mtxid</i> <i>unlockcount</i> times. The mutex resource is released when the lock count becomes zero. Note that if an unlock count is specified such that the lock count would become negative, the lock count is not changed, and an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF">SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF</a>) is returned instead.<br>To unlock a mutex with a value of 2 or more specified for <i>unlockCount</i>, the SCE_KERNEL_MA_RECURSIVE attribute must have been specified when the mutex was created.<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel mutex resource<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCancelMutex </b>(
	SceUID <i>mtxid</i>,
	int <i>newcount</i>,
	int *<i>numWaitThreads</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mtxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Mutex ID&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>newcount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Mutex lock count value specification&nbsp;&nbsp;<br>&nbsp;&nbsp;(If 0 is specified, the mutex is not locked after it is canceled.)&nbsp;&nbsp;<br>&nbsp;&nbsp;(If -1 is specified, the initial lock count when the mutex was created is used.) &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a variable for receiving the number of threads for which the &nbsp;&nbsp;<br>&nbsp;&nbsp;wait state was canceled &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MUTEXID">SCE_KERNEL_ERROR_UNKNOWN_MUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_COUNT">SCE_KERNEL_ERROR_ILLEGAL_COUNT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the wait states of threads that are waiting for the mutex specified by <i>mtxid</i>. <br>A thread for which the wait state was canceled can determine that it was canceled from the return value of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelLockMutex">sceKernelLockMutex</a>(). Subsequently, the lock count value specified by <i>newcount</i> is set for the mutex. If <i>newcount</i> is zero, the mutex will not be acquired.<br><i>newcount</i> must be zero when sceKernelCancelMutex() is called from an interrupt handler.<br>To reallocate a mutex with a value of 2 or more specified for <i>newCount</i>, the SCE_KERNEL_MA_RECURSIVE attribute must have been specified when the mutex was created.<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferMutexStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferMutexStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get mutex status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferMutexStatus </b>(
	SceUID <i>mtxid</i>,
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMutexInfo">SceKernelMutexInfo</a> *<i>info</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mtxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of mutex for which status is to be obtained   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the mutex status.&nbsp;&nbsp;<br>&nbsp;&nbsp;Be sure to assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMutexInfo">SceKernelMutexInfo</a>) to info-&gt;size when &nbsp;&nbsp;<br>&nbsp;&nbsp;calling this function.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MUTEXID">SCE_KERNEL_ERROR_UNKNOWN_MUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of a mutex. This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMutexInfo">SceKernelMutexInfo</a><br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateLwMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateLwMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create a lightweight mutex<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCreateLwMutex</b>(
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexWork">SceKernelLwMutexWork</a> *<i>work</i>,
	const char *<i>name</i>,
	SceUInt <i>attr</i>,
	int <i>initCount</i>,
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexOptParam">SceKernelLwMutexOptParam</a> *<i>optParam</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>work</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Work&nbsp;area&nbsp;of&nbsp;the&nbsp;lightweight&nbsp;mutex&nbsp;to&nbsp;be&nbsp;created.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;lightweight&nbsp;mutex.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;operator&nbsp;for&nbsp;&nbsp;<br>&nbsp;visual&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;to&nbsp;determine&nbsp;if&nbsp;<br>&nbsp;the&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td rowspan= 4  valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Lightweight&nbsp;mutex&nbsp;attribute.&nbsp;Specify&nbsp;either&nbsp;one&nbsp;of&nbsp;SCE_KERNEL_LWMA_THFIFO&nbsp;and&nbsp;SCE_KERNEL_LWMA_THPRI.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_LWMA_THFIFO&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;FIFO.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_LWMA_THPRI&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;by&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_LWMA_RECURSIVE&nbsp;</td>
<td valign="top">&nbsp;A&nbsp;recursive&nbsp;lock&nbsp;is&nbsp;allowed&nbsp;by&nbsp;the&nbsp;<br>&nbsp;thread&nbsp;that&nbsp;acquired&nbsp;the&nbsp;lightweight&nbsp;<br>&nbsp;mutex.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>initCount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Initial&nbsp;lock&nbsp;count&nbsp;of&nbsp;the&nbsp;lightweight&nbsp;mutex&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Reserved&nbsp;for&nbsp;future&nbsp;expansion.&nbsp;Specify&nbsp;NULL.&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a lightweight mutex.<br>If <i>initCount</i> is a positive number, the lightweight mutex will be initially owned by the creating thread and locked <i>initCount</i> times. If <i>initCount</i> is zero, the lightweight mutex will be created in a non-acquired state.<br>A lightweight mutex can be created with <i>initCount</i> &gt;= 2 only when the SCE_KERNEL_LWMA_RECURSIVE attribute is also specified.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexOptParam">SceKernelLwMutexOptParam</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteLwMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteLwMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete a lightweight mutex<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteLwMutex </b>(
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexWork">SceKernelLwMutexWork</a> *<i>work</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>work</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Work area of the lightweight mutex to be deleted.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID">SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the lightweight mutex indicated by <i>work</i>. An error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>) is returned for a thread that had already been registered in the lightweight mutex wait queue.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelLockLwMutex"></a><a name="sceKernelLockLwMutexCB"></a><a name="sceKernelTryLockLwMutex"></a>
<a name="sceKernelLockLwMutex / sceKernelLockLwMutexCB / sceKernelTryLockLwMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelLockLwMutex / sceKernelLockLwMutexCB / sceKernelTryLockLwMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Acquire lightweight mutex resource<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelLockLwMutex</b> (
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexWork">SceKernelLwMutexWork</a> *<i>work</i>,
	int <i>lockcount</i>,
	SceUInt *<i>timeout</i>
);
int <b>sceKernelLockLwMutexCB</b>(
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexWork">SceKernelLwMutexWork</a> *<i>work</i>,
	int <i>lockcount</i>,
	SceUInt *<i>timeout</i>
);
int <b>sceKernelTryLockLwMutex </b>(
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexWork">SceKernelLwMutexWork</a> *<i>work</i>,
	int <i>lockcount</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td rowspan= 4  valign="top">&nbsp;sceKernelLockLwMutex&nbsp;</td>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Can&nbsp;be&nbsp;called&nbsp;from&nbsp;a&nbsp;thread&nbsp;(must&nbsp;be&nbsp;called&nbsp;in&nbsp;an&nbsp;&nbsp;<br>&nbsp;interrupt-enabled&nbsp;state)&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Multithread&nbsp;safe&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Dispatching&nbsp;must&nbsp;be&nbsp;enabled&nbsp;</td>
</tr>
<tr>
<td rowspan= 4  valign="top">&nbsp;sceKernelLockLwMutexCB&nbsp;</td>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Can&nbsp;be&nbsp;called&nbsp;from&nbsp;a&nbsp;thread&nbsp;(must&nbsp;be&nbsp;called&nbsp;in&nbsp;an&nbsp;&nbsp;<br>&nbsp;interrupt-enabled&nbsp;state)&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Multithread&nbsp;safe&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Dispatching&nbsp;must&nbsp;be&nbsp;enabled&nbsp;</td>
</tr>
<tr>
<td rowspan= 3  valign="top">&nbsp;sceKernelTryLockLwMutex&nbsp;</td>
<td valign="top">&nbsp;Cannot&nbsp;be&nbsp;called&nbsp;from&nbsp;an&nbsp;interrupt&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Can&nbsp;be&nbsp;called&nbsp;from&nbsp;a&nbsp;thread&nbsp;&nbsp;<br>&nbsp;(does&nbsp;not&nbsp;depend&nbsp;on&nbsp;interrupt-disabled&nbsp;or&nbsp;-enabled&nbsp;state)&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Multithread&nbsp;safe&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>work</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Lightweight mutex work area for which resource is to be acquired&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>lockcount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of times lightweight mutex is to be locked after resource acquisition (greater than or equal to 1)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>timeout</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to an SceUInt type variable in which the &nbsp;&nbsp;<br>&nbsp;&nbsp;maximum wait time specified in microseconds is stored.&nbsp;&nbsp;<br>&nbsp;&nbsp;If NULL is specified, waiting will continue indefinitely.&nbsp;&nbsp;<br>&nbsp;&nbsp;When the resource is acquired, the remaining time will be &nbsp;&nbsp;<br>&nbsp;&nbsp;returned. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_COUNT">SCE_KERNEL_ERROR_ILLEGAL_COUNT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID">SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_LWMUTEX_RECURSIVE">SCE_KERNEL_ERROR_LWMUTEX_RECURSIVE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_LWMUTEX_LOCK_OVF">SCE_KERNEL_ERROR_LWMUTEX_LOCK_OVF</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Performs operations for acquiring the lightweight mutex indicated by <i>work</i> and locking it <i>lockcount</i> times. If <i>timeout</i> is specified, a timeout will be set with a value in microseconds. If <i>timeout</i> is NULL, no timeout operation will be performed.<br>Note that when <i>timeout</i> is specified, the value indicated by <i>timeout</i> is updated when the service call ends. If the desired condition was met within the timeout period, the value will be updated with the time remaining. If the desired condition was not met, <i>timeout</i> will be set to 0 and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a> error will be returned.<br>sceKernelLockLwMutexCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelLockLwMutex(). If a callback notification is received for the calling thread while the thread is waiting for a lightweight mutex, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br>The sceKernelTryLockLwMutex() service call is equivalent to sceKernelLockLwMutex() with the function for entering the WAIT state removed. It differs from sceKernelLockLwMutex() in that when the lightweight mutex was acquired by another thread, it returns the error <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_LWMUTEX_FAILED_TO_OWN">SCE_KERNEL_ERROR_LWMUTEX_FAILED_TO_OWN</a>.<br>To lock a lightweight mutex with a value of 2 or more specified for <i>lockCount</i>, the SCE_KERNEL_LWMA_RECURSIVE attribute must have been specified when the lightweight mutex was created.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelUnlockLwMutex"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelUnlockLwMutex<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Return lightweight mutex resource<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelUnlockLwMutex </b>(
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexWork">SceKernelLwMutexWork</a> *<i>work</i>,
	int <i>unlockcount</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>work</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Work area of lightweight mutex for which &nbsp;&nbsp;<br>&nbsp;&nbsp;resource is to be returned&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>unlockcount</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of times lightweight mutex is to be &nbsp;&nbsp;<br>&nbsp;&nbsp;unlocked before resource is returned&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID">SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_LWMUTEX_NOT_OWNED">SCE_KERNEL_ERROR_LWMUTEX_NOT_OWNED</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_LWMUTEX_UNLOCK_UDF">SCE_KERNEL_ERROR_LWMUTEX_UNLOCK_UDF</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Performs operations for unlocking the lightweight mutex indicated by <i>work unlockcount</i> times. The lightweight mutex resource is released when the lock count becomes zero. Note that if an unlock count is specified such that the lock count would become negative, the lock count is not changed, and an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_LWMUTEX_UNLOCK_UDF">SCE_KERNEL_ERROR_LWMUTEX_UNLOCK_UDF</a>) is returned instead.<br>To unlock a lightweight mutex with a value of 2 or more specified for <i>unlockCount</i>, the SCE_KERNEL_MA_RECURSIVE attribute must have been specified when the lightweight mutex was created.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferLwMutexStatus"></a><a name="sceKernelReferLwMutexStatusById"></a>
<a name="sceKernelReferLwMutexStatus / sceKernelReferLwMutexStatusById"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferLwMutexStatus / sceKernelReferLwMutexStatusById<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get lightweight mutex status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferLwMutexStatus </b>(
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexWork">SceKernelLwMutexWork</a> *<i>work</i>,
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexInfo">SceKernelLwMutexInfo</a> *<i>info</i>
);
int <b>sceKernelReferLwMutexStatusById </b>(
	SceUID <i>uid</i>,
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexInfo">SceKernelLwMutexInfo</a> *<i>info</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>work</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Work area of lightweight mutex for which status is to be obtained.  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>uid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of lightweight mutex for which status is to be obtained&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the lightweight mutex status.&nbsp;&nbsp;<br>&nbsp;&nbsp;Be sure to assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexInfo">SceKernelLwMutexInfo</a>) to info-&gt;size when calling &nbsp;&nbsp;<br>&nbsp;&nbsp;this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID">SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of a lightweight mutex. This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelLwMutexInfo">SceKernelLwMutexInfo</a><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateMbx"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateMbx<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create message box<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateMbx</b>( 
	const char *<i>name</i>, 
	SceUInt <i>attr</i>, 
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMbxOptParam">SceKernelMbxOptParam</a> *<i>optParam</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;message&nbsp;box.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;operator&nbsp;for&nbsp;visual&nbsp;<br>&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;<br>&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td rowspan= 6  valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Attribute&nbsp;of&nbsp;the&nbsp;message&nbsp;box.&nbsp;<br>&nbsp;Specify&nbsp;one&nbsp;of&nbsp;the&nbsp;following&nbsp;for&nbsp;queuing&nbsp;the&nbsp;wait&nbsp;thread.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MBA_THFIFO&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;FIFO.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MBA_THPRI&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;the&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td colspan= 2  valign="top">&nbsp;Specify&nbsp;one&nbsp;of&nbsp;the&nbsp;following&nbsp;for&nbsp;queuing&nbsp;the&nbsp;message.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MBA_MSFIFO&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;message&nbsp;is&nbsp;queued&nbsp;using&nbsp;FIFO.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MBA_MSPRI&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;message&nbsp;is&nbsp;queued&nbsp;using&nbsp;the&nbsp;message&nbsp;priority.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Reserved&nbsp;for&nbsp;future&nbsp;expansion.&nbsp;Specify&nbsp;NULL.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;mbxid(mbxid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Message box ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a message box. The ID of the created message box is returned by the function. <br> <br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMbxOptParam">SceKernelMbxOptParam</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteMbx"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteMbx<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete message box<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteMbx </b>( 
	SceUID <i>mbxid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mbxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the message box to delete. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MBXID">SCE_KERNEL_ERROR_UNKNOWN_MBXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the message box indicated by <i>mbxid</i>. <br>If a thread is waiting for a message in the target message box, this service call will end normally and an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>) will be returned to the thread in the wait state. <br>If a message is remaining in the target message box, the message box will be deleted without generating an error and the message inside will be left as is. <br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSendMbx"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSendMbx<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Send to message box<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSendMbx</b>( 
	SceUID <i>mbxid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMsgPacket">SceKernelMsgPacket</a> *<i>sendmsg</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mbxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Sending destination message box.  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>sendmsg</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Starting address of the message packet to be sent. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MBXID">SCE_KERNEL_ERROR_UNKNOWN_MBXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MBOX_LOOP">SCE_KERNEL_ERROR_MBOX_LOOP</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sends a message packet with a starting address of <i>sendmsg</i> to the target message box indicated by <i>mbxid</i>. The contents of the message packet aren't copied; only the starting address (the value of <i>sendmsg</i>) is passed when the message is received. <br>The message packet that was sent can be received with the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMbx">sceKernelReceiveMbx</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelPollMbx">sceKernelPollMbx</a>() functions. When the message is sent with sceKernelSendMbx(), if a thread is already waiting for the relevant message box because it called <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMbx">sceKernelReceiveMbx</a>(), the WAIT state of the thread at the head of the wait queue will be canceled, the <i>sendmsg</i> specified by sceKernelSendMbx() will be sent to that thread and become the return parameter of recvmsg of the following <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMbx">sceKernelReceiveMbx</a>().<br>If there is already a thread waiting for a message in the target message box, the WAIT state of the thread at the head of the wait queue will be canceled, the <i>sendmsg</i> specified by sceKernelSendMbx() will be sent to that thread and become the return parameter of recvmsg of the following <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMbx">sceKernelReceiveMbx</a>(). <br>By comparison, if no thread is waiting for a message in the target message box, the message that was sent is entered in the message queue in the message box. In either case, the thread that issued sceKernelSendMbx() does not enter a WAIT state. <br>A message packet consists of a system-defined message header followed by a message body containing data stored by the application program. <br>An application program can set the msgPriority of the message header as needed. It is not necessary for the application program to manipulate other parts of the message header. <br>The multithread manager is not at all concerned with the message body. The application program is responsible for determining the size of the message body and how that size is exchanged between threads (such as tacitly stipulating the size or adding information to the body that indicates the size). <br>In addition, the management of memory where message packets are stored is also the responsibility of the application program. A sending thread in an application program uses a memory pool management function provided by the multithread manager to allocate memory from an array variable declared in the program, and to store and send data in message packets. <br>A receiving thread uses a memory pool management function to return memory to an array variable after processing the data in a received message packet. It is the responsibility of the application program to maintain coherency in memory management between the sending thread and the receiving thread. Since the contents of the message packet aren't copied, you must not send a message packet again with the same address using the sceKernelSendMbx() function until the first message packet is received.<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReceiveMbx"></a><a name="sceKernelReceiveMbxCB"></a><a name="sceKernelPollMbx"></a>
<a name="sceKernelReceiveMbx / sceKernelReceiveMbxCB / sceKernelPollMbx"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReceiveMbx / <br>sceKernelReceiveMbxCB / <br>sceKernelPollMbx<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Receive from message box<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReceiveMbx </b>( 
	SceUID <i>mbxid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMsgPacket">SceKernelMsgPacket</a> **<i>recvmsg</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelReceiveMbxCB </b>( 
	SceUID <i>mbxid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMsgPacket">SceKernelMsgPacket</a> **<i>recvmsg</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelPollMbx </b>( 
	SceUID <i>mbxid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMsgPacket">SceKernelMsgPacket</a> **<i>recvmsg</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelReceiveMbx&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread &nbsp;&nbsp;<br>&nbsp;&nbsp;(must be called in an interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelReceiveMbxCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread &nbsp;&nbsp;<br>&nbsp;&nbsp;(must be called in an interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelPollMbx&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Can be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread &nbsp;&nbsp;<br>&nbsp;&nbsp;(does not depend on interrupt-disabled or -enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;</td>
</tr>
</table>
</div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mbxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Receive message box.   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>recvmsg</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable for receiving starting address of receive message packet. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>timeout</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a variable of type SceUInt where the upper limit of the wait&nbsp;&nbsp;<br>&nbsp;&nbsp;time specified in microseconds is stored. When <i>NULL</i> is specified,&nbsp;&nbsp;<br>&nbsp;&nbsp;waiting will continue indefinitely. When the message is received,&nbsp;&nbsp;<br>&nbsp;&nbsp;the remaining time is returned by the function.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MBXID">SCE_KERNEL_ERROR_UNKNOWN_MBXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MBOX_NOMSG">SCE_KERNEL_ERROR_MBOX_NOMSG</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MBOX_LOOP">SCE_KERNEL_ERROR_MBOX_LOOP</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Receives a message from the target message box indicated by <i>mbxid</i>. If the message in the target message box has not been sent yet (if the message box is empty), the thread that issued this service call enters a WAIT state and is added to a message arrival wait queue in the message box. If there is already a message waiting in the target message box, the message at the head of the queue is extracted and that message is stored in the return parameter <i>recvmsg</i>, then the service call returns. <br>If <i>timeout</i> is specified, a timeout will be set with a value in microseconds. If <i>timeout</i> is NULL, no timeout operation will be performed.<br>Note that when <i>timeout</i> is specified, the value indicated by <i>timeout</i> is updated when the service call ends. If the desired condition was met within the timeout period, the value will be updated with the time remaining. If the desired condition was not met, <i>timeout</i> will be set to 0, and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a> error will be returned.<br>sceKernelReceiveMbxCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelReceiveMbx().<br>If a callback notification is received for the calling thread while the thread is waiting for a message to be received, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br>sceKernelPollMbx() is equivalent to the sceKernelReceiveMbx() service call except that the function for entering the wait queue has been removed. If the message in the target message box has not yet been sent, the error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MBOX_NOMSG">SCE_KERNEL_ERROR_MBOX_NOMSG</a>) is returned. This behavior is different from that of sceKernelReceiveMbx().  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelReceiveMbx"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelReceiveMbx<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel message box receive wait<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>int <b>sceKernelCancelReceiveMbx </b>( 
	SceUID <i>mbxid</i>, 
	int *<i>numWaitThreads</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mbxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;message boxID &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable for receiving the number of threads for which the &nbsp;&nbsp;<br>&nbsp;&nbsp;wait state was canceled. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MBXID">SCE_KERNEL_ERROR_UNKNOWN_MBXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the wait state of the thread that is waiting in the message box specified by <i>mbxid</i>. The thread for which the wait state was canceled can determine that it was canceled from the return value of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMbx">sceKernelReceiveMbx</a>(). <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferMbxStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferMbxStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get message box status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
<i>int</i> <b>sceKernelReferMbxStatus</b>( 
	SceUID <i>mbxid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMbxInfo">SceKernelMbxInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mbxid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;message boxID to be to obtained  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to the structure variable for receiving the status of the message box. You&nbsp;&nbsp;<br>&nbsp;&nbsp;must assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMbxInfo">SceKernelMbxInfo</a>) to info-&gt;size before calling this function.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MBXID">SCE_KERNEL_ERROR_UNKNOWN_MBXID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets status of message box.<br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMbxInfo">SceKernelMbxInfo</a><br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateMsgPipe"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateMsgPipe<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create message pipe<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateMsgPipe</b>( 
	const char *<i>name</i>, 
	SceUID <i>mpid</i>, 
	SceUInt <i>attr</i>, 
	SceSize <i>bufsize</i>, 
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMppOptParam">SceKernelMppOptParam</a> *<i>optParam</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;message&nbsp;pipe.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;operator&nbsp;for&nbsp;visual&nbsp;<br>&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;<br>&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>mpid</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;ID&nbsp;of&nbsp;the&nbsp;memory&nbsp;partition&nbsp;where&nbsp;the&nbsp;buffer&nbsp;for&nbsp;the&nbsp;message&nbsp;pipe&nbsp;is&nbsp;to&nbsp;be&nbsp;located.&nbsp;&nbsp;&nbsp;<br>&nbsp;Specify&nbsp;SCE_KERNEL_PRIMARY_USER_PARTITION&nbsp;</td>
</tr>
<tr>
<td rowspan= 7  valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Attributes&nbsp;of&nbsp;the&nbsp;message&nbsp;pipe.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPA_THFIFO_S&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;send&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;<i>FIFO</i>.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPA_THPRI_S&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;send&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPA_THFIFO_R&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;receive&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;<i>FIFO</i>.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPA_THPRI_R&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;receive&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPA_THFIFO&nbsp;</td>
<td valign="top">&nbsp;Both&nbsp;the&nbsp;send&nbsp;and&nbsp;receive&nbsp;wait&nbsp;threads&nbsp;&nbsp;<br>&nbsp;are&nbsp;queued&nbsp;using&nbsp;<i>FIFO</i>.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPA_THPRI&nbsp;</td>
<td valign="top">&nbsp;Both&nbsp;the&nbsp;send&nbsp;and&nbsp;receive&nbsp;wait&nbsp;threads&nbsp;&nbsp;<br>&nbsp;are&nbsp;queued&nbsp;using&nbsp;thread&nbsp;priority.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>bufsize</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Buffer&nbsp;size&nbsp;of&nbsp;the&nbsp;message&nbsp;pipe.&nbsp;0&nbsp;can&nbsp;also&nbsp;be&nbsp;specified.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Reserved&nbsp;for&nbsp;future&nbsp;expansion.&nbsp;Specify&nbsp;NULL.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;mppid(mppid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Message pipe ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a message pipe. The <i>ID</i> of the created message pipe is returned by the function. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMppOptParam">SceKernelMppOptParam</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteMsgPipe"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteMsgPipe<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete message pipe<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteMsgPipe </b>( 
	SceUID <i>mppid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mppid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of message pipe to be deleted. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MPPID">SCE_KERNEL_ERROR_UNKNOWN_MPPID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Delete the message pipe specified by mbxid. <br>When there is a thread waiting to send or receive a message in the target message pipe, this service call will end normally and an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>) will be returned to the waiting thread. <br>Also, if a message is left in the target message pipe, the message pipe will be deleted without reporting an error and the message will be discarded. <br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSendMsgPipe"></a><a name="sceKernelSendMsgPipeCB"></a><a name="sceKernelTrySendMsgPipe"></a>
<a name="sceKernelSendMsgPipe / sceKernelSendMsgPipeCB / sceKernelTrySendMsgPipe"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSendMsgPipe / <br>sceKernelSendMsgPipeCB / <br>sceKernelTrySendMsgPipe<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Send to message pipe<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSendMsgPipe </b>( 
	SceUID <i>mppid</i>, 
	void *<i>sendbuf</i>, 
	SceSize <i>sendsize</i>, 
	int <i>waitmode</i>, 
	SceSize *<i>result</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelSendMsgPipeCB </b>( 
	SceUID <i>mppid</i>, 
	void *<i>sendbuf</i>, 
	SceSize <i>sendsize</i>, 
	int <i>waitmode</i>, 
	SceSize *<i>result</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelTrySendMsgPipe </b>( 
	SceUID <i>mppid</i>, 
	void *<i>sendbuf</i>, 
	SceSize <i>sendsize</i>, 
	int <i>waitmode</i>, 
	SceSize *<i>result</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelSendMsgPipe&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelSendMsgPipeCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelTrySendMsgPipe&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Can be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (does not depend on &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-disabled or -enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>mppid</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Sending&nbsp;destination&nbsp;for&nbsp;the&nbsp;message&nbsp;pipe.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>sendbuf</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Starting&nbsp;address&nbsp;of&nbsp;the&nbsp;data&nbsp;to&nbsp;be&nbsp;sent.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>sendsize</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Number&nbsp;of&nbsp;bytes&nbsp;of&nbsp;data&nbsp;to&nbsp;be&nbsp;sent.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td rowspan= 3  valign="top">&nbsp;<i>waitmode</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Wait&nbsp;mode.&nbsp;Specify&nbsp;one&nbsp;of&nbsp;the&nbsp;following.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPW_FULL&nbsp;&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;until&nbsp;all&nbsp;send&nbsp;data&nbsp;is&nbsp;received&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPW_ASAP&nbsp;&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;until&nbsp;just&nbsp;one&nbsp;byte&nbsp;can&nbsp;be&nbsp;sent&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>result</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;variable&nbsp;of&nbsp;type&nbsp;SceSize&nbsp;for&nbsp;returning&nbsp;the&nbsp;actual&nbsp;number&nbsp;of&nbsp;bytes&nbsp;of&nbsp;data&nbsp;sent.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>timeout</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;a&nbsp;variable&nbsp;of&nbsp;type&nbsp;SceUInt&nbsp;where&nbsp;the&nbsp;upper&nbsp;limit&nbsp;of&nbsp;the&nbsp;wait&nbsp;time&nbsp;<br>&nbsp;specified&nbsp;in&nbsp;microseconds&nbsp;is&nbsp;stored.&nbsp;When&nbsp;<i>NULL</i>&nbsp;is&nbsp;specified,&nbsp;waiting&nbsp;will&nbsp;<br>&nbsp;continue&nbsp;indefinitely.&nbsp;If&nbsp;the&nbsp;message&nbsp;is&nbsp;received,&nbsp;the&nbsp;remaining&nbsp;<br>&nbsp;time&nbsp;is&nbsp;returned&nbsp;by&nbsp;the&nbsp;function.&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MPP_FULL">SCE_KERNEL_ERROR_MPP_FULL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_SIZE">SCE_KERNEL_ERROR_ILLEGAL_SIZE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MODE">SCE_KERNEL_ERROR_ILLEGAL_MODE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MPPID">SCE_KERNEL_ERROR_UNKNOWN_MPPID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sends message data with a starting address of <i>sendbuf</i> to the message pipe indicated by <i>mppid</i>. The send operation is different depending on whether the size of the buffer belonging to the message pipe is zero or nonzero as described below. <br><br></div>
<div style="margin-left:35px;"><ul>
<li> When the size of the message pipe buffer is 0 <br>Data is directly copied from the send thread to the receive thread. <br>When the <i>waitmode</i> is <i>SCE_KERNEL_MPW_FULL</i>, the receiving thread will enter WAIT state until all send messages have been received, and then the send messages will be added to the message pipe's message send wait queue. <br>When the <i>waitmode</i> is SCE_KERNEL_MPW_ASAP, if just a single byte of data is received by the receive thread, control will return immediately. The receiving thread will enter WAIT state only when there are no threads in a receive wait state. Then, the send message will be added to the message pipe's send wait queue. 
<li> When the size of the message pipe buffer is nonzero <br>Data is copied indirectly via the buffer. When <i>sendsize</i> is larger than the message pipe buffer, an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_SIZE">SCE_KERNEL_ERROR_ILLEGAL_SIZE</a>) will occur. <br>When <i>waitmode</i> is SCE_KERNEL_MPW_FULL, if there is <i>sendsize</i> amount of space available in the message pipe buffer, all the data will be copied to the buffer and control will return immediately. If there is not enough free space in the buffer, the thread will enter WAIT state until the buffer has enough free space and the message will be added to the message pipe's send message wait queue. <br>When <i>waitmode</i> is SCE_KERNEL_MPW_ASAP, even if the message pipe buffer has just one byte of free space, only the data that can fit in the buffer will be copied and control will return immediately. When the buffer is full, the thread will enter WAIT state until the data is received and the message will be added to the message pipe's message send wait queue. <br>
</ul></div>
<div style="margin-left:50px;">The length of the message that was actually sent is returned in the variable of type SceSize pointed to by <i>result</i>. When <i>waitmode</i> is SCE_KERNEL_MPW_FULL, the send operation will end normally and when sceKernelSendMsgPipe() returns <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a>, the message length will become equal to <i>sendsize</i>. However, when the send operation is interrupted by a forced cancel of a wait state or a timeout before the send message has been completely received by a receive thread, or if <i>waitmode</i> is set to SCE_KERNEL_MPW_ASAP, it may be that a value smaller than <i>sendsize</i> will be returned. <br>If <i>timeout</i> is specified, a timeout will be set with a value in microseconds. If <i>timeout</i> is NULL, no timeout operation will be performed.<br>Note that when <i>timeout</i> is specified, the value indicated by <i>timeout</i> is updated when the service call ends. If the desired condition was met within the timeout period, the value will be updated with the time remaining. If the desired condition was not met, <i>timeout</i> will be set to 0, and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a> error will be returned.<br>sceKernelSendMsgPipeCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelSendMsgPipe().<br>If a callback notification is received for the calling thread while the thread is waiting for a message to be sent, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br>sceKernelTrySendMsgPipe() is equivalent to the sceKernelSendMsgPipe() service call except that the function for entering WAIT state has been removed. If <i>waitmode</i> is SCE_KERNEL_MPW_FULL, when there is no message pipe buffer or receive wait thread that only receives all send messages, or if <i>waitmode</i> is SCE_KERNEL_MPW_ASAP when just one byte of a message cannot be received, an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MPP_FULL">SCE_KERNEL_ERROR_MPP_FULL</a>) will be returned. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReceiveMsgPipe"></a><a name="sceKernelReceiveMsgPipeCB"></a><a name="sceKernelTryReceiveMsgPipe"></a>
<a name="sceKernelReceiveMsgPipe / sceKernelReceiveMsgPipeCB / sceKernelTryReceiveMsgPipe"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReceiveMsgPipe / <br>sceKernelReceiveMsgPipeCB / <br>sceKernelTryReceiveMsgPipe<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Receive from message pipe<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReceiveMsgPipe </b>( 
	SceUID <i>mppid</i>, 
	void *recvbuf, 
	SceSize recvsize, 
	int <i>waitmode</i>, 
	SceSize *<i>result</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelReceiveMsgPipeCB </b>( 
	SceUID <i>mppid</i>, 
	void *recvbuf, 
	SceSize recvsize, 
	int <i>waitmode</i>, 
	SceSize *<i>result</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelTryReceiveMsgPipe </b>( 
	SceUID <i>mppid</i>, 
	void *recvbuf, 
	SceSize recvsize, 
	int <i>waitmode</i>, 
	SceSize *result
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelReceiveMsgPipe&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelReceiveMsgPipeCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelTryReceiveMsgPipe&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Can be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (does not depend on &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-disabled or -enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>mppid</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Receive&nbsp;message&nbsp;pipe.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>recvbuf</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Storage&nbsp;address&nbsp;of&nbsp;receive&nbsp;data.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>recvsize</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Specify&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;of&nbsp;data&nbsp;to&nbsp;be&nbsp;received.&nbsp;&nbsp;</td>
</tr>
<tr>
<td rowspan= 3  valign="top">&nbsp;<i>waitmode</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Wait&nbsp;mode.&nbsp;Specify&nbsp;one&nbsp;of&nbsp;the&nbsp;following.&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPW_FULL&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;until&nbsp;receive&nbsp;buffer&nbsp;becomes&nbsp;full&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_MPW_ASAP&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;until&nbsp;just&nbsp;one&nbsp;byte&nbsp;can&nbsp;be&nbsp;received&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>result</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;variable&nbsp;of&nbsp;type&nbsp;SceSize&nbsp;that&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;of&nbsp;data&nbsp;&nbsp;<br>&nbsp;actually&nbsp;received.&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>timeout</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;a&nbsp;variable&nbsp;of&nbsp;type&nbsp;SceUInt&nbsp;where&nbsp;the&nbsp;upper&nbsp;limit&nbsp;of&nbsp;the&nbsp;wait&nbsp;time&nbsp;<br>&nbsp;specified&nbsp;in&nbsp;microseconds&nbsp;is&nbsp;stored.&nbsp;When&nbsp;NULL&nbsp;is&nbsp;specified,&nbsp;waiting&nbsp;will&nbsp;<br>&nbsp;continue&nbsp;indefinitely.&nbsp;If&nbsp;the&nbsp;message&nbsp;is&nbsp;received,&nbsp;the&nbsp;remaining&nbsp;<br>&nbsp;time&nbsp;is&nbsp;returned&nbsp;by&nbsp;the&nbsp;function.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MPP_EMPTY">SCE_KERNEL_ERROR_MPP_EMPTY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_SIZE">SCE_KERNEL_ERROR_ILLEGAL_SIZE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MODE">SCE_KERNEL_ERROR_ILLEGAL_MODE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MPPID">SCE_KERNEL_ERROR_UNKNOWN_MPPID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Receives a message from the message pipe specified by <i>mppid</i>, and then stores the message in the receive buffer at the starting address of <i>recvbuf</i>. The receive operation is different depending on whether the size of the buffer belonging to the message pipe is zero or nonzero as described below. <br></div>
<div style="margin-left:35px;"><ul>
<li> When the size of the message pipe buffer is 0 <br>Data is directly copied from the send thread to the receive thread. <br>When the <i>waitmode</i> is SCE_KERNEL_MPW_FULL, the receiving thread will enter WAIT state until the amount of data specified by <i>recvsize</i> is received, and then the received message will be added to the message pipe's message receive queue. <br>When the waitmode is SCE_KERNEL_MPW_ASAP and a send wait thread exists, data will be received up to the maximum <i>recvsize</i>, then control will return immediately. The receive thread will enter WAIT state only when a send wait thread does not exist and in that case the message will be added to the message pipe's message receive wait queue. 
<li> When the size of the message pipe buffer is nonzero <br>Data is copied indirectly via the buffer. When <i>rcvsize</i> is larger than the message pipe buffer, an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_SIZE">SCE_KERNEL_ERROR_ILLEGAL_SIZE</a>) will occur. <br>When the <i>waitmode</i> is SCE_KERNEL_MPW_FULL, if there is <i>recvsize</i> bytes of data in the message pipe buffer, the data will be received from the buffer and control will return immediately. When the size of the data in the buffer is less than <i>recvsize</i> bytes, the receiving thread will enter WAIT state until the data in the buffer is greater than or equal to recvsize bytes, and the message will be added to the message pipe's message receive queue. <br>When the <i>waitmode</i> is SCE_KERNEL_MPW_ASAP, if there is just one byte of data in the message pipe buffer, the data will be received up to the maximum <i>recvsize</i> bytes, and then control will immediately return. When the buffer is empty, the receiving thread will enter WAIT state until the data is sent to the message pipe and the message will be added to the message pipe's message receive wait queue. <br>
</ul></div>
<div style="margin-left:50px;">The length of the message that is actually be received is returned in the variable of type SceSize pointed to by <i>result</i>. When <i>waitmode</i> is SCE_KERNEL_MPW_FULL, the receive operation will end normally and when sceKernelReceiveMsgPipe() returns <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a>, the message length will become equal to <i>recvsize</i>. However, when the receive operation is interrupted by a forced cancel of a wait state or a timeout before <i>recvsize</i> bytes have been completely received, or if <i>waitmode</i> is set to SCE_KERNEL_MPW_ASAP, it may be that a value smaller than <i>recvsize</i> will be returned. <br>sceKernelReceiveMsgPipeCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelReceiveMsgPipe().<br>If a callback notification is received for the calling thread while the thread is waiting for a message to be received, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again. <br>sceKernelReceiveMsgPipe() is equivalent to the sceKernelReceiveMsgPipe() service call except that the function for entering WAIT state has been removed. When <i>waitmode</i> is SCE_KERNEL_MPW_FULL, if the data in the message pipe buffer and of the send wait thread are all collected together but the total size is less than recvsize, or when waitmode is SCE_KERNEL_MPW_ASAP and the message pipe is empty and there is no send wait thread in that message pipe, an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_MPP_EMPTY">SCE_KERNEL_ERROR_MPP_EMPTY</a>) will be returned. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelMsgPipe"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelMsgPipe<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel message pipe receive wait<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>int <b>sceKernelCancelMsgPipe </b>( 
	SceUID <i>mppid</i>, 
	int *<i>numSendWaitThreads</i>, 
	int *<i>numReceiveWaitThreads</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mppid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Message pipe ID  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numSendWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable for receiving the number of threads for&nbsp;&nbsp;<br>&nbsp;&nbsp;which the send wait state was canceled &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numReceiveWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable for receiving the number of threads for&nbsp;&nbsp;<br>&nbsp;&nbsp;which the receive wait state was canceled &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MPPID">SCE_KERNEL_ERROR_UNKNOWN_MPPID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the wait state of the thread waiting on the message pipe specified by <i>mppid</i>. Also clears data remaining in the message pipe buffer. <br>The thread for which the wait state was canceled can determine that it was canceled from the return values of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSendMsgPipe">sceKernelSendMsgPipe</a>() and <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReceiveMsgPipe">sceKernelReceiveMsgPipe</a>().<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferMsgPipeStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferMsgPipeStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get message pipe status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
<i>int</i> <b>sceKernelReferMsgPipeStatus </b>( 
	SceUID <i>mppid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMppInfo">SceKernelMppInfo</a> *<i>info</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>mppid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of message pipe to be obtained   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the status of the message pipe. You&nbsp;&nbsp;<br>&nbsp;&nbsp;must assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMppInfo">SceKernelMppInfo</a>) to info-&gt;size when calling this function.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_MPPID">SCE_KERNEL_ERROR_UNKNOWN_MPPID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of a message pipe.<br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelMppInfo">SceKernelMppInfo</a><br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateVpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateVpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create variable length memory pool<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateVpl</b>( 
	const char *<i>name</i>, 
	SceUID <i>mpid</i>, 
	SceUInt <i>attr</i>, 
	SceSize <i>size</i>, 
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVplOptParam">SceKernelVplOptParam</a> *<i>optParam</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;variable&nbsp;length&nbsp;memory&nbsp;pool.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;<br>&nbsp;operator&nbsp;for&nbsp;visual&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;<br>&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>mpid</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;ID&nbsp;of&nbsp;the&nbsp;memory&nbsp;partition&nbsp;where&nbsp;the&nbsp;memory&nbsp;pool&nbsp;is&nbsp;to&nbsp;be&nbsp;located.&nbsp;&nbsp;&nbsp;<br>&nbsp;Specify&nbsp;SCE_KERNEL_PRIMARY_USER_PARTITION&nbsp;</td>
</tr>
<tr>
<td rowspan= 6  valign="top">&nbsp;<i>attr</i>&nbsp;<br>&nbsp;&nbsp;&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Attribute&nbsp;of&nbsp;variable&nbsp;length&nbsp;memory&nbsp;pool.&nbsp;One&nbsp;of&nbsp;the&nbsp;following&nbsp;must&nbsp;be&nbsp;specified.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_VA_THFIFO&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;FIFO.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_VA_THPRI&nbsp;</td>
<td valign="top">&nbsp;The&nbsp;wait&nbsp;thread&nbsp;is&nbsp;queued&nbsp;using&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td colspan= 2  valign="top">&nbsp;Also,&nbsp;as&nbsp;an&nbsp;option,&nbsp;the&nbsp;following&nbsp;specification&nbsp;can&nbsp;be&nbsp;added&nbsp;by&nbsp;logically&nbsp;ORing&nbsp;it&nbsp;with&nbsp;<i>attr</i>.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_VA_MEMBTM&nbsp;</td>
<td valign="top">&nbsp;Allocates&nbsp;a&nbsp;memory&nbsp;pool&nbsp;closest&nbsp;to&nbsp;memory&nbsp;<br>&nbsp;bottom&nbsp;(high&nbsp;addresses).&nbsp;If&nbsp;this&nbsp;<br>&nbsp;specification&nbsp;is&nbsp;not&nbsp;included,&nbsp;the&nbsp;memory&nbsp;<br>&nbsp;pool&nbsp;will&nbsp;be&nbsp;allocated&nbsp;closest&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;<br>&nbsp;memory&nbsp;(low&nbsp;addresses).&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_VA_THPASS&nbsp;</td>
<td valign="top">&nbsp;Even&nbsp;when&nbsp;a&nbsp;waiting&nbsp;thread&nbsp;is&nbsp;already&nbsp;&nbsp;<br>&nbsp;queued,&nbsp;if&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;required&nbsp;<br>&nbsp;by&nbsp;a&nbsp;subsequent&nbsp;thread&nbsp;is&nbsp;small,&nbsp;pass&nbsp;up&nbsp;<br>&nbsp;the&nbsp;waiting&nbsp;thread&nbsp;and&nbsp;allocate&nbsp;memory&nbsp;<br>&nbsp;for&nbsp;the&nbsp;latter&nbsp;thread&nbsp;first.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>size</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Total&nbsp;size&nbsp;(number&nbsp;of&nbsp;bytes)&nbsp;of&nbsp;variable&nbsp;length&nbsp;memory&nbsp;pool.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Reserved&nbsp;for&nbsp;future&nbsp;expansion.&nbsp;Specify&nbsp;NULL.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;vplid( vplid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of variable length memory pool&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE">SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a memory pool that can acquire variable length memory blocks. Any size memory blocks that do not exceed the size of the memory pool can be acquired from a variable length memory pool. However, a variable length memory pool does require more processing time compared to a fixed length memory pool, which is described later. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVplOptParam">SceKernelVplOptParam</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteVpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteVpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete variable length memory pool<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteVpl </b>( 
	SceUID <i>vplid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of variable length memory pool to be deleted.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VPLID">SCE_KERNEL_ERROR_UNKNOWN_VPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the variable length memory pool specified by <i>vplid</i>. No error will occur even if a memory block has not been returned from among the memory blocks acquired from this memory pool. Operation is not guaranteed if an attempt is made to use a memory block that was not returned after a memory pool was deleted. You must create application programs such that memory blocks which are not returned after deleting a memory pool are not used. If a memory pool is deleted when a thread is waiting in the memory acquisition wait queue, an error (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>) will be returned to the waiting thread. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelAllocateVpl"></a><a name="sceKernelAllocateVplCB"></a><a name="sceKernelTryAllocateVpl"></a>
<a name="sceKernelAllocateVpl / sceKernelAllocateVplCB / sceKernelTryAllocateVpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelAllocateVpl / <br>sceKernelAllocateVplCB / <br>sceKernelTryAllocateVpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Acquire variable length memory block<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelAllocateVpl </b>( 
	SceUID <i>vplid</i>, 
	SceSize <i>size</i>, 
	void **<i>blockp</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelAllocateVplCB </b>( 
	SceUID <i>vplid</i>, 
	SceSize <i>size</i>, 
	void **<i>blockp</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelTryAllocateVpl </b>( 
	SceUID <i>vplid</i>, 
	SceSize <i>size</i>, 
	void **<i>blockp</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelAllocateVpl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread &nbsp;&nbsp;<br>&nbsp;&nbsp;(must be called in an interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelAllocateVplCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread &nbsp;&nbsp;<br>&nbsp;&nbsp;(must be called in an interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelTryAllocateVpl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Can be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread &nbsp;&nbsp;<br>&nbsp;&nbsp;(does not depend on interrupt-disabled or -enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of variable length memory pool used for acquiring the memory block. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of bytes in memory block. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>blockp</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable for storing the address of the acquired memory block. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>timeout</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a variable of type SceUInt where the upper limit of the wait time&nbsp;&nbsp;<br>&nbsp;&nbsp;specified in microseconds is stored. When <i>NULL</i> is specified, waiting will&nbsp;&nbsp;<br>&nbsp;&nbsp;continue indefinitely. If the memory block could be acquired, the remaining&nbsp;&nbsp;<br>&nbsp;&nbsp;time is returned by the function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE">SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VPLID">SCE_KERNEL_ERROR_UNKNOWN_VPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Acquires a memory block of <i>size</i> bytes from the variable length memory pool specified by <i>vplid</i>. The contents of the acquired memory block are undefined. <br>If a memory block cannot be acquired from the specified memory pool when sceKernelAllocateVpl() is called, the calling thread will enter a WAIT state (memory acquisition wait state) and will wait until the memory can be acquired. <br>If <i>timeout</i> is specified, a timeout will be set with a value in microseconds. If <i>timeout</i> is NULL, no timeout operation will be performed.<br>Note that when <i>timeout</i> is specified, the value indicated by <i>timeout</i> is updated when the service call ends. If the desired condition was met within the timeout period, the value will be updated with the time remaining. If the desired condition was not met, <i>timeout</i> will be set to 0, and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a> error will be returned.<br>sceKernelAllocateVplCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelAllocateVpl().<br>If a callback notification is received for the calling thread while waiting for memory acquisition, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br>sceKernelTryAllocateVpl() is equivalent to the sceKernelAllocateVpl() service call except that the function for entering WAIT state has been removed. In addition, a difference with sceKernelAllocateVpl() is that if memory cannot be acquired, an error will be returned (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a>).  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelFreeVpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelFreeVpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Return variable length memory block<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelFreeVpl </b>( 
	SceUID <i>vplid</i>, 
	void *<i>block</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of variable length memory pool to which the memory block will be returned.  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>block</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Address of the memory block to be returned.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK">SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VPLID">SCE_KERNEL_ERROR_UNKNOWN_VPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns the memory block indicated by <i>block</i> to the memory pool <i>vplid</i>. If there is free space in the memory pool due to returning a memory block, and if another thread is waiting in a memory acquisition wait, it might be the case that the memory block will be acquired for the thread and its WAIT state will be canceled. If a memory block has not been acquired from the specified memory pool, an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK">SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK</a> error will occur. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelVpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelVpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel variable length memory pool allocation wait<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>int <b>sceKernelCancelVpl </b>( 
	SceUID <i>vplid</i>, 
	int *<i>numWaitThreads</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of variable length memory pool &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable for receiving the number of threads whose wait &nbsp;&nbsp;<br>&nbsp;&nbsp;states were canceled  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VPLID">SCE_KERNEL_ERROR_UNKNOWN_VPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the wait states of threads waiting on the variable length memory pool specified by <i>vplid</i>. The thread for which the wait state was canceled can determine that it was canceled from the return value of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelAllocateVpl">sceKernelAllocateVpl</a>(). <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferVplStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferVplStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get variable length memory pool status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
<i>int</i> <b>sceKernelReferVplStatus </b>( 
	SceUID <i>vplid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVplInfo">SceKernelVplInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of memory pool whose status is to be obtained &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the status of the memory pool. You&nbsp;&nbsp;<br>&nbsp;&nbsp;must assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVplInfo">SceKernelVplInfo</a>) to info-&gt;size before calling this function.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VPLID">SCE_KERNEL_ERROR_UNKNOWN_VPLID</a> <br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of a variable length memory pool.  <br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVplInfo">SceKernelVplInfo</a><br><br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateFpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateFpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create fixed length memory pool<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateFpl</b>( 
	const char *<i>name</i>, 
	SceUID <i>mpid</i>, 
	SceUInt <i>attr</i>, 
	SceSize <i>blockSize</i>, 
	int <i>numBlocks</i>, 
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelFplOptParam">SceKernelFplOptParam</a> *<i>optParam</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;fixed&nbsp;length&nbsp;memory&nbsp;pool.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;<br>&nbsp;operator&nbsp;for&nbsp;visual&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;<br>&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>mpid</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;ID&nbsp;of&nbsp;the&nbsp;memory&nbsp;partition&nbsp;where&nbsp;the&nbsp;memory&nbsp;pool&nbsp;is&nbsp;to&nbsp;be&nbsp;located.&nbsp;&nbsp;&nbsp;<br>&nbsp;Specify&nbsp;SCE_KERNEL_PRIMARY_USER_PARTITION&nbsp;</td>
</tr>
<tr>
<td rowspan= 5  valign="top">&nbsp;<i>attr</i>&nbsp;<br>&nbsp;&nbsp;&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Attribute&nbsp;of&nbsp;the&nbsp;fixed&nbsp;length&nbsp;memory&nbsp;pool.&nbsp;One&nbsp;of&nbsp;the&nbsp;following&nbsp;is&nbsp;required.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_FA_THFIFO&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;threads&nbsp;are&nbsp;queued&nbsp;using&nbsp;FIFO.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_FA_THPRI&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;threads&nbsp;are&nbsp;queued&nbsp;using&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td colspan= 2  valign="top">&nbsp;Also,&nbsp;as&nbsp;an&nbsp;option,&nbsp;the&nbsp;following&nbsp;specification&nbsp;can&nbsp;be&nbsp;added&nbsp;by&nbsp;logically&nbsp;ORing&nbsp;it&nbsp;with&nbsp;<i>attr</i>.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_FA_MEMBTM&nbsp;</td>
<td valign="top">&nbsp;Allocates&nbsp;a&nbsp;memory&nbsp;pool&nbsp;closest&nbsp;to&nbsp;<br>&nbsp;memory&nbsp;bottom&nbsp;(high&nbsp;addresses).&nbsp;If&nbsp;this&nbsp;<br>&nbsp;specification&nbsp;is&nbsp;not&nbsp;included,&nbsp;the&nbsp;memory&nbsp;<br>&nbsp;pool&nbsp;will&nbsp;be&nbsp;allocated&nbsp;closest&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;<br>&nbsp;memory&nbsp;(low&nbsp;addresses).&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>blockSize</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Size&nbsp;of&nbsp;a&nbsp;memory&nbsp;block&nbsp;that&nbsp;can&nbsp;be&nbsp;acquired&nbsp;from&nbsp;the&nbsp;fixed&nbsp;length&nbsp;memory&nbsp;pool.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>numBlocks</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Number&nbsp;of&nbsp;memory&nbsp;blocks&nbsp;that&nbsp;can&nbsp;be&nbsp;acquired&nbsp;from&nbsp;the&nbsp;fixed&nbsp;length&nbsp;&nbsp;<br>&nbsp;memory&nbsp;pool.&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;an&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelFplOptParam">SceKernelFplOptParam</a>&nbsp;structure&nbsp;which&nbsp;specifies&nbsp;additional&nbsp;&nbsp;<br>&nbsp;data&nbsp;for&nbsp;the&nbsp;fixed-length&nbsp;memory&nbsp;pool&nbsp;to&nbsp;be&nbsp;created.&nbsp;Be&nbsp;sure&nbsp;to&nbsp;assign&nbsp;&nbsp;<br>&nbsp;sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelFplOptParam">SceKernelFplOptParam</a>)&nbsp;to&nbsp;optParam-&gt;size.&nbsp;&nbsp;<br>&nbsp;If&nbsp;additional&nbsp;data&nbsp;is&nbsp;not&nbsp;necessary,&nbsp;specify&nbsp;NULL.&nbsp;</td>
</tr></table>
</div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;fplid( fplid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of fixed length memory pool&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE">SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT">SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function creates a memory pool from which fixed-length memory blocks can be acquired. Compared to a variable-length memory pool, the individual memory blocks that are acquired from a fixed-length memory pool are all of a fixed length, and the process of acquiring memory blocks from a fixed-length memory pool requires less time than that for a variable-length memory pool.<br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<div style="margin-left:50px;">Memory blocks which are acquired from the memory pool which is created are guaranteed to have 4-byte alignment, but any arbitrary alignment can be specified by placing additional data in an <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelFplOptParam">SceKernelFplOptParam</a> structure and providing the address of the structure in the <i>optParam</i> argument.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelFplOptParam">SceKernelFplOptParam</a><br>  <br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteFpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteFpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete fixed length memory pool<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteFpl </b>( 
	SceUID <i>fplid</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>fplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of fixed length memory pool to delete. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_FPLID">SCE_KERNEL_ERROR_UNKNOWN_FPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the fixed length memory pool specified by <i>fplid</i>. No error will occur even if a memory block has not been returned from among the memory blocks acquired from this memory pool. Operation is not guaranteed if an attempt is made to use a memory block that was not returned after a memory pool was deleted. You must create application programs such that memory blocks which are not returned after deleting a memory pool are not used. If a memory pool is deleted when a thread is waiting in the memory acquisition wait queue, an error will be returned to the waiting thread. <br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelAllocateFpl"></a><a name="sceKernelAllocateFplCB"></a><a name="sceKernelTryAllocateFpl"></a>
<a name="sceKernelAllocateFpl / sceKernelAllocateFplCB / sceKernelTryAllocateFpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelAllocateFpl / <br>sceKernelAllocateFplCB / <br>sceKernelTryAllocateFpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Acquire fixed length memory block<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelAllocateFpl </b>( 
	SceUID <i>fplid</i>, 
	void **<i>blockp</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelAllocateFplCB </b>( 
	SceUID <i>fplid</i>, 
	void **<i>blockp</i>, 
	SceUInt *<i>timeout</i> 
);
int <b>sceKernelTryAllocateFpl </b>( 
	SceUID <i>fplid</i>, 
	void **<i>blockp</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelAllocateFpl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelAllocateFplCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelTryAllocateFpl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Can be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (does not depend on &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-disabled or -enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;</td>
</tr>
</table>
</div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>fplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of fixed length memory pool ID to be used for acquiring the memory block.   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>blockp</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable for storing address of acquired memory block. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>timeout</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a variable of type SceUInt where the upper limit of the wait time&nbsp;&nbsp;<br>&nbsp;&nbsp;specified in microseconds is stored. When <i>NULL</i> is specified, waiting will&nbsp;&nbsp;<br>&nbsp;&nbsp;continue indefinitely. If the memory block could be acquired, the remaining&nbsp;&nbsp;<br>&nbsp;&nbsp;time is returned by the function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_FPLID">SCE_KERNEL_ERROR_UNKNOWN_FPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Acquires one memory block from the fixed length memory pool specified by <i>fplid</i>. The block size that was specified when the fixed length memory pool was created will be used as the memory block size. The contents of the acquired memory block are undefined. <br>If a memory block cannot be acquired from the specified memory pool when sceKernelAllocateFpl() is called, the calling thread will enter a WAIT state (memory acquisition wait state) and will wait until the memory can be acquired. <br>If <i>timeout</i> is specified, a timeout will be set with a value in microseconds. If <i>timeout</i> is NULL, no timeout operation will be performed.<br>Note that when <i>timeout</i> is specified, the value indicated by <i>timeout</i> is updated when the service call ends. If the desired condition was met within the timeout period, the value will be updated with the time remaining. If the desired condition was not met, <i>timeout</i> will be set to 0, and an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a> error will be returned.<br>sceKernelAllocateFplCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelAllocateFpl().<br>If a callback notification is received for the calling thread while waiting for memory acquisition, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again. <br>sceKernelTryAllocateFpl() is equivalent to the sceKernelAllocateFpl() service call except that the function for entering WAIT state has been removed. In addition, a difference with sceKernelAllocateFpl() is that if memory cannot be acquired, an error will be returned (<a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a>).  <br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelFreeFpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelFreeFpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Return fixed length memory block<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelFreeFpl </b>( 
	SceUID <i>fplid</i>, 
	void *<i>block</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>fplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of fixed length memory pool to which the memory block will be returned. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>block</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Address of memory block to return. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK">SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_FPLID">SCE_KERNEL_ERROR_UNKNOWN_FPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a> <br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns the memory block indicated by <i>block</i> to the memory pool <i>fplid</i>. If there is free space in the memory pool due to returning a memory block, and if another thread is waiting in a memory acquisition wait, it might be the case that the memory block will be acquired for the thread and its WAIT state will be canceled. If a memory block has not been acquired from the specified memory pool, an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK">SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK</a> error will occur. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelFpl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelFpl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel fixed length memory pool allocation wait<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>int <b>sceKernelCancelFpl </b>( 
	SceUID <i>fplid</i>, 
	int *<i>numWaitThreads</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>fplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of fixed length memory pool  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>numWaitThreads</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable for receiving the number of threads whose wait &nbsp;&nbsp;<br>&nbsp;&nbsp;states were canceled  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_FPLID">SCE_KERNEL_ERROR_UNKNOWN_FPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the wait states of threads waiting on the fixed length memory pool specified by <i>fplid</i>. The thread for which the wait state was canceled can determine that it was canceled from the return value of <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelAllocateFpl">sceKernelAllocateFpl</a>(). <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferFplStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferFplStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get fixed length memory pool status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
<i>int</i> <b>sceKernelReferFplStatus </b>( 
	SceUID <i>fplid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelFplInfo">SceKernelFplInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>fplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of memory pool whose status is to be obtained   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the status of the memory pool. You&nbsp;&nbsp;<br>&nbsp;&nbsp;must assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelFplInfo">SceKernelFplInfo</a>) to info-&gt;size before calling this function. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_FPLID">SCE_KERNEL_ERROR_UNKNOWN_FPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the fixed-length memory pool status. <br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelFplInfo">SceKernelFplInfo</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateTlspl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateTlspl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create TLS memory pool<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateTlspl</b>(
	const char *<i>name</i>,
	SceUID <i>mpid</i>,
	SceUInt <i>attr</i>,
	SceSize <i>blockSize</i>,
	int <i>numBlocks</i>,
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelTlsplOptParam">SceKernelTlsplOptParam</a> *<i>optParam</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="top">&nbsp;<i>name</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Name&nbsp;of&nbsp;the&nbsp;TLS&nbsp;memory&nbsp;pool.&nbsp;Since&nbsp;the&nbsp;name&nbsp;is&nbsp;used&nbsp;by&nbsp;an&nbsp;<br>&nbsp;operator&nbsp;for&nbsp;visual&nbsp;identification&nbsp;during&nbsp;debugging,&nbsp;no&nbsp;specific&nbsp;check&nbsp;is&nbsp;done&nbsp;<br>&nbsp;to&nbsp;determine&nbsp;if&nbsp;the&nbsp;name&nbsp;is&nbsp;unique.&nbsp;The&nbsp;name&nbsp;can&nbsp;have&nbsp;a&nbsp;maximum&nbsp;length&nbsp;&nbsp;<br>&nbsp;of&nbsp;31&nbsp;bytes.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>mpid</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;ID&nbsp;of&nbsp;the&nbsp;memory&nbsp;partition&nbsp;where&nbsp;the&nbsp;TLS&nbsp;memory&nbsp;pool&nbsp;is&nbsp;to&nbsp;be&nbsp;located.&nbsp;&nbsp;&nbsp;<br>&nbsp;Specify&nbsp;SCE_KERNEL_PRIMARY_USER_PARTITION.&nbsp;</td>
</tr>
<tr>
<td rowspan= 5  valign="top">&nbsp;<i>attr</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Attribute&nbsp;of&nbsp;the&nbsp;TLS&nbsp;memory&nbsp;pool.&nbsp;One&nbsp;of&nbsp;the&nbsp;following&nbsp;is&nbsp;required.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TA_THFIFO&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;threads&nbsp;are&nbsp;queued&nbsp;using&nbsp;FIFO.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TA_THPRI&nbsp;</td>
<td valign="top">&nbsp;Wait&nbsp;threads&nbsp;are&nbsp;queued&nbsp;using&nbsp;thread&nbsp;priority.&nbsp;</td>
</tr>
<tr>
<td colspan= 2  valign="top">&nbsp;Also,&nbsp;as&nbsp;an&nbsp;option,&nbsp;the&nbsp;following&nbsp;specification&nbsp;can&nbsp;be&nbsp;added&nbsp;by&nbsp;logically&nbsp;ORing&nbsp;it&nbsp;with&nbsp;<i>attr</i>.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TA_MEMBTM&nbsp;</td>
<td valign="top">&nbsp;Allocates&nbsp;a&nbsp;TLS&nbsp;memory&nbsp;pool&nbsp;closest&nbsp;to&nbsp;<br>&nbsp;memory&nbsp;bottom&nbsp;(high&nbsp;addresses).&nbsp;If&nbsp;this&nbsp;<br>&nbsp;specification&nbsp;is&nbsp;not&nbsp;included,&nbsp;the&nbsp;TLS&nbsp;&nbsp;<br>&nbsp;memory&nbsp;pool&nbsp;will&nbsp;be&nbsp;allocated&nbsp;closest&nbsp;to&nbsp;&nbsp;<br>&nbsp;the&nbsp;start&nbsp;of&nbsp;memory&nbsp;(low&nbsp;addresses).&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>blockSize</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Size&nbsp;of&nbsp;a&nbsp;TLS&nbsp;memory&nbsp;block&nbsp;that&nbsp;can&nbsp;be&nbsp;acquired&nbsp;from&nbsp;the&nbsp;TLS&nbsp;memory&nbsp;pool.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>numBlocks</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Number&nbsp;of&nbsp;TLS&nbsp;memory&nbsp;blocks&nbsp;that&nbsp;can&nbsp;be&nbsp;acquired&nbsp;from&nbsp;the&nbsp;TLS&nbsp;memory&nbsp;pool.&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>optParam</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;an&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelTlsplOptParam">SceKernelTlsplOptParam</a>&nbsp;structure&nbsp;which&nbsp;specifies&nbsp;additional&nbsp;&nbsp;<br>&nbsp;data&nbsp;for&nbsp;the&nbsp;TLS&nbsp;memory&nbsp;pool&nbsp;to&nbsp;be&nbsp;created.&nbsp;Be&nbsp;sure&nbsp;to&nbsp;assign&nbsp;&nbsp;<br>&nbsp;sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelTlsplOptParam">SceKernelTlsplOptParam</a>)&nbsp;to&nbsp;optParam-&gt;size.&nbsp;&nbsp;<br>&nbsp;If&nbsp;additional&nbsp;data&nbsp;is&nbsp;not&nbsp;necessary,&nbsp;specify&nbsp;NULL.&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;tlsplid(tlsplid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of TLS memory pool&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE">SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT">SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UTLS_FULL">SCE_KERNEL_ERROR_UTLS_FULL</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function creates a TLS memory pool from which fixed-length TLS memory blocks can be acquired. Threads call <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetTlsAddr">sceKernelGetTlsAddr</a>() to request and acquire local TLS memory blocks which are allocated from the TLS memory pool. <br><br>TLS memory blocks which are acquired from the created TLS memory pool are guaranteed to have 4-byte alignment, but any arbitrary alignment can be specified by placing additional data in an <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelTlsplOptParam">SceKernelTlsplOptParam</a> structure and providing the address of the structure in the <i>optParam</i> argument.<br><br>A maximum of 16 TLS memory pools can be created system-wide. If an attempt is made to create more than 16, the function will return an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UTLS_FULL">SCE_KERNEL_ERROR_UTLS_FULL</a> error. This does not mean that 16 threads can use one TLS memory pool. The number of threads that can use a given TLS memory pool is equal to the number specified by the <i>numBlocks</i> argument.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelTlsplOptParam">SceKernelTlsplOptParam</a>, <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetTlsAddr">sceKernelGetTlsAddr</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteTlspl"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteTlspl<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete TLS memory pool<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteTlspl </b>(
	SceUID <i>tlsplid</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>tlsplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of TLS memory pool to delete.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_TLSPLID">SCE_KERNEL_ERROR_UNKNOWN_TLSPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UTLS_BUSY">SCE_KERNEL_ERROR_UTLS_BUSY</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the TLS memory pool specified by <i>tlsplid</i>. If a thread that allocated a TLS memory block from this TLS memory pool is running, an <a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UTLS_BUSY">SCE_KERNEL_ERROR_UTLS_BUSY</a> error will occur. However, sceKernelDeleteTlspl() can be used to delete the TLS memory pool as long as the thread that called this function is the only thread that was using the TLS memory pool.<br><br>If a TLS memory pool is deleted when a thread is waiting in the memory acquisition wait queue, an error will be returned to the waiting thread and the return value of the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetTlsAddr">sceKernelGetTlsAddr</a>() function will be NULL.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetTlsAddr"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetTlsAddr<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get TLS memory block<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
void *<b>sceKernelGetTlsAddr </b>(
	SceUID <i>tlsplid</i>
);
</font></pre></div>
<div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (must be called in interrupt-enabled state)<br>Multithread safe<br>Dispatching must be enabled<br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>tlsplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specify the TLS memory pool ID from which to acquire a TLS &nbsp;&nbsp;<br>&nbsp;&nbsp;memory block.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns the starting address of the TLS memory block.<br>Returns NULL if TLS memory block acquisition failed for any reason.<br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets a TLS memory block from the TLS memory pool indicated by <i>tlsplid</i>. If the calling thread has already acquired the TLS memory block, then the address of the TLS memory block is returned.<br>The size of the TLS memory block to acquire is given by the block size specified when the TLS memory pool is created. A TLS memory block is initialized with zeroes when a thread first acquires a TLS memory block. When a thread calls sceKernelGetTlsAddr(), and a TLS memory block cannot be acquired from the specified TLS memory pool, the thread will enter a WAIT state (memory acquisition wait state) and will wait until memory can be acquired.<br><br>An error will occur and the function will return NULL in the following cases:<br><br></div>
</ul>
<div style="margin-left:60px;"><ul>
<li> The specified <i>tlsplid</i> is invalid;
<li> The calling context is invalid;
<li> The function was called in an interrupt-disabled or dispatch-disabled state;
<li> The WAIT state was canceled by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseWaitThread">sceKernelReleaseWaitThread</a>() function;
<li> Or the TLS memory pool was deleted while the thread was in a WAIT state
</ul></div>
<div style="margin-left:50px;"><br>If a thread enters the DORMANT state, a TLS memory block that it had acquired is automatically returned to the TLS memory pool.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferTlsplStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferTlsplStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get TLS memory pool status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferTlsplStatus </b>(
	SceUID <i>tlsplid</i>,
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelTlsplInfo">SceKernelTlsplInfo</a> *<i>info</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>tlsplid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of TLS memory pool whose status is to be obtained&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to a structure variable for receiving the status of the TLS memory pool. You&nbsp;&nbsp;<br>&nbsp;&nbsp;must assign sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelTlsplInfo">SceKernelTlsplInfo</a>) to <i>info-&gt;size</i> before calling this function.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_TLSPLID">SCE_KERNEL_ERROR_UNKNOWN_TLSPLID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of a TLS memory pool. This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelTlsplInfo">SceKernelTlsplInfo</a><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetSystemTime"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetSystemTime<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get system time <br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetSystemTime</b>(
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>clock</i>
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>hi</i>  &nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Stores the high-order 32 bits of the system time.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>low</i>   &nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Stores the low-order 32 bits of the system time.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets elapsed time from system operation start (the system time). <br>System time is in units of microseconds. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetSystemTimeWide"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetSystemTimeWide<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get system time in 64-bit width<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
unsigned long long <b>sceKernelGetSystemTimeWide</b>(
	void
);
</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">System time<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets elapsed time from system operation start (the system time). <br>This function differs from <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetSystemTime">sceKernelGetSystemTime</a>() in that the result is returned directly as an unsigned long long value.  <br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetSystemTimeLow"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetSystemTimeLow<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get low order 32 bits of system time<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUInt <b>sceKernelGetSystemTimeLow</b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Low-order 32 bits of system time <br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the low-order 32 bits of the elapsed time from system operation start (the system time). <br>sceKernelGetSystemTimeLow requires less execution time than <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetSystemTime">sceKernelGetSystemTime</a>() or <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetSystemTimeWide">sceKernelGetSystemTimeWide</a>(). <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDelayThread"></a><a name="sceKernelDelayThreadCB"></a>
<a name="sceKernelDelayThread / sceKernelDelayThreadCB"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDelayThread / sceKernelDelayThreadCB<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delay thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDelayThread </b>(
	SceUInt <i>usec</i> 
);
int <b>sceKernelDelayThreadCB </b>(
	SceUInt <i>usec</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelDelayThread&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelDelayThreadCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>usec</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Stop time in microseconds.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Temporarily stops execution of the calling thread and enters an elapsed time wait state. <br>Because the elapsed time wait state is one of the WAIT states, you can cancel it using <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseWaitThread">sceKernelReleaseWaitThread</a>(). <br>Specify the stop time in units of microseconds. When the specified value is 100 microseconds or less, the value is rounded up to approximately 100 microseconds. <br>When the time gets close to the finish time for multiple threads that have called sceKernelDelayThread() (200 microseconds or less), the threads will be collectively returned from their wait states at the latest time. <br>sceKernelDelayThreadCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelDelayThread(). <br>If a callback notification is received for the calling thread while waiting for elapsed time, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDelaySysClockThread"></a><a name="sceKernelDelaySysClockThreadCB"></a>
<a name="sceKernelDelaySysClockThread / sceKernelDelaySysClockThreadCB"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDelaySysClockThread / sceKernelDelaySysClockThreadCB<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delay thread<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDelaySysClockThread </b>(
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>clock</i> 
);
int <b>sceKernelDelaySysClockThreadCB </b>(
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>clock</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelDelaySysClockThread&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;sceKernelDelaySysClockThreadCB&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cannot be called from an interrupt handler&nbsp;&nbsp;<br>&nbsp;&nbsp;Can be called from a thread (must be called in an &nbsp;&nbsp;<br>&nbsp;&nbsp;interrupt-enabled state)&nbsp;&nbsp;<br>&nbsp;&nbsp;Multithread safe&nbsp;&nbsp;<br>&nbsp;&nbsp;Dispatching must be enabled&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;High-order 32-bits of stop time of system clock conversion &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Low-order 32-bits of stop time of system clock conversion  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Temporarily stops execution of the calling thread and enters an elapsed time wait state. <br>Because the elapsed time wait state is one of the WAIT states, you can cancel it using <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelReleaseWaitThread">sceKernelReleaseWaitThread</a>(). <br>Specify the stop time in units of microseconds. When the specified value is 100 microseconds or less, the value is rounded up to approximately 100 microseconds. <br>When the time gets close to the finish time for multiple threads that have called <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>() (200 microseconds or less), the threads will be collectively returned from their wait states at the latest time. <br>sceKernelDelaySysClockThread() is almost identical to <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>(). The only difference is the manner in which the time is specified. <br>sceKernelDelaySysClockThreadCB() is a service call that adds a function for checking whether or not a callback notification exists while the thread is in a wait state, to sceKernelDelaySysClockThread().<br>If a callback notification is received for the calling thread while waiting for elapsed time, the thread temporarily exits from the wait state, the callback function is executed, and then the thread enters the wait state again.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSetAlarm"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSetAlarm<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Alarm handler settings<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelSetAlarm </b>(
	SceUInt <i>usec</i>,
	SceUInt(*<i>handler</i>)(void*),
	void *<i>common</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>usec</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Time until the handler starts in microseconds.   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>handler</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Entry point for alarm handler  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to memory shared between alarm handler and general routine.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;almid(almid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Alarm ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sets up the alarm handler that is called after the specified time elapses. An alarm handler is similar to an interrupt handler, has one argument and is called as a thread-independent part. <br>Specify the elapsed time in units of system clocks. When the specified value is 100 microseconds or less, the value is rounded up to approximately 100 microseconds. <br>When the time gets close to the finish time for multiple threads that have called <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>() or the expiration time of an alarm (200 microseconds or less), the threads may be processed together at the latest time. <br>Canceling or continuing the alarm operation is determined by the return value of the handler itself when the alarm handler is called after the specified time elapses. You can also use <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelAlarm">sceKernelCancelAlarm</a>(), described later, to cancel the alarm without waiting for the specified time to elapse. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelAlarm">sceKernelCancelAlarm</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#alarmhandler">alarmhandler</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSetSysClockAlarm"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSetSysClockAlarm<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Alarm handler settings<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelSetSysClockAlarm </b>(
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>clock</i>,
	SceUInt (*<i>handler</i>)(void*),
	void *<i>common</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;High-order 32-bits of time until handler starts &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Low-order 32-bits of time until handler starts &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>handler</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Entry point of alarm handler   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to memory shared between alarm handler and general routine.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;almid(almid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Alarm ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sets up the alarm handler that is called after the specified time elapses. An alarm handler is similar to an interrupt handler, has one argument and is called as a thread-independent part. <br>Specify the elapsed time in units of system clocks. When the specified value is 100 microseconds or less, the value is rounded up to approximately 100 microseconds. <br>When the time gets close to the finish time for multiple threads that have called <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>() or the expiration time of an alarm (200 microseconds or less), the threads may be processed together at the latest time. <br>Canceling or continuing the alarm operation is determined by the return value of the handler itself when the alarm handler is called after the specified time elapses. You can also use <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelAlarm">sceKernelCancelAlarm</a>(), described later, to cancel the alarm without waiting for the specified time to elapse. <br>sceKernelSetSysClockAlarm() is almost identical to <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetAlarm">sceKernelSetAlarm</a>(). The only difference is the manner in which the time is specified. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a>, <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCancelAlarm">sceKernelCancelAlarm</a>(), <a href="../kernel/Thread_Manager-Reference-English.htm#alarmhandler">alarmhandler</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="alarmhandler"></a>
<table width="100%"><td width="70%"><font size=6>alarmhandler<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Alarm handler prototype<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUInt <b>alarmhandler</b>(
	void *<i>common</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Called in the context of the interrupt handler.<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;<i>Common</i> specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetAlarm">sceKernelSetAlarm</a>() is passed. &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Delete this alarm handler.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;clock(clock&gt;=1)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Call again after clock that indicates this alarm handler by the return value.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">After being called, the alarm handler's return value (in microseconds) determines whether it will be called again. <br>When the value returned by the alarm handler is 0, that alarm handler will be deleted. <br>When the value returned by the alarm handler is 1 or more, it will be added to the current scheduled call time of the handler and the next scheduled call time will be determined. When the value is 100 microseconds or less, the value is rounded up to approximately 100 microseconds. <br>Handler calls, as described in the paragraph for <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetAlarm">sceKernelSetAlarm</a>(), are not always correctly executed at the precise time that was specified, and there is a possibility that they may get delayed. However, the next handler call time is not actually the time called by the handler and is calculated based on the scheduled call time. Because of this, delays in the calls do not accumulate. <br>Note:<br>Alarm handlers are one type of interrupt handler. Therefore, there are restrictions on how they may use system service calls. Please refer to "Service calls issued from a thread-independent part" of the paragraph "System state under control of the multithread manager".<br>In addition, when creating a module that includes an alarm handler, it may not be possible for an alarm handler to directly access global data (such as global variables and string literals) using compiling options (other than -G 0). When global data must be accessed, we recommend explicitly passing the address of the global data in the common argument.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelAlarm"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelAlarm<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel alarm handler<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCancelAlarm </b>(
	SceUID <i>almid</i>
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>almid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of alarm to delete&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_ALMID">SCE_KERNEL_ERROR_UNKNOWN_ALMID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels alarm handler set by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetAlarm">sceKernelSetAlarm</a>() without waiting for elapsed time. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferAlarmStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferAlarmStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get alarm status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferAlarmStatus </b>( 
	SceUID <i>almid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelAlarmInfo">SceKernelAlarmInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>almid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Alarm ID for which status is to be obtained&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specifies a pointer to a structure variable for receiving the alarm status. Call this&nbsp;&nbsp;<br>&nbsp;&nbsp;function after assigning sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelAlarmInfo">SceKernelAlarmInfo</a>) to info-&gt;size.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_ALMID">SCE_KERNEL_ERROR_UNKNOWN_ALMID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the alarm status.<br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelAlarmInfo">SceKernelAlarmInfo</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelUSec2SysClock"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelUSec2SysClock<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Convert microseconds to system clock value<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelUSec2SysClock</b>(
	unsigned int <i>usec</i>,
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>clock</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>usec</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Value in microseconds you wish to convert  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Stores high-order 32 bits of converted result  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Stores low-order 32 bits of converted result  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Utility function that converts microseconds to system clock value. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelUSec2SysClockWide"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelUSec2SysClockWide<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Convert microseconds to 64-bit system clock value<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
unsigned long long <b>sceKernelUSec2SysClockWide</b>(
	unsigned int <i>usec</i>
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>usec</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Value in microseconds you wish to convert&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;clock&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Converted results&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Utility function that converts microseconds to system clock value.<br>This function differs from <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelUSec2SysClock">sceKernelUSec2SysClock</a>() in that the result is returned directly as an unsigned long long value.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSysClock2USec"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSysClock2USec<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Convert system clock value to actual time<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSysClock2USec</b>(
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>clock</i>,
	int *<i>sec</i>,
	int *<i>usec</i>
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;High-order 32-bits of system clock value you wish to convert &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Low-order 32-bits of system clock value you wish to convert  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>sec</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable that stores converted results in units of seconds &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>usec</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable that stores converted results in units of microseconds   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Utility function that converts system clock value to microseconds. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSysClock2USecWide"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSysClock2USecWide<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Convert 64-bit system clock value to actual time<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSysClock2USecWide</b>(
	unsigned long long <i>clock</i>,
	int *<i>sec</i>,
	int *<i>usec</i>
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;System clock value you wish to convert&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>sec</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable that stores converted results in units of seconds&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>usec</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to variable that stores converted results in units of microseconds&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Utility function that converts system clock value to microseconds.<br>This function is almost the same as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSysClock2USec">sceKernelSysClock2USec</a>() except that a different method is used for specifying the clock. <br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCreateVTimer"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCreateVTimer<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Create virtual timer<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUID <b>sceKernelCreateVTimer</b>(
	const char *<i>name</i>,
	const <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVTimerOptParam">SceKernelVTimerOptParam</a> *<i>optParam</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>name</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Name of the virtual timer. Since the name is used by an operator for visual&nbsp;&nbsp;<br>&nbsp;&nbsp;identification during debugging, no specific check is done to determine if the&nbsp;&nbsp;<br>&nbsp;&nbsp;name is unique. The name can have a maximum length of 31 bytes.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>optParam</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Reserved for future expansion. Specify NULL.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;vtid(vtid&gt;0)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Virtual timer ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Creates a virtual timer and returns the ID of the virtual timer that was created. <br>Immediately after the virtual timer is created, it is placed in a stopped state. To start the virtual timer counting, use the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartVTimer">sceKernelStartVTimer</a>() function.  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVTimerOptParam">SceKernelVTimerOptParam</a><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDeleteVTimer"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDeleteVTimer<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Delete virtual timer<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDeleteVTimer </b>(
	SceUID <i>vtid</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer to be deleted.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Deletes the virtual timer specified by <i>vtid</i>. The handler that was set for the virtual timer is also canceled. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetVTimerBase"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetVTimerBase<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get base time of virtual timer<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetVTimerBase</b>( 
	SceUID <i>vtid</i>,
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>base</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer for which the base time is to be obtained  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>base</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Location where the high-order 32 bits of the base time are stored  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>base</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Location where the low-order 32 bits of the base time are stored  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the base time of the virtual timer specified by <i>vtid</i>. In other words, gets the value of the system time that corresponds to time zero for that virtual timer. <br>Since a virtual timer's count value is initialized to zero immediately after the timer is allocated, its base time is normally the same as the time that the timer was started by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStartVTimer">sceKernelStartVTimer</a>() function. If the timer was temporarily stopped by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelStopVTimer">sceKernelStopVTimer</a>() function and its time value was changed by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerTime">sceKernelSetVTimerTime</a>() function, the base time will no longer be the same as the time that the timer was started.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetVTimerBaseWide"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetVTimerBaseWide<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get base time of virtual timer in unsigned long long type<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
unsigned long long <b>sceKernelGetVTimerBaseWide</b>( 
	SceUID <i>vtid</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer for which the base time is to be obtained &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;base(base!=-1)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Base time of virtual timer&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;-1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Invalid virtual timer ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the base time of the virtual timer specified by <i>vtid</i>. In other words, gets the value of the system time that corresponds to time zero for that virtual timer. <br>This function differs from <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetVTimerBase">sceKernelGetVTimerBase</a>() in that the result is returned directly as an unsigned long long value.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetVTimerTime"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetVTimerTime<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get current time of virtual timer<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetVTimerTime </b>( 
	SceUID <i>vtid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>clock</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer for which the current time is to be obtained &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Location where the high-order 32 bits of the current time are stored &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Location where the low-order 32 bits of the current time are stored&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the current time of the virtual timer specified by <i>vtid</i>. <br>The time is given in units of microseconds.  <br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetVTimerTimeWide"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetVTimerTimeWide<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get current time of virtual timer in unsigned long long type<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
unsigned long long <b>sceKernelGetVTimerTimeWide</b>( 
	SceUID <i>vtid</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer for which the current time is to be obtained  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;clock(clock!=-1)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Current time of virtual timer&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;-1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Invalid virtual timer ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the current time of the virtual timer specified by <i>vtid</i>. <br>This function differs from <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetVTimerTime">sceKernelGetVTimerTime</a>() in that the result is returned directly as an unsigned long long value.  <br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSetVTimerTime"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSetVTimerTime<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Set current time of virtual timer<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSetVTimerTime </b>( 
	SceUID <i>vtid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>clock</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer for which the current time is to be set  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;High-order 32 bits of the time to be set. The previous setting of the&nbsp;&nbsp;<br>&nbsp;&nbsp;high-order 32 bits of the time are stored as a return value. &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Low-order 32 bits of the time to be set. The previous setting of the low-order&nbsp;&nbsp;<br>&nbsp;&nbsp;32 bits of the time are stored as a return value.  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sets the current time of the virtual timer specified by <i>vtid</i>. <br>If a handler has been set for the virtual timer, and if the current time is set to a time that is past the scheduled calling time of the handler, the handler is called immediately after the setting is performed. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSetVTimerTimeWide"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSetVTimerTimeWide<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Set current time of virtual timer in unsigned long long type<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
unsigned long long <b>sceKernelSetVTimerTimeWide</b>( 
	SceUID <i>vtid</i>, 
	unsigned long long <i>clock</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cannot be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer for which the current time is to be set &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>clock</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Time to be set for the virtual timer  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;clock(clock!=-1)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Previous value of virtual timer's current time&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;-1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Invalid virtual timer ID&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sets the current time of the virtual timer specified by <i>vtid</i>. <br>This function is almost the same as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerTime">sceKernelSetVTimerTime</a>() except that a different method is used for specifying the time.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelStartVTimer"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelStartVTimer<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Start virtual timer<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelStartVTimer </b>( 
	SceUID <i>vtid</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer to be started &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The virtual timer was started&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The virtual time was already running&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_VTID">SCE_KERNEL_ERROR_ILLEGAL_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Starts the count of the virtual timer specified by <i>vtid</i>. <br>Although this service call can be called from an interrupt handler, a virtual timer cannot start itself from its virtual timer handler function by specifying its own virtual timer ID.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelStopVTimer"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelStopVTimer<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Stop virtual timer<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelStopVTimer </b>( 
	SceUID <i>vtid</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of the virtual timer to be stopped&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The virtual timer was already stopped&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The virtual timer was stopped&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_VTID">SCE_KERNEL_ERROR_ILLEGAL_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Stops the count of the virtual timer specified by <i>vtid</i>. <br>Although this service call can be called from an interrupt handler, a virtual timer cannot stop itself from its virtual timer handler function by specifying its own virtual timer ID.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSetVTimerHandler"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSetVTimerHandler<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Set virtual timer handler<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSetVTimerHandler </b>( 
	SceUID <i>vtid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>schedule</i>, 
	SceUInt (*<i>handler</i>)(SceUID, <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *, <a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *, void *), 
	void *<i>common</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Virtual timer ID &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>schedule</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;High-order 32 bits of handler call time   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>schedule</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Low-order 32 bits of handler call time &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>handler</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Entry point of virtual timer handler   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Arguments that are passed to the virtual timer handler   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_VTID">SCE_KERNEL_ERROR_ILLEGAL_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sets the handler that is called when the time of the virtual timer specified by <i>vtid</i> reaches the <i>schedule</i> value. <br>When the time gets close to the finish time for multiple threads that have called <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>() or if the alarms are about to expire (within 200 microseconds), processing may be performed collectively at the latest time. <br>Although this service call can be called from an interrupt handler, a virtual timer cannot set its own handler from its virtual timer handler function by specifying its virtual timer ID. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#vtimerhandler">vtimerhandler</a>()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vtimerhandler"></a>
<table width="100%"><td width="70%"><font size=6>vtimerhandler<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Virtual timer handler prototype<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUInt <b>vtimerhandler</b>( 
	SceUID <i>vtid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>schedule</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSysClock">SceKernelSysClock</a> *<i>actual</i>, 
	void *<i>common</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Called in the context of the interrupt handler.<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Virtual timer ID  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>schedule</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;High-order 32 bits of handler's scheduled calling time  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>schedule</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Low-order 32 bits of handler's scheduled calling time  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>actual</i>-&gt;<i>hi</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;High-order 32 bits of handler's actual start time &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>actual</i>-&gt;<i>low</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Low-order 32 bits of handler's actual start time &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;<i>common</i> argument specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerHandler">sceKernelSetVTimerHandler</a>()   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The handler is canceled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;clock( clock&gt;=1)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The handler is called again after the specified time (in microseconds) &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">A virtual timer handler is called at the time set in advance by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerHandler">sceKernelSetVTimerHandler</a>() function. The time that the handler is called is not exact and it may be called later than the scheduled time. The amount of time the handler call was delayed can be calculated by subtracting <i>schedule</i> from <i>actual</i>. <br>Whether a virtual timer handler function is called again is determined by its return value. If the handler function returns 0, the handler's registration is canceled (the virtual timer itself is not deleted). If the handler function returns a value greater than or equal to 1, it will be called again with the scheduled time for the next call determined by taking the return value and adding it to the scheduled time for this call (in microseconds). However, if a value less than 100 microseconds is specified, it is rounded up to 100 microseconds. <br>Although the virtual timer handler may be called later than the scheduled time that was set, since the time when the handler is called next is calculated based on its scheduled calling time and not the time that the handler was actually called, calling delays will not accumulate. <br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_3">
<div style="margin-left:40px;"><h4><b>Note</b><br><br></h4></div></a>

<div style="margin-left:50px;">Virtual timer handlers are one type of interrupt handler. Therefore, there are restrictions on how they may use system service calls. Please refer to "Service calls issued from a thread-independent part" of the paragraph "System state under control of the multithread manager".<br>In addition, when creating a module that includes a virtual timer handler, it may not be possible for the virtual timer handler to directly access global data (such as global variables and string literals) using compiling options (other than -G 0). When global data must be accessed, we recommend explicitly passing the address of the global data in the common argument.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerHandler">sceKernelSetVTimerHandler</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelSetVTimerHandlerWide"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelSetVTimerHandlerWide<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Set virtual timer handler with 64-bit argument<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelSetVTimerHandlerWide </b>( 
	SceUID <i>vtid</i>, 
	unsigned long long <i>schedule</i>, 
	SceUInt (*<i>handler</i>)(SceUID, unsigned long long *, unsigned long long *, void *), 
	void *<i>common</i> ); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Virtual timer ID   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>schedule</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Handler start time  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>handler</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Entry point of virtual timer handler  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Arguments passed to the virtual timer handler &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_VTID">SCE_KERNEL_ERROR_ILLEGAL_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Sets the handler that is called when the time of the virtual timer specified by <i>vtid</i> reaches the <i>schedule</i> value. <br>This function is almost the same as <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerHandler">sceKernelSetVTimerHandler</a>() except that it uses a different method for specifying the time. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#vtimerhandlerwide">vtimerhandlerwide</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vtimerhandlerwide"></a>
<table width="100%"><td width="70%"><font size=6>vtimerhandlerwide<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>64-bit argument virtual timer handler prototype<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
SceUInt <b>vtimerhandlerwide</b>( 
	SceUID <i>vtid</i>, 
	unsigned long long *<i>schedule</i>, 
	unsigned long long *<i>actual</i>, 
	void *<i>common</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Called in the context of the interrupt handler.<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Virtual timer ID &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>schedule</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to unsigned long long variable where the scheduled handler calling&nbsp;&nbsp;<br>&nbsp;&nbsp;time is stored   &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>actual</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to unsigned long long variable where the actual handler starting &nbsp;&nbsp;<br>&nbsp;&nbsp;time is stored  &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>common</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;<i>common</i> argument that was specified by <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerHandlerWide">sceKernelSetVTimerHandlerWide</a>()   &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The handler is canceled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;clock(clock&gt;=1)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The handler is called again after the specified time (in microseconds)  &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This prototype is used as the virtual timer handler that is called when the virtual timer handler is set by the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerHandlerWide">sceKernelSetVTimerHandlerWide</a>() function. <br>It is identical to the other prototype except that the types used for passing the scheduled calling time and actual starting time are different.  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetVTimerHandlerWide">sceKernelSetVTimerHandlerWide</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelCancelVTimerHandler"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelCancelVTimerHandler<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Cancel virtual timer handler<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelCancelVTimerHandler </b>( 
	SceUID <i>vtid</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Virtual timer ID &nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_VTID">SCE_KERNEL_ERROR_ILLEGAL_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Cancels the handler that was set for the virtual timer specified by <i>vtid</i>. <br>Although this service call can be called from an interrupt handler, a virtual timer handler cannot cancel itself from its virtual timer handler function by specifying its virtual timer ID. <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferVTimerStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferVTimerStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get virtual timer status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferVTimerStatus </b>( 
	SceUID <i>vtid</i>, 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVTimerInfo">SceKernelVTimerInfo</a> *<i>info</i> 
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>vtid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID of virtual timer for which status is to be obtained&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specifies a pointer to a structure variable for receiving the virtual timer status.&nbsp;&nbsp;<br>&nbsp;&nbsp;Call this function after assigning sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVTimerInfo">SceKernelVTimerInfo</a>) to info-&gt;size.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets the status of a virtual timer.<br>This service call is provided to aid debugging. Information that can be obtained by this service call changes moment by moment. Programming that issues this service call frequently, then changes the control flow according to the information that was received is not recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelVTimerInfo">SceKernelVTimerInfo</a><br><br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelReferSystemStatus"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelReferSystemStatus<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get system status<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelReferSystemStatus </b>( 
	<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSystemStatus">SceKernelSystemStatus</a> *<i>info</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>info</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Pointer to the structure variable for receiving the system status. You must assign &nbsp;&nbsp;<br>&nbsp;&nbsp;sizeof(<a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSystemStatus">SceKernelSystemStatus</a>) to info-&gt;size before calling this function.&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Gets system status. This system call can be called anytime.  <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SceKernelSystemStatus">SceKernelSystemStatus</a><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetThreadmanIdList"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetThreadmanIdList<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get list of IDs under control of thread manager<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetThreadmanIdList </b>( 
	int <i>type</i>, 
	SceUID *<i>readbuf</i>, 
	int <i>readbufsize</i>, 
	int *<i>idcount</i> 
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td rowspan= 27  valign="top">&nbsp;<i>type</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Specify&nbsp;the&nbsp;ID&nbsp;list&nbsp;you&nbsp;wish&nbsp;to&nbsp;obtain&nbsp;by&nbsp;specifying&nbsp;any&nbsp;of&nbsp;the&nbsp;following.&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Thread&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;all&nbsp;threads&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_SleepThread&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;all&nbsp;threads&nbsp;executing&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSleepThread">sceKernelSleepThread</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_DelayThread&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;all&nbsp;threads&nbsp;executing&nbsp;<br>&nbsp;<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>()&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_SuspendThread&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;all&nbsp;threads&nbsp;in&nbsp;SUSPEND&nbsp;state&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_DormantThread&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;all&nbsp;threads&nbsp;in&nbsp;DORMANT&nbsp;state&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Semaphore&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;semaphores&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_EventFlag&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;event&nbsp;flags&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Mbox&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;message&nbsp;boxes&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Vpl&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;variable&nbsp;length&nbsp;memory&nbsp;pools&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Fpl&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;fixed&nbsp;length&nbsp;memory&nbsp;pools&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Mpipe&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;message&nbsp;pipes&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Callback&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;callbacks&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_ThreadEventHandler&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;thread&nbsp;event&nbsp;handlers&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Alarm&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;alarm&nbsp;handlers&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_VTimer&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;virtual&nbsp;timers&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Mutex&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;mutexes&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_LwMutex&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;lightweight&nbsp;mutexes&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;SCE_KERNEL_TMID_Tlspl&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;TLS&nbsp;memory&nbsp;blocks&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Semaphore&nbsp;ID&nbsp;&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;threads&nbsp;placed&nbsp;in&nbsp;wait&nbsp;<br>&nbsp;state&nbsp;by&nbsp;specified&nbsp;semaphore&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Event&nbsp;handler&nbsp;ID&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;threads&nbsp;placed&nbsp;in&nbsp;wait&nbsp;<br>&nbsp;state&nbsp;by&nbsp;specified&nbsp;event&nbsp;handler&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Mutex&nbsp;ID&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;threads&nbsp;placed&nbsp;in&nbsp;wait&nbsp;state&nbsp;by&nbsp;specified&nbsp;mutex&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Lightweight&nbsp;mutex&nbsp;ID&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;threads&nbsp;placed&nbsp;in&nbsp;wait&nbsp;&nbsp;<br>&nbsp;state&nbsp;by&nbsp;specified&nbsp;lightweight&nbsp;&nbsp;<br>&nbsp;mutex&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Message&nbsp;box&nbsp;ID&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;threads&nbsp;placed&nbsp;in&nbsp;wait&nbsp;<br>&nbsp;state&nbsp;by&nbsp;specified&nbsp;message&nbsp;box&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Variable&nbsp;length&nbsp;memory&nbsp;pool&nbsp;ID&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;threads&nbsp;placed&nbsp;in&nbsp;wait&nbsp;<br>&nbsp;state&nbsp;by&nbsp;specified&nbsp;variable&nbsp;length&nbsp;memory&nbsp;pool&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;Fixed&nbsp;length&nbsp;memory&nbsp;pool&nbsp;ID&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;threads&nbsp;placed&nbsp;in&nbsp;wait&nbsp;<br>&nbsp;state&nbsp;by&nbsp;specified&nbsp;fixed&nbsp;length&nbsp;<br>&nbsp;memory&nbsp;pool&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;TLS&nbsp;memory&nbsp;pool&nbsp;ID&nbsp;</td>
<td valign="top">&nbsp;Get&nbsp;list&nbsp;of&nbsp;threads&nbsp;placed&nbsp;in&nbsp;wait&nbsp;&nbsp;<br>&nbsp;state&nbsp;by&nbsp;specified&nbsp;TLS&nbsp;memory&nbsp;&nbsp;<br>&nbsp;pool&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>readbuf</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;start&nbsp;of&nbsp;SceUID&nbsp;array&nbsp;that&nbsp;will&nbsp;store&nbsp;the&nbsp;ID&nbsp;list.&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>readbufsize</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Size&nbsp;of&nbsp;<i>readbuf</i>&nbsp;(number&nbsp;of&nbsp;<i>IDs</i>&nbsp;that&nbsp;can&nbsp;be&nbsp;stored)&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<i>idcount</i>&nbsp;</td>
<td colspan= 2  valign="top">&nbsp;Pointer&nbsp;to&nbsp;variable&nbsp;for&nbsp;obtaining&nbsp;the&nbsp;number&nbsp;of&nbsp;<i>IDs</i>&nbsp;of&nbsp;the&nbsp;specified&nbsp;type.&nbsp;<br>&nbsp;When&nbsp;<i>NULL</i>&nbsp;is&nbsp;specified,&nbsp;the&nbsp;number&nbsp;of&nbsp;<i>IDs</i>&nbsp;is&nbsp;not&nbsp;obtained.&nbsp;</td>
</tr></table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;count&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;count&gt;=0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of entries read into the buffer&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div style="margin-left:50px;"><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_TYPE">SCE_KERNEL_ERROR_ILLEGAL_TYPE</a><br><a href="../kernel/Thread_Manager-Reference-English.htm#SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a><br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This service call is provided to support debugging. The call obtains <i>IDs</i> of threads, semaphores, event handlers, etc., managed by the thread manager.  <br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelGetThreadmanIdType"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelGetThreadmanIdType<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Get type of IDs under control of thread manager<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelGetThreadmanIdType</b>( 
	SceUID <i>uid</i>
); 

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>uid</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID for which you wish to obtain type&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Macro</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Description</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Thread&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a thread&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Semaphore&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a semaphore&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_EventFlag&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is an event flag&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Mbox&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a message box&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Vpl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a variable length memory pool&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Fpl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a fixed length memory pool&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Mpipe&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a message pipe&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Callback&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a callback&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_ThreadEventHandler &nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a thread event handler&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Alarm&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is an alarm handler&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_VTimer&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a virtual timer&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Mutex&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a mutex&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_LwMutex&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a lightweight mutex&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_TMID_Tlspl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is a TLS memory pool&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;ID is not controlled by the thread manager&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function gets types of IDs such as threads, semaphores, and event flags managed by the thread manager.<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="List of Error Codes"></a>
<table width="100%"><td width="70%"><font size=6>List of Error Codes<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Error Codes]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Error codes returned by the PSP&trade; thread manager API <br></div><br>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Macro</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Description</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_OK">SCE_KERNEL_ERROR_OK</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Normal termination&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_CONTEXT">SCE_KERNEL_ERROR_ILLEGAL_CONTEXT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020064&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Called from an interrupt handler&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_CPUDI">SCE_KERNEL_ERROR_CPUDI</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020066&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Interrupts were already disabled&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_PERM">SCE_KERNEL_ERROR_ILLEGAL_PERM</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800200d1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Permission attribute is invalid&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT">SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800200d2&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Illegal argument&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_ADDR">SCE_KERNEL_ERROR_ILLEGAL_ADDR</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800200d3&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Illegal address&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_NO_MEMORY">SCE_KERNEL_ERROR_NO_MEMORY</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020190&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Insufficient memory&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_ATTR">SCE_KERNEL_ERROR_ILLEGAL_ATTR</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020191&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Illegal attr specification&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_ENTRY">SCE_KERNEL_ERROR_ILLEGAL_ENTRY</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020192&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Illegal entry address of thread &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_PRIORITY">SCE_KERNEL_ERROR_ILLEGAL_PRIORITY</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020193&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Illegal priority specification &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE">SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020194&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Illegal stack size specification &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_MODE">SCE_KERNEL_ERROR_ILLEGAL_MODE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020195&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Value of mode argument is illegal&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_MASK">SCE_KERNEL_ERROR_ILLEGAL_MASK</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020196&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Value of mask argument is illegal&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_THID">SCE_KERNEL_ERROR_ILLEGAL_THID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020197&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specified thread is invalid&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_THID">SCE_KERNEL_ERROR_UNKNOWN_THID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020198&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target thread does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_SEMID">SCE_KERNEL_ERROR_UNKNOWN_SEMID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x80020199&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target semaphore does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_EVFID">SCE_KERNEL_ERROR_UNKNOWN_EVFID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x8002019a&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target event flag does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_MBXID">SCE_KERNEL_ERROR_UNKNOWN_MBXID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x8002019b&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target message box does not exist.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_FPLID">SCE_KERNEL_ERROR_UNKNOWN_FPLID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x8002019d&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target fixed length memory &nbsp;&nbsp;<br>&nbsp;&nbsp;pool does not exist.&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_VPLID">SCE_KERNEL_ERROR_UNKNOWN_VPLID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x8002019c&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target variable length &nbsp;&nbsp;<br>&nbsp;&nbsp;memory pool does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_MPPID">SCE_KERNEL_ERROR_UNKNOWN_MPPID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x8002019e&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target message pipe does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_ALMID">SCE_KERNEL_ERROR_UNKNOWN_ALMID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x8002019f&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target alarm does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_TEID">SCE_KERNEL_ERROR_UNKNOWN_TEID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target thread event handler&nbsp;&nbsp;<br>&nbsp;&nbsp;does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_CBID">SCE_KERNEL_ERROR_UNKNOWN_CBID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target callback does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_DORMANT">SCE_KERNEL_ERROR_DORMANT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a2&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target thread was in &nbsp;&nbsp;<br>&nbsp;&nbsp;DORMANT state &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_SUSPEND">SCE_KERNEL_ERROR_SUSPEND</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a3&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target thread was in &nbsp;&nbsp;<br>&nbsp;&nbsp;SUSPEND state &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_NOT_DORMANT">SCE_KERNEL_ERROR_NOT_DORMANT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a4&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target thread was not in &nbsp;&nbsp;<br>&nbsp;&nbsp;DORMANT state&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_NOT_SUSPEND">SCE_KERNEL_ERROR_NOT_SUSPEND</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a5&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target thread was not in &nbsp;&nbsp;<br>&nbsp;&nbsp;SUSPEND state&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_NOT_WAIT">SCE_KERNEL_ERROR_NOT_WAIT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a6&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target thread was not in a &nbsp;&nbsp;<br>&nbsp;&nbsp;WAIT state &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_CAN_NOT_WAIT">SCE_KERNEL_ERROR_CAN_NOT_WAIT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a7&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Attempt was made to enter a &nbsp;&nbsp;<br>&nbsp;&nbsp;wait state when dispatching&nbsp;&nbsp;<br>&nbsp;&nbsp;was prohibited&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_WAIT_TIMEOUT">SCE_KERNEL_ERROR_WAIT_TIMEOUT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a8&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;WAIT state timeout occurred &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_WAIT_CANCEL">SCE_KERNEL_ERROR_WAIT_CANCEL</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201a9&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;WAIT state was canceled &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_RELEASE_WAIT">SCE_KERNEL_ERROR_RELEASE_WAIT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201aa&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;WAIT state was forcibly canceled &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_THREAD_TERMINATED">SCE_KERNEL_ERROR_THREAD_TERMINATED</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201ac&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The target thread was forcibly terminated&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_SEMA_ZERO">SCE_KERNEL_ERROR_SEMA_ZERO</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201ad&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Semaphore resources cannot be acquired &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_SEMA_OVF">SCE_KERNEL_ERROR_SEMA_OVF</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201ae&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Semaphore counter reached &nbsp;&nbsp;<br>&nbsp;&nbsp;maximum value and cannot be&nbsp;&nbsp;<br>&nbsp;&nbsp;updated&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_EVF_COND">SCE_KERNEL_ERROR_EVF_COND</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201af&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Event flag wait condition was&nbsp;&nbsp;<br>&nbsp;&nbsp;not satisfied&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_EVF_MULTI">SCE_KERNEL_ERROR_EVF_MULTI</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201b0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Multiple waits are not &nbsp;&nbsp;<br>&nbsp;&nbsp;permitted for an event flag&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_EVF_ILPAT">SCE_KERNEL_ERROR_EVF_ILPAT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201b1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Event flag wait pattern is illegal&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MBOX_NOMSG">SCE_KERNEL_ERROR_MBOX_NOMSG</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201b2&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Message was not in message box&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MPP_FULL">SCE_KERNEL_ERROR_MPP_FULL</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201b3&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Message pipe is full and no &nbsp;&nbsp;<br>&nbsp;&nbsp;more data can be sent&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MPP_EMPTY">SCE_KERNEL_ERROR_MPP_EMPTY</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201b4&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Message pipe is empty and &nbsp;&nbsp;<br>&nbsp;&nbsp;message cannot be received &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_WAIT_DELETE">SCE_KERNEL_ERROR_WAIT_DELETE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201b5&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;WAIT-target object was deleted&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK">SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201b6&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Memory block to be freed does not belong to&nbsp;&nbsp;<br>&nbsp;&nbsp;the specified memory pool&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE">SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201b7&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specified memory size is invalid&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_TYPE">SCE_KERNEL_ERROR_ILLEGAL_TYPE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201bb&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Invalid type&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_SIZE">SCE_KERNEL_ERROR_ILLEGAL_SIZE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201bc&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Invalid size&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_COUNT">SCE_KERNEL_ERROR_ILLEGAL_COUNT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201bd&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specified count is invalid&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_VTID">SCE_KERNEL_ERROR_UNKNOWN_VTID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201be&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specified virtual timer does not exist &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_VTID">SCE_KERNEL_ERROR_ILLEGAL_VTID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201bf&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specified virtual timer ID is invalid&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_ILLEGAL_KTLSID">SCE_KERNEL_ERROR_ILLEGAL_KTLSID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Specified KTLSID is invalid &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_KTLS_FULL">SCE_KERNEL_ERROR_KTLS_FULL</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;No further KTLS can be reserved &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_KTLS_BUSY">SCE_KERNEL_ERROR_KTLS_BUSY</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c2&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;KTLS is in use &nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_MUTEXID">SCE_KERNEL_ERROR_UNKNOWN_MUTEXID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c3&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target mutex does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MUTEX_FAILED_TO_OWN">SCE_KERNEL_ERROR_MUTEX_FAILED_TO_OWN</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c4&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Mutex resource cannot be acquired&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MUTEX_NOT_OWNED">SCE_KERNEL_ERROR_MUTEX_NOT_OWNED</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c5&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Tried to release mutex that &nbsp;&nbsp;<br>&nbsp;&nbsp;thread does not own&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MUTEX_LOCK_OVF">SCE_KERNEL_ERROR_MUTEX_LOCK_OVF</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c6&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Could not update mutex &nbsp;&nbsp;<br>&nbsp;&nbsp;because lock count is too big&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF">SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c7&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Tried to unlock a mutex more &nbsp;&nbsp;<br>&nbsp;&nbsp;times than it was locked&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MUTEX_RECURSIVE">SCE_KERNEL_ERROR_MUTEX_RECURSIVE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c8&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Mutex does not allow &nbsp;&nbsp;<br>&nbsp;&nbsp;recursive locks&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_MBOX_LOOP">SCE_KERNEL_ERROR_MBOX_LOOP</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201c9&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Duplicate message &nbsp;&nbsp;<br>&nbsp;&nbsp;transmission was detected by &nbsp;&nbsp;<br>&nbsp;&nbsp;message box&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID">SCE_KERNEL_ERROR_UNKNOWN_LWMUTEXID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201ca&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target lightweight mutex does not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_LWMUTEX_FAILED_TO_OWN">SCE_KERNEL_ERROR_LWMUTEX_FAILED_TO_OWN</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201cb&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Lightweight mutex resource &nbsp;&nbsp;<br>&nbsp;&nbsp;cannot be acquired&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_LWMUTEX_NOT_OWNED">SCE_KERNEL_ERROR_LWMUTEX_NOT_OWNED</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201cc&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Tried to release lightweight &nbsp;&nbsp;<br>&nbsp;&nbsp;mutex that thread does not &nbsp;&nbsp;<br>&nbsp;&nbsp;own&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_LWMUTEX_LOCK_OVF">SCE_KERNEL_ERROR_LWMUTEX_LOCK_OVF</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201cd&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Could not update lightweight &nbsp;&nbsp;<br>&nbsp;&nbsp;mutex because lock count is &nbsp;&nbsp;<br>&nbsp;&nbsp;too big&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_LWMUTEX_UNLOCK_UDF">SCE_KERNEL_ERROR_LWMUTEX_UNLOCK_UDF</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201ce&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Tried to unlock a lightweight &nbsp;&nbsp;<br>&nbsp;&nbsp;mutex more times than it was &nbsp;&nbsp;<br>&nbsp;&nbsp;locked&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_LWMUTEX_RECURSIVE">SCE_KERNEL_ERROR_LWMUTEX_RECURSIVE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201cf&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Lightweight mutex does not &nbsp;&nbsp;<br>&nbsp;&nbsp;allow recursive locks&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UNKNOWN_TLSPLID">SCE_KERNEL_ERROR_UNKNOWN_TLSPLID</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201d0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Target TLS memory pool does &nbsp;&nbsp;<br>&nbsp;&nbsp;not exist&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UTLS_FULL">SCE_KERNEL_ERROR_UTLS_FULL</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201d1&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;No more TLS memory pools &nbsp;&nbsp;<br>&nbsp;&nbsp;can be allocated&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a name="SCE_KERNEL_ERROR_UTLS_BUSY">SCE_KERNEL_ERROR_UTLS_BUSY</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;0x800201d2&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;UTLS is in use&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<p><p><hr>
<div ALIGN="right">
    &copy;2010 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
