<html lang="en">
<head>
<title>Cache-Reference</title>
<meta http-equiv="Content-Type" content= text/html; charset=iso-8859-1>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&trade; Programmer Tool Runtime Library Release 6.3.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
Cache Manipulation Utilities Reference
</h1></center>
</a>
<!-- sce_hd1 -->
<div style="margin-left:50px;">   <br></div>
<div style="margin-left:50px;"><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelIsCachedAddr"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelIsCachedAddr<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Determine whether address is cached address<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ int <b>sceKernelIsCachedAddr </b>(
	const void *<i>v</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled states)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled states)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>v</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;User-space virtual address on which to perform address determination&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns 1 if it was a virtual address in the cached addresses (segment kuseg0), or 0 if it was a virtual address in the uncached addresses (segment kuseg1).<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function determines whether or not the address specified by the <i>v</i> argument is a virtual address in segment kuseg0, which is to be CPU cached.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelMakeCachedAddr">sceKernelMakeCachedAddr</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelIsUncachedAddr"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelIsUncachedAddr<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Determine whether address is uncached address<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ int <b>sceKernelIsUncachedAddr </b>(
	const void *<i>v</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled states)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled states)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>v</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;User-space virtual address on which to perform address determination&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns 1 if it was a virtual address in the uncached addresses (segment kuseg1), or 0 if it was a virtual address in the cached addresses (segment kuseg0).<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function determines whether or not the address specified by the <i>v</i> argument is a virtual address in segment kuseg1, which is not to be CPU cached.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelMakeUncachedAddr">sceKernelMakeUncachedAddr</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelMakeCachedAddrUIntPtr"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelMakeCachedAddrUIntPtr<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Make cached address<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ unsigned int <b>sceKernelMakeCachedAddrUIntPtr </b>(
	const void *<i>v</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on an interrupt-disabled or -enabled state)<br>Can be called from a thread (does not depend on an interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>v</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;User-space virtual address on which to perform address conversion&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns a virtual address in the cached addresses (segment kuseg0) as an unsigned int.<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function converts the address specified by the <i>v</i> argument into a virtual address in segment kuseg0, which is to be CPU cached<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelIsCachedAddr">sceKernelIsCachedAddr</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelMakeCachedAddr"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelMakeCachedAddr<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Make cached address<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ void *<b>sceKernelMakeCachedAddr </b>(
	const void *<i>v</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled states)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled states)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>v</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;User-space virtual address on which to perform address conversion&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns a virtual address in the cached addresses (segment kuseg0).<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function converts the address specified by the <i>v</i> argument into a virtual address in segment kuseg0, which is to be CPU cached.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelIsCachedAddr">sceKernelIsCachedAddr</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelMakeUncachedAddrUIntPtr"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelMakeUncachedAddrUIntPtr<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Make uncached address<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ unsigned int <b>sceKernelMakeUncachedAddrUIntPtr </b>(
	const void *<i>v</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on an interrupt-disabled or -enabled state)<br>Can be called from a thread (does not depend on an interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>v</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;User-space virtual address on which to perform address conversion&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns a virtual address in the uncached addresses (segment kuseg1) as an unsigned int.<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function converts the address specified by the <i>v</i> argument into a virtual address in segment kuseg1, which is not to be CPU cached.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelIsUncachedAddr">sceKernelIsUncachedAddr</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelMakeUncachedAddr"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelMakeUncachedAddr<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Function]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Make uncached address<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ void *<b>sceKernelMakeUncachedAddr </b>(
	const void *<i>v</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled states)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled states)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>v</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;User-space virtual address on which to perform address conversion&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns a virtual address in the uncached addresses (segment kuseg1).<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function converts the address specified by the <i>v</i> argument into a virtual address in segment kuseg1, which is not to be CPU cached.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelIsUncachedAddr">sceKernelIsUncachedAddr</a>()<br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheCreateDirtyExclusiveRange"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheCreateDirtyExclusiveRange<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Allocate specified address range as dirty in D-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ void <b>sceKernelDcacheCreateDirtyExclusiveRange </b>(
	void *<i>start</i>,
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled state)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of region to be write-allocated (multiple of 64)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of region to be write-allocated (multiple of 64)&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function places the specified address range in the D-cache and marks it as dirty. As a result, the data will not be fetched from main memory. If it is known that a write is going to be performed to an entire 64-byte D-cache line, omitting the fill from main memory to the D-cache can improve performance. <br><br>Tag check in the ALLEGREX CPU cache is performed using virtual addresses, so the address indicated by the <i>start</i> argument must be in the cached area (segment kuseg0). The sceKernelDcacheCreateDirtyExclusiveRange() function is implemented using the CreateDirtyExclusive(D) operation of the ALLEGREX CPU cache. The operation is undefined when the CreateDirtyExclusive(D) operation is executed on an uncached address, so with an uncached address the sceKernelDcacheCreateDirtyExclusiveRange() function does nothing. <br><br>If the beginning and end of the region specified by the <i>start</i> and <i>size</i> arguments do not fall on 64-byte alignment boundaries, then the lines lying outside the specified region will get prefetched as well.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">__builtin_allegrex_cache()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheFillRange"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheFillRange<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Place specified address range into the D-cache. <br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ void <b>sceKernelDcacheFillRange</b>(
	void *<i>start</i>,
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled state)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of region to be prefetched (multiple of 64)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of region to be prefetched (multiple of 64)&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function places the specified address range into the D-cache. By prefetching data into the D-cache in advance, stalling during computations can be reduced. <br><br>Tag check in the ALLEGREX CPU cache is performed using virtual addresses, so the address indicated by the <i>start</i> argument must be in the cached area (segment kuseg0). The sceKernelDcacheFillRange() function is implemented using the Fill(D) operation of the ALLEGREX CPU cache. There is absolutely no benefit to executing the Fill(D) operation when an uncached address is specified because with an uncached address the sceKernelDcacheFillRange() function does nothing. <br><br>In the ALLEGREX CPU, fetches from the bus into the D-cache are performed in a nonblocking manner, but in the CPU pipeline, nonblocking operations or hit-and-miss operations from the D-cache are not performed. In general, rather than prefetching an entire range, as with the sceKernelDcacheFillRange() function, it is more efficient to insert __builtin_allegrex_cache(SCE_ALLEGREX_CACHEOP_FILL_D) for processing one line at a time, in the loop which carries out the computation. <br><br>If the beginning and end of the region specified by the <i>start</i> and <i>size</i> arguments do not fall on 64-byte alignment boundaries, then the lines lying outside the specified region will get prefetched as well.<br><br></div>

<!-- sce_title -->
<a Name ="HeadingT_2_1">
<div style="margin-left:40px;"><h4><b>Note</b><br><br></h4></div></a>

<div style="margin-left:50px;">If a Fill (D) operation of the CACHE instruction is performed for memory for which there is a hit in the D-cache, ALLEGREX CPU operation is restricted in that the relevant cache line ends up being put in a dirty state even though a write operation has not been performed. A writeback operation for writing to memory is performed for a cache line that is in a dirty state when any cache line is replaced.<br>Therefore, specifying an address range that has already been hit when using the sceKernelDcacheFillRange() function increases the number of dirty lines needlessly and causes a decrease in performance because unnecessary writeback operations end up being performed for a long time after. Be sure not to use sceKernelDcacheFillRange() multiple times for a range that has already been hit.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">__builtin_allegrex_cache()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheInvalidateRange"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheInvalidateRange<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Invalidate a specified range in the D-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDcacheInvalidateRange</b>(
	void *<i>start</i>,
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled state)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of region to be invalidated (multiple of 64)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of region to be invalidated (multiple of 64)&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If an error occurs, a negative value is returned.<br></div>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Result</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Success&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;&lt;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Error&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function invalidates the specified range in the D-cache. If there were dirty lines in the D-cache, their contents are discarded without writing them back to main memory.<br><br>The sceKernelDcacheInvalidateRange() function is used in the following situation. <br></div>
<div style="margin-left:35px;"><ul>
<li> When a memory area is to be written by the DMAC or VFPU write buffer, and you need to be sure that the next read will fetch that data from memory rather than the cache, then this function can be used to ensure that a cache miss will occur when the data is fetched.
</ul></div>
<div style="margin-left:50px;"><br>If the beginning and end of the region specified by the <i>start</i> and <i>size</i> arguments do not fall on 64-byte alignment boundaries, then the lines outside the specified region will get written back to memory and invalidated.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackInvalidateAll">sceKernelDcacheWritebackInvalidateAll</a>(), <a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackInvalidateRange">sceKernelDcacheWritebackInvalidateRange</a>(), __builtin_allegrex_cache()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelMemcpy"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelMemcpy<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Perform memory copy of specified address range<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
void *<b>sceKernelMemcpy</b> (
	void *<i>dest</i>,
	const void *<i>src</i>,
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or -enabled state)<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>dest</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Copy destination start address&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>src</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Copy source start address&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of bytes to copy&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns the same value as <i>dest</i>.<br></div>
        <div style="margin-left:50px;"><pre><font size=3>
</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function checks the type of the specified address range and performs a memory copy using the most appropriate method. If the memory region is data cache-enabled, it will use Create Dirty Exclusive (the Create Dirty Exclusive(D) operation of the ALLEGREX CPU CACHE instruction). Otherwise, it performs a word-by-word memory copy using a non-aligned load/store instruction.<br>The range specified by the <i>dest</i> and <i>size</i> arguments and the range specified by the <i>src</i> and <i>size</i> arguments must not overlap. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">memcpy(), <a href="../peripheral/DMAC-Reference-English.htm#sceDmacMemcpy">sceDmacMemcpy</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelMemset"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelMemset<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Fill specified address range with specified byte<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
void *<b>sceKernelMemset</b> (
	void *<i>start</i>,
	int <i>c</i>,
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or -enabled state)<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of region to fill&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>c</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Data byte with which to fill&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of region to fill&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Returns the same value as <i>start</i>.<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function checks the type of the specified address range and performs a memory fill using the most appropriate method. If the memory region is data cache-enabled, it will use Create Dirty Exclusive (the Create Dirty Exclusive(D) operation of the ALLEGREX CPU CACHE instruction). Otherwise, it performs the memory fill using a word-by-word store instruction and non-aligned load/store instruction.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">memset()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheMemcpyInline"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheMemcpyInline<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Perform memory copy of specified address range<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ void <b>sceKernelDcacheMemcpyInline</b>(
	void *<i>dest,</i>
	const void *<i>src,</i>
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or -enabled state)<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>dest</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Copy destination start address&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>src</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Copy source start address&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Number of bytes to copy&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return value -->
<div style="margin-left:10px;"><b>Return value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function performs a high-speed memory copy of the specified address range using Create Dirty Exclusive (the Create Dirty Exclusive(D) operation of the ALLEGREX CPU CACHE instruction). The range specified by the <i>dest</i> and <i>size</i> arguments and the range specified by the <i>src</i> and <i>size</i> arguments must not overlap. The <i>dest</i> and <i>src</i> arguments must both be 4-byte aligned. <br><br>The ALLEGREX CPU cache performs tag checking using virtual addresses, so the addresses indicated by the <i>dest</i> and <i>src</i> arguments must be cached addresses (segment kuseg0). Executing the CreateDirtyExclusive(D) operation with non-cache addresses specified will result in indeterminate behavior. When non-cache addresses are specified for <i>dest</i> and <i>src</i>, the <a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheMemsetInline">sceKernelDcacheMemsetInline</a>() function performs a byte-by-byte copy without using the CACHE instruction, and thus will be extremely slow.<br><br>This function is expanded inline by the compiler. As a result, the compiler may generate binary code partly to avoid the cost of the function call and to improve performance. However, this will cause the size of the binary to increase, so use of <a href="../kernel/Cache-Reference-English.htm#sceKernelMemset">sceKernelMemset</a>() is normally recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">memcpy(), <a href="../peripheral/DMAC-Reference-English.htm#sceDmacMemcpy">sceDmacMemcpy</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheMemsetInline"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheMemsetInline<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Fill specified address range with specified byte<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
static __inline__ void <b>sceKernelDcacheMemsetInline</b>(
	void *<i>start,</i>
	int <i>c,</i>
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or -enabled state)<br>Can be called from a thread (does not depend on interrupt-disabled or -enabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of region to fill&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>c</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Data byte with which to fill&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of region to fill&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return value -->
<div style="margin-left:10px;"><b>Return value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function performs a high-speed memory fill of the specified address range with the specified byte using Create Dirty Exclusive (the Create Dirty Exclusive(D) operation of the ALLEGREX CPU CACHE instruction). <br><br>The ALLEGREX CPU cache performs tag checking using virtual addresses, so the address indicated by the <i>start</i> argument must be a cached address (segment kuseg0). Executing the CreateDirtyExclusive(D) operation with a non-cache address specified will result in indeterminate behavior. When a non-cache address is specified for <i>start</i>, the sceKernelDcacheMemsetInline() function performs a byte-by-byte fill without using the CACHE instruction, and thus will be extremely slow.<br><br>This function is expanded inline by the compiler. As a result, the compiler may generate binary code partly to avoid the cost of the function call and to improve performance. However, this will cause the size of the binary to increase, so use of <a href="../kernel/Cache-Reference-English.htm#sceKernelMemset">sceKernelMemset</a>() is normally recommended. <br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">memset(), <a href="../kernel/Cache-Reference-English.htm#sceKernelMemset">sceKernelMemset</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheProbe"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheProbe<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Probe the D-cache for the specified address<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDcacheProbe</b> (
	const void *<i>probe</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-enabled or disabled state)<br>Can be called from a thread (does not depend on interrupt-enabled or disabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>probe</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Address to probe&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If an error occurs, a negative value is returned.<br></div>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Result</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_DCACHE_PROBE_HIT_DIRTY&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cached and also dirty&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_DCACHE_PROBE_HIT&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cached&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_DCACHE_PROBE_MISS&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Not cached&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;&lt;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Error&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function checks whether or not the specified virtual address is cached in the D-cache. It returns SCE_KERNEL_DCACHE_PROBE_HIT or SCE_KERNEL_DCACHE_PROBE_HIT_DIRTY if the CPU has cached the associated line. <br><br>If the function returns SCE_KERNEL_DCACHE_PROBE_HIT_DIRTY, it means that the CPU did not perform a writeback after performing a store operation on the associated line. If a read is subsequently performed for a bus master other than the CPU, such as the DMAC, then a writeback must be explicitly performed on the D-cache. <br>If the function returns SCE_KERNEL_DCACHE_PROBE_HIT, it means that after the relevant line was filled in the D-cache, the CPU has not performed a store operation on that line. In this state it is at least certain that the CPU has not performed a write, and the contents of memory have not changed, so it is not necessary to perform a writeback on the D-cache. However, if a write is performed for a bus master other than the CPU, such as the DMAC, then the D-cache must be explicitly invalidated. <br><br>Tag check in the ALLEGREX CPU cache is performed using virtual addresses, so the address indicated by the <i>probe</i> argument must be in the cached area (segment kuseg0). <br><br>The sceKernelDcacheProbe() function was intended to be used as a debugging aid. It can be used, for example, to determine whether a particular memory location in which the D-cache should be coherent is not dirty. It will work on the PSP&trade; console, but this is not recommended.<br><br></div>

<!-- sce_title -->
<a Name ="HeadingT_2_2">
<div style="margin-left:40px;"><h4><b>Note</b><br><br></h4></div></a>

<div style="margin-left:50px;">If a Fill (D) or Fill with Lock (D) operation of the CACHE instruction is performed for memory for which there was a hit in the D-cache, ALLEGREX CPU operation is restricted in that the relevant cache line ends up being put in a dirty state even though a write operation has not been performed. Note that in this case, the sceKernelDcacheProbe() function ends up returning SCE_KERNEL_DCACHE_PROBE_HIT_DIRTY.<br>Since performing a Fill (D) operation for addresses that you already know have been hit will bring about a decrease in performance, this is not recommended.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheProbeRange"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheProbeRange<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Probe a specified range in the D-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDcacheProbeRange</b> (
	void *<i>start,</i>
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled states)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled states)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of region to probe&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of region to probe&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If an error occurs, a negative value is returned.<br></div>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Result</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_DCACHE_PROBE_HIT_DIRTY&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Was partially cached and had dirty lines&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_DCACHE_PROBE_HIT&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Was partially cached&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_DCACHE_PROBE_MISS&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Was not cached at all&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;&lt;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Error&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function determines whether or not the specified address range in the D-cache is cached. It returns SCE_KERNEL_DCACHE_PROBE_HIT or SCE_KERNEL_DCACHE_PROBE_HIT_DIRTY if the CPU cached the associated line. <br>If the function returns SCE_KERNEL_DCACHE_PROBE_HIT_DIRTY, it means that after the CPU performed a store operation, there are some lines in the specified area which did not get written back. If a read is subsequently performed for a bus master other than the CPU, such as the DMAC, then a writeback must be explicitly performed on the D-cache. <br>If the function returns SCE_KERNEL_DCACHE_PROBE_HIT, it means that after the specified area was filled in the D-cache, there are some lines in that area for which the CPU has not performed a store operation. In this state it is at least certain that the contents of memory will not change as the result of a write from the CPU, so it is not necessary to write back the D-cache. However, if a write is performed for a bus master other than the CPU, such as the DMAC, then the D-cache must be explicitly invalidated. <br><br>Tag check in the ALLEGREX CPU cache is performed using virtual addresses, so the address indicated by the <i>start</i> argument must be in the cached area (segment kuseg0). <br><br>The sceKernelDcacheProbeRange() function was intended to be used as a debugging aid. It can be used, for example, to determine whether a particular memory location in which the D-cache should be coherent is not dirty. It will work on the PSP&trade; console, but this is not recommended.<br><br></div>

<!-- sce_title -->
<a Name ="HeadingT_2_3">
<div style="margin-left:40px;"><h4><b>Note</b><br><br></h4></div></a>

<div style="margin-left:50px;">If a Fill (D) or Fill with Lock (D) operation of the CACHE instruction is performed for memory for which there is a hit in the D-cache, ALLEGREX CPU operation is restricted in that the relevant cache line ends up being put in a dirty state even though a write operation has not been performed. Note that in this case, the sceKernelDcacheProbeRange() function ends up returning SCE_KERNEL_DCACHE_PROBE_HIT_DIRTY.<br>Since performing a Fill (D) operation for addresses that you already know have been hit will bring about a decrease in performance, this is not recommended.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheWritebackAll"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheWritebackAll<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Write back entire contents of D-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
void <b>sceKernelDcacheWritebackAll</b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-enabled or disabled state)<br>Can be called from a thread (does not depend on interrupt-enabled or disabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function writes back (writes out) the entire contents of the D-cache. The dirty lines in the D-cache are written to main memory, and the D-cache is made coherent with main memory.<br><br>With the sceKernelDcacheWritebackAll() function, only cache writeback is carried out; invalidation is not performed. Consequently, the data which was cached in the D-cache will remain in the cache.<br><br>The sceKernelDcacheWritebackAll() function is used in the following cases.<br></div>
<div style="margin-left:35px;"><ul>
<li> When a command list was generated at a cached address and the command list is being interpreted by the graphics engine
<li> When updating the display address of the frame buffer after writing to the frame buffer from a cached address
</ul></div>
<div style="margin-left:50px;"><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackInvalidateAll">sceKernelDcacheWritebackInvalidateAll</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheWritebackInvalidateAll"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheWritebackInvalidateAll<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Write back and invalidate entire contents of D-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
void <b>sceKernelDcacheWritebackInvalidateAll</b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-disabled or enabled states)<br>Can be called from a thread (does not depend on interrupt-disabled or enabled states)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function writes back and invalidates the entire contents of the D-cache. The dirty lines in the D-cache are written back to main memory, and all lines will become invalidated. <br>Since the D-cache will become empty, immediately after this function executes, all addresses will result in a D-cache miss. <br>The sceKernelDcacheWritebackInvalidateAll() function is used in the following situations. <br></div>
<div style="margin-left:35px;"><ul>
<li> When having the Graphics Engine interpret a command list which was generated at a cached address
<li> When updating the display address of the frame buffer after writing to the frame buffer from a cached address
</ul></div>
<div style="margin-left:50px;"><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackAll">sceKernelDcacheWritebackAll</a>()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheWritebackInvalidateRange"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheWritebackInvalidateRange<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Write back and invalidate a specified range in the D-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDcacheWritebackInvalidateRange</b>(
	const void *<i>start,</i>
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-enabled or disabled state)<br>Can be called from a thread (does not depend on interrupt-enabled or disabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of the area to write back and invalidate&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of the area to write back and invalidate&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If an error occurs, a negative value is returned.<br></div>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value </b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Result</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Success&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;&lt;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Error&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function writes back (writes out) and invalidates the specified address range from the D-cache. The dirty lines in the D-cache are written to main memory and invalidated, and the D-cache is made coherent with main memory.<br><br>Tag check in the ALLEGREX CPU cache is performed using virtual addresses, so the address indicated by the <i>start</i> argument must be a cached address (segment kuseg0). <br><br>The sceKernelDcacheWritebackInvalidateRange() function is used in the following situations.<br></div>
<div style="margin-left:35px;"><ul>
<li> When a command list was generated at a cached address and the command list is being interpreted by the graphics engine
<li> When updating the display address of the frame buffer after writing to the frame buffer from a cached address
</ul></div>
<div style="margin-left:50px;"><br>If the beginning and end of the area specified by the <i>start</i> and <i>size</i> arguments are not aligned on 64-byte boundaries, then lines that cross the specified area will be written back to memory and invalidated as well.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackRange">sceKernelDcacheWritebackRange</a>(), __builtin_allegrex_cache()<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelDcacheWritebackRange"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelDcacheWritebackRange<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[D-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Write back a specified range in the D-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelDcacheWritebackRange </b>(
	const void *<i>start,</i>
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-enabled or disabled state)<br>Can be called from a thread (does not depend on interrupt-enabled or disabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of area to write back&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of area to write back&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If an error occurs, a negative value is returned.<br></div>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value </b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Result</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Success&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;&lt;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Error&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function writes back (writes out) the specified address range from the D-cache. The dirty lines in the D-cache are written to main memory, and the D-cache is made coherent with main memory for the specified area.<br><br>Tag check in the ALLEGREX CPU cache is performed using virtual addresses, so the address indicated by the <i>start</i> argument must be a cached address (segment kuseg0). <br><br>The sceKernelDcacheWritebackRange() function is used in the following situations.<br></div>
<div style="margin-left:35px;"><ul>
<li> When a command list was generated at a cached address and the command list is being interpreted by the graphics engine
<li> When updating the display address of the frame buffer after writing to the frame buffer from a cached address
</ul></div>
<div style="margin-left:50px;"><br>If the beginning and end of the area specified by the <i>start</i> and <i>size</i> arguments are not aligned on 64-byte boundaries, then lines that cross the specified area will be written back to memory as well.<br><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelDcacheWritebackInvalidateRange">sceKernelDcacheWritebackInvalidateRange</a>(), __builtin_allegrex_cache()<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelIcacheInvalidateAll"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelIcacheInvalidateAll<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[I-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Invalidate the entire contents of the I-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
void <b>sceKernelIcacheInvalidateAll</b>(
	void
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-enabled or disabled state)<br>Can be called from a thread (does not depend on interrupt-enabled or disabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">None<br><br></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function invalidates the entire I-cache. <br>The sceKernelIcacheInvalidateAll() function is used in the following situation. <br></div>
<div style="margin-left:35px;"><ul>
<li> When control is transferred to executable code which was created by some other means other than the kernel module load function. 
</ul></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelIcacheInvalidateRange">sceKernelIcacheInvalidateRange</a>()<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelIcacheInvalidateRange"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelIcacheInvalidateRange<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[I-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Invalidate a specified range in the I-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelIcacheInvalidateRange </b>(
	const void *<i>start,</i>
	unsigned int <i>size</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-enabled or disabled state)<br>Can be called from a thread (does not depend on interrupt-enabled or disabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>start</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Start address of area to invalidate&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>size</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Size of area to invalidate&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If an error occurs, a negative value is returned.<br><br></div>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value </b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Result</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Success&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;&lt;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Error&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function invalidates the specified address range from the I-cache. <br>Since the invalidated addresses will no longer be present in the cache, the next instruction that is read from that address range will result in an I-cache miss.<br><br>Tag check in the ALLEGREX CPU cache is performed using virtual addresses, so the address indicated by the <i>start</i> argument must be in the cached area (segment kuseg0). <br><br>The sceKernelIcacheInvalidateRange() function is used in the following situation. <br></div>
<div style="margin-left:35px;"><ul>
<li> When control is transferred to executable code which was created by some other means other than the kernel module load function. 
</ul></div>
<div style="margin-left:50px;"><br></div>

<!-- See Also -->
<div style="margin-left:10px;"><b>See Also</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><a href="../kernel/Cache-Reference-English.htm#sceKernelIcacheInvalidateAll">sceKernelIcacheInvalidateAll</a>(), __builtin_allegrex_cache()<br><br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sceKernelIcacheProbe"></a>
<table width="100%"><td width="70%"><font size=6>sceKernelIcacheProbe<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[I-Cache Operations]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Probe the I-cache<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>#include &lt;kernel.h&gt;
int <b>sceKernelIcacheProbe</b> (
	const void *<i>probe</i>
);

</font></pre></div>

<!-- Calling Conditions -->
<div style="margin-left:10px;"><b>Calling Conditions</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Can be called from an interrupt handler (does not depend on interrupt-enabled or disabled state)<br>Can be called from a thread (does not depend on interrupt-enabled or disabled state)<br>Multithread safe<br><br></div>

<!-- Arguments -->
<div style="margin-left:10px;"><b>Arguments</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">
<table border=0>
<tr>
<td valign="TOP">&nbsp;&nbsp;<i>probe</i>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Address to probe&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- Return Value -->
<div style="margin-left:10px;"><b>Return Value</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If an error occurs, a negative value is returned.<br><br></div>
<div style="margin-left:50px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Value</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Description</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_ICACHE_PROBE_HIT&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Cached&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;SCE_KERNEL_ICACHE_PROBE_MISS&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Not cached&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;&lt;0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Error&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This function checks whether or not the specified virtual address is cached in the I-cache. <br><br>Tag check in the ALLEGREX CPU cache is performed using virtual addresses, so the address indicated by the <i>probe</i> argument must be in the cached area (segment kuseg0). <br><br>The sceKernelIcacheProbe() function is intended to be used as a debugging aid. It will work on the PSP&trade; console, but this is not recommended.<br><br></div>
<p><p><hr>
<div ALIGN="right">
    &copy;2009 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
