<html lang="en">
<head>
<title>USB_PSPComm-Overview</title>
<meta http-equiv="Content-Type" content= text/html; charset=iso-8859-1>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&trade; Programmer Tool Runtime Library Release 6.3.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
USB PSP&trade; Communications Library Overview
</h1></center>
</a>
<!-- sce_hd1 -->

<!-- sce_hd3 -->
<a name="Heading3_1">
<h2>
 1 <!-- hp --><b>Overview</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_1_1">
<h3>
<a href="#Heading3_1"> 1. </a>1 
<!-- hp1 --><b>Objective</b><br>
</a>
</h3>
<div style="margin-left:50px;">The USB PSP&trade; communications library enables the USB port of the PSP&trade; to be used for data communication between a PlayStation&reg;2 which is the USB host and a PlayStation&reg;3.<br>In addition to communication between the PSP&trade; and USB host, it also enables communication between two PSP&trade; consoles with the USB host side library acting as a relay.<br><br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-English001.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 1 Communication Formats</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_2">
<h3>
<a href="#Heading3_1"> 1. </a>2 
<!-- hp1 --><b>Main Features</b><br>
</a>
</h3>
<div style="margin-left:50px;">The USB PSP&trade; communications library consists of two modules. One module is the USB bus driver and the other module is the USB PSP&trade; communications driver. The USB PSP&trade; communications driver, which is one of the USB protocol drivers, operates by plugging in to the USB bus driver. (For details, refer to the document entitled "USB Driver").<br>The USB PSP&trade; communications library provides the following two types of interfaces.<br><br></div>
</ol>
<div style="margin-left:40px;"><ul>
<li> IO/File access<br>This is the interface for communications. It is used to issue communication initiation requests and to send or receive data.
<li> Connection/disconnection report<br>This is the interface for reporting a PSP&trade; connection/disconnection. By registering a thread for performing processing when a PSP&trade; is connected/disconnected, that thread will be started up each time a PSP&trade; connection/disconnection is detected.
</ul></div>
<div style="margin-left:50px;"></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-English002.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 2 Library Configuration Overview</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_3">
<h3>
<a href="#Heading3_1"> 1. </a>3 
<!-- hp1 --><b>Component Files</b><br>
</a>
</h3>
<div style="margin-left:50px;">The following files are required to use the USB PSP&trade; communications library.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Category</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Filename</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Header file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usb.h&nbsp;&nbsp;<br>&nbsp;&nbsp;usbpspcm.h&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Stub file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usb_stub.a&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Module file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usbpspcm.prx&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_4">
<h3>
<a href="#Heading3_1"> 1. </a>4 
<!-- hp1 --><b>Sample Programs</b><br>
</a>
</h3>
<div style="margin-left:50px;">The following sample programs for the USB PSP&trade; communications library are provided for reference.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_1_4_1"><h4>
(1)&nbsp;<b>devkit/sample/usb/usbpspcm/print/</b><br></h4>
</a></div>
<div style="margin-left:50px;">This program sends a string to the USB host and another PSP&trade; and displays the received string in the debugger at the same time.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_1_4_2"><h4>
(2)&nbsp;<b>devkit/sample/usb/usbpspcm/file_transfer/</b><br></h4>
</a></div>
<div style="margin-left:50px;">This program transfers a file to the USB host and to another PSP&trade;.<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_2">
<h2>
 2 <!-- hp --><b>Usage Procedure</b>
<hr noshade>
</h2>


<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1"><h4>
(1)&nbsp;<b>Load USB PSP&trade; communications driver</b><br></h4>
</a></div>
<div style="margin-left:50px;">Load the USB PSP&trade; communications driver module usbpspcm.prx.<br>For information about the module loading method, refer to the sample programs.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2"><h4>
(2)&nbsp;<b>Activate USB device</b><br></h4>
</a></div>
<div style="margin-left:50px;">Use the following procedure to activate the USB device.<br></div>
<div style="margin-left:67px;"><br></div>
        <div style="margin-left:80px;"><pre><font size=3>const unsigned char *title = "XXXXXXXXXX"; // String for title check

// Start USB bus driver 
if (<a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbStart">sceUsbStart</a>(SCE_USB_BUS_DRIVER_NAME, 0, NULL) &lt; 0) {
	// Error processing
}

// Plug in USB PSP&trade; communications driver 
if (<a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbStart">sceUsbStart</a>(<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_NAME">SCE_USBPSPCM_NAME</a>, sizeof(title), title) &lt; 0) {
	// Error processing
}

// Activate USB device 
if (<a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbActivate">sceUsbActivate</a>(<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USB_PID_PSPCM">SCE_USB_PID_PSPCM</a>) &lt; 0) {
	// Error processing
}

</font></pre></div>
<div style="margin-left:50px;">Note that a title check string of at most 64 bytes is required for the argument when the USB PSP&trade; communications driver is plugged in.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3"><h4>
(3)&nbsp;<b>Generate connection/disconnection processing thread</b><br></h4>
</a></div>
<div style="margin-left:50px;">Generate a thread for performing processing when a PSP&trade; connection/disconnection occurs. This thread performs processing if the connection succeeds or error processing if the connection fails and also performs connection/disconnection processing for another PSP&trade;.<br>Note that the next connection/disconnection is not reported until the connection/disconnection processing thread is terminated. Therefore, do not call a function that enters a wait state or perform processing that takes an extremely long time within this thread.<br>For details, see the Explanation of Operation in the next chapter or refer to the Reference.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Connection/disconnection processing thread
int connection_detect_thread(SceSize argsize, void *arg)
{
	<a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> *conn;

	conn = (<a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> *)arg;

	if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a>) {
		// When the PSP&trade; itself is connected/disconnected
		if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>) {
			int addr = conn-&gt;addr;  // Own address
			// Processing when the PSP&trade; itself is connected
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>) {
			// Processing when the PSP&trade; itself is disconnected
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_INVAL_TITLE">SCE_USBPSPCM_INVAL_TITLE</a>) {
			// When the title check failed
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_BUSY">SCE_USBPSPCM_BUSY</a>) {
			// When the USB host is busy
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_WAIT">SCE_USBPSPCM_WAIT</a>) {
			// When waiting for a title check
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_VERSION_ERROR">SCE_USBPSPCM_VERSION_ERROR</a>) {
			// When the library version is not compatible
		} else {
			// When too many PSP&trade; devices are connected
		}
	} else {
		// When another PSP&trade; is connected/disconnected
		int addr = conn-&gt;addr;  // Address of connected/disconnected PSP&trade;
		if (conn-&gt;stat &amp; SCE_USB_CONNECTED) {
			// Processing when the other PSP&trade; is connected
		} else {
			// Processing when the other PSP&trade; is disconnected
		}
	}

}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_4"><h4>
(4)&nbsp;<b>Register connection/disconnection processing thread</b><br></h4>
</a></div>
<div style="margin-left:50px;">Use the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_REGISTER">SCE_USBPSPCM_REGISTER</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoDevctl">sceIoDevctl</a>() function to register the ID of the connection/disconnection processing thread that was created, in the USB PSP&trade; communications driver. Once this is done, the connection/disconnection processing thread is started up each time a connection/disconnection of the PSP&trade; itself or of another PSP&trade; is detected.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>SceUID thid;
int ret;

// Create thread for executing connection/disconnection processing functions
thid = <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateThread">sceKernelCreateThread</a>("ConnectionDetect", connection_detect_thread,
			     SCE_KERNEL_MODULE_INIT_PRIORITY, 0x1000,
			     SCE_KERNEL_TH_CLEAR_STACK, NULL);
if (thid &lt; 0) {
	// Error processing
}

// Register ID of created thread
ret = <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoDevctl">sceIoDevctl</a>(SCE_USBPSPCM_DEVNAME,
		   <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_REGISTER">SCE_USBPSPCM_REGISTER</a>,
		   &amp;thid, sizeof(SceUID), NULL, 0);
if (ret &lt; 0) {
	// Error processing
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_5"><h4>
(5)&nbsp;<b>Start communications</b><br></h4>
</a></div>
<div style="margin-left:50px;">Issue a communications initiation request by specifying the address of the communication destination for an argument and executing the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoDevctl">sceIoDevctl</a>() function. If the communication destination is the USB host, specify <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_HOST_ADDR">SCE_USBPSPCM_HOST_ADDR</a> for the address.<br>If the communications initiation request is successful, this command returns a device file name. By using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoOpen">sceIoOpen</a>() function to open that device file, the PSP&trade; enters a state in which it can communicate.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>#define BIND_TIMEOUT   2000000  // 2 sec

<a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmBind">SceUsbPspcmBind</a> bind;
SceUChar devname[SCE_USBPSPCM_DEVNAME_LENGTH];
SceUInt timeout = BIND_TIMEOUT;
SceUID fd;
int ret;

bind.size    = sizeof(<a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmBind">SceUsbPspcmBind</a>);
bind.addr    = 1;                          // Address of communication destination
bind.timeout = &amp;timeout;

// Issue communications initiation request
ret = <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoDevctl">sceIoDevctl</a>(SCE_USBPSPCM_DEVNAME,
		    <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a>, 
		    &amp;bind, sizeof(bind), devname, sizeof(devname));
if (ret &lt; 0) {
	// Error processing
}

// Open device file having assigned unit number
fd = <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoOpen">sceIoOpen</a>(devname, SCE_O_RDWR, 0);
if (fd &lt; 0) {
	// Error processing
}
</font></pre></div>
<div style="margin-left:50px;">Note that the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a> command enables a timeout interval to be specified as a means of dealing with a problem such as when the communication destination hangs up. Although it also depends on the situation, normally, an interval of 2 to 3 seconds should be specified (in seconds) as the timeout interval.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_6"><h4>
(6)&nbsp;<b>Send/receive data</b><br></h4>
</a></div>
<div style="margin-left:50px;">When the device file is opened, data can be sent by using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoWrite">sceIoWrite</a>() function and data can be received by using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoRead">sceIoRead</a>() function. Since cache operations are performed within the library when data is sent/received, make sure that the buffer that is passed when data is sent/received is created with 64-byte alignment.<br>Also, for the buffer that is passed when sending data, be sure to specify an address in main memory. If an address that is not in main memory is specified, an <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_ERROR_INVAL">SCE_USBPSPCM_ERROR_INVAL</a> error will occur. Although an address that is not in main memory can be specified for the buffer that is passed when receiving data, performance will drop because the driver internally copies it to the specified address after it is transferred to main memory.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>#define BUF_SIZE    0x1000

char buf[BUF_SIZE] __attribute__ ((aligned (64)));  // 64-byte alignment
SceSSize len;

// Receive data
if ((len = <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoRead">sceIoRead</a>(fd, buf, BUF_SIZE)) &lt; 0) {
	// Error processing
}

// Send data
if ((len = <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoWrite">sceIoWrite</a>(fd, buf, BUF_SIZE)) &lt; 0) {
	// Error processing
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_7"><h4>
(7)&nbsp;<b>Reset communication channel</b><br></h4>
</a></div>
<div style="margin-left:50px;">To reset the communication channel without terminating communications, execute the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RESET">SCE_USBPSPCM_RESET</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoIoctl">sceIoIoctl</a>() function.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Reset communication channel
if (<a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoIoctl">sceIoIoctl</a>(fd, <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RESET">SCE_USBPSPCM_RESET</a>, NULL, 0, NULL, 0) &lt; 0) {
	// Error processing
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_8"><h4>
(8)&nbsp;<b>Terminate communications</b><br></h4>
</a></div>
<div style="margin-left:50px;">Terminate communications by using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoClose">sceIoClose</a>() function to close the device file.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Terminate communications
if (<a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoClose">sceIoClose</a>(fd) &lt; 0) {
	// Error processing
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_9"><h4>
(9)&nbsp;<b>Unregister connection/disconnection processing thread</b><br></h4>
</a></div>
<div style="margin-left:50px;">To cancel the connection/disconnection processing thread registration, use the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_UNREGISTER">SCE_USBPSPCM_UNREGISTER</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoDevctl">sceIoDevctl</a>() function.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>int ret;

// Cancel thread registration
ret = <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoDevctl">sceIoDevctl</a>(SCE_USBPSPCM_DEVNAME,
		    <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_UNREGISTER">SCE_USBPSPCM_UNREGISTER</a>,
		    &amp;thid, sizeof(SceUID), NULL, 0);
if (ret &lt; 0) {
	// Error processing
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_10"><h4>
(10)&nbsp;<b> Termination processing</b><br></h4>
</a></div>
<div style="margin-left:50px;">Use the following procedure to deactivate the USB device.<br></div>
<div style="margin-left:67px;"><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Deactivate USB device
if (<a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbDeactivate">sceUsbDeactivate</a>() &lt; 0) {
	// Error processing
}

// Plug out USB PSP&trade; communications driver
if (<a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbStop">sceUsbStop</a>(<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_NAME">SCE_USBPSPCM_NAME</a>, 0, NULL) &lt; 0) {
	// Error processing
}

// Stop USB bus driver
if (<a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbStop">sceUsbStop</a>(SCE_USB_BUS_DRIVER_NAME, 0, NULL) &lt; 0) {
	// Error processing
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_11"><h4>
(11)&nbsp;<b> Unload USB driver module</b><br></h4>
</a></div>
<div style="margin-left:50px;">Unload the USB PSP&trade; communications driver module.<br>For information about the unloading method, refer to the sample programs.<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_3">
<h2>
 3 <!-- hp --><b>Explanation of Operation</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_3_1">
<h3>
<a href="#Heading3_3"> 3. </a>1 
<!-- hp1 --><b>Title Check</b><br>
</a>
</h3>
<div style="margin-left:50px;">When the PSP&trade; is connected to the USB host, a title check is performed. The title string which was specified for the argument when the USB PSP&trade; communications driver was plugged in and has a length of at most 64 bytes, is sent from the PSP&trade; to the USB host.<br>The USB host uses this string to determine the game title of the newly connected PSP&trade;. Therefore, be sure to set this string to a unique string based on the product number so that the PSP&trade; game can be identified. The TRC also has a description of the title check string for reference.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_2">
<h3>
<a href="#Heading3_3"> 3. </a>2 
<!-- hp1 --><b>PSP&trade; Connection/Disconnection Reporting </b><br>
</a>
</h3>
<div style="margin-left:50px;">The USB PSP&trade; communications library reports the connection/disconnection of the USB cable or the connection/disconnection of another PSP&trade; by starting a registered connection/disconnection processing thread. The <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_REGISTER">SCE_USBPSPCM_REGISTER</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoDevctl">sceIoDevctl</a>() function is used to register the thread. <br>The <a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> structure is passed in the argument of the connection/disconnection processing thread, and the connection/disconnection that is being reported can be determined from the value of that structure's <i>stat</i> member.<br>For reports related to the connection/disconnection of the PSP&trade; itself, the value of <i>stat</i> will be the logical OR of <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a> and the following values.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Macro</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Description</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The PSP&trade; itself was connected&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The PSP&trade; itself was disconnected&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_VERSION_ERROR">SCE_USBPSPCM_VERSION_ERROR</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The library version is not compatible with&nbsp;&nbsp;<br>&nbsp;&nbsp;the one at the USB host side&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_INVAL_TITLE">SCE_USBPSPCM_INVAL_TITLE</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The title check failed&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_BUSY">SCE_USBPSPCM_BUSY</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The USB host side is busy&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_WAIT">SCE_USBPSPCM_WAIT</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Waiting for the title check&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_EXCEEDED">SCE_USBPSPCM_EXCEEDED</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Too many PSP&trade; devices are connected&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>
<div style="margin-left:50px;">For reports related to the connection/disconnection of another PSP&trade;, <i>stat</i> will have one of the following values.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Macro</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Description</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Another PSP&trade; was connected&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;The connection of another PSP&trade; was&nbsp;&nbsp;<br>&nbsp;&nbsp;disconnected&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>
<div style="margin-left:50px;">The following figure shows the operations that are performed between the connection/disconnection processing thread, the PSP&trade;, and the USB host when a connection is established.<br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-English003.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 3 Operation When Connection is Established</b><br>
</div>
<br>
<div style="margin-left:50px;">When a PSP&trade; and a USB host are connected via USB, a version check is performed first to determine if the libraries are compatible between the PSP&trade; and USB host. If an error occurs in this version check, the connection/disconnection processing thread is started up, and the <i>stat</i> member in the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> structure of the argument will have the value (<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a> | <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_VERSION_ERROR">SCE_USBPSPCM_VERSION_ERROR</a>).<br><br>Next, a title check string is sent from the PSP&trade; to the USB host. The USB host decides whether the connection of the newly connected PSP&trade; is permitted from the string that was sent from the PSP&trade;, the number of PSP&trade; devices that are connected, and the status of the USB host.<br>If the connection is refused, the error cause is sent from the USB host to the PSP&trade;, and the connection/disconnection processing thread is started up. At the same time, <i>stat</i> of the the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> structure of the argument is set to the logical OR of <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a> and the error cause.<br>If the connection is permitted, an address is assigned to the connected PSP&trade;, and that address is sent from the USB host to the PSP&trade;. In addition, the connection/disconnection processing thread is started up, and the assigned address is assigned for <i>addr</i> and the value (<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a> | <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>) is assigned for <i>stat</i> in the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> structure of the argument.<br>Then, the addresses of all connected PSP&trade; devices are sent from the USB host to each PSP&trade;. In addition, if there exists another connected PSP&trade;, the connection/disconnection processing thread is started up at each device and connection reports are sent sequentially. At this time, the other PSP&trade; address is assigned for <i>addr</i> and the value <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a> is assigned for <i>stat</i> in the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> structure of the argument.<br><br>Even if the connection/disconnection processing thread is registered when the PSP&trade; was already connected to the USB host, first the fact that the PSP&trade; itself is connected is reported and then the connection reports of other PSP&trade; devices are sent sequentially in a similar manner as described above.<br><br>The following figure shows the operations that are performed when a PSP&trade; is disconnected.<br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-English004.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 4  Operations When the USB is Disconnected</b><br>
</div>
<br>
<div style="margin-left:50px;">When another PSP&trade; connection is disconnected, the addresses of all connected PSP&trade; devices are sent from the USB host to the PSP&trade;. The PSP&trade; that was disconnected is determined by comparing the information that was sent with the previous information, and a disconnection report for that PSP&trade; is sent. At the same time, the address of that PSP&trade; is assigned for <i>addr</i> and the value <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a> is assigned for <i>stat</i> in the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> structure of the argument.<br>If the connection of the PSP&trade; itself was disconnected, since the connection with another PSP&trade; is always disconnected, only the disconnection report for the PSP&trade; itself is sent. At the same time, the value (<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a> | <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>) is assigned for <i>stat</i> in the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> structure of the argument of the connection/disconnection thread.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_3">
<h3>
<a href="#Heading3_3"> 3. </a>3 
<!-- hp1 --><b>Operations When Communications Start</b><br>
</a>
</h3>
<div style="margin-left:50px;">When the USB PSP&trade; communications library receives a communication initiation request that was issued from an application using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoDevctl">sceIoDevctl</a>() function, it waits for a communication initiation request that is issued in a similar manner from the communication destination. When communication initiation requests from both parties are present, the unit number of an empty device file is assigned to establish a communication channel.<br>If the establishment of the communication channel is successful, the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a> command returns the device file name of the assigned unit number. Using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoOpen">sceIoOpen</a>() function to open that device file enables data to be received by using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoRead">sceIoRead</a>() function and data to be sent by using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoWrite">sceIoWrite</a>() function.<br>Since cache operations are performed within the library when data is sent/received, make sure that the buffer that is passed when data is sent/received is created with 64-byte alignment. Also, for the buffer that is passed when sending data, be sure to specify an address in main memory. If an address that is not in main memory is specified, the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_ERROR_INVAL">SCE_USBPSPCM_ERROR_INVAL</a> error will occur. Although an address that is not in main memory can be specified for the buffer that is passed when receiving data, performance will drop because the driver internally copies it to the specified address after it was transferred to main memory.<br>Multiple initiation requests cannot be issued at the same time for the same address. To establish multiple communication channels for the same address, first verify that a communication channel was successfully established by the previous initiation request before issuing the next initiation request.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_4">
<h3>
<a href="#Heading3_3"> 3. </a>4 
<!-- hp1 --><b>Normal Method of Sending/Receiving (Write/Read) Data</b><br>
</a>
</h3>
<div style="margin-left:50px;">By default, <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a>/Write mode is set for the normal mode <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RDWR_NORMAL">SCE_USBPSPCM_RDWR_NORMAL</a>. With this mode, the data for one Write is handled as one chunk of data, and a <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a> ends when the reading of one chunk of data ends. If the remaining size of one chunk of data was not equal to the value of the <i>nbyte</i> argument of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoRead">sceIoRead</a>() function, the next <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a> will end at 0 bytes.<br>The receiving application can determine that the reception of one chunk of data ended when the received data size of the return value is less than the value specified for the <i>nbyte</i> argument of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoRead">sceIoRead</a>() function. Therefore, even when the size of the data that is sent is unknown, the end of one chunk of data can be known with certainty.<br><br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-English005.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 5 Normal Mode (SCE_USBPSPCM_RDWR_NORMAL)</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_3_5">
<h3>
<a href="#Heading3_3"> 3. </a>5 
<!-- hp1 --><b>Receiving Data When the Maximum Size is Known</b><br>
</a>
</h3>
<div style="margin-left:50px;">When the maximum size of the data to be received is known in advance, then even if the remaining size of one chunk of data was not equal to the value of the <i>nbyte</i> argument of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoRead">sceIoRead</a>() function, the receiving application will know that one chunk of data ends at that location. Therefore, the processing in which the next <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a> ends at 0 bytes will be wasted.<br>In this case, using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RDWR_MODE">SCE_USBPSPCM_RDWR_MODE</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoIoctl">sceIoIoctl</a>() function to set the <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a> mode to <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RDWR_RD_SEQ">SCE_USBPSPCM_RDWR_RD_SEQ</a> will enable the next chunk of data to be read immediately in this situation without the next <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a> ending at 0 bytes.<br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-English006.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 6 RD_SEQ Mode (SCE_USBPSPCM_RDWR_RD_SEQ)</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_3_6">
<h3>
<a href="#Heading3_3"> 3. </a>6 
<!-- hp1 --><b>Dividing and Sending Large Amounts of Data</b><br>
</a>
</h3>
<div style="margin-left:50px;">When there is a large amount of data, if an attempt is made to transfer it by a single Write, the sending application load will increase. In this case, using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RDWR_MODE">SCE_USBPSPCM_RDWR_MODE</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoIoctl">sceIoIoctl</a>() function to set the Write mode to <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RDWR_WR_SEQ">SCE_USBPSPCM_RDWR_WR_SEQ</a> will enable one chunk of data to be divided and sent using multiple Writes.<br>With this mode, as long as the size of one Write is an integer multiple of 4K bytes, the library decides that the one chunk of data has not ended yet and that there exists succeeding data. Therefore, be sure that the sending application makes the size of a single Write be an integer multiple of 4K bytes.<br>Also, be sure that the Write mode is returned to normal mode (<a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RDWR_NORMAL">SCE_USBPSPCM_RDWR_NORMAL</a>) before the last chunk of data is written. If the Write mode remains in WR_SEQ mode and the size of the last Write is an integer multiple of 4K bytes, the library will decide that there exists succeeding data and the receiving side will not be able to properly determine that one chunk of data has ended.<br><br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-English007.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 7 WR_SEQ Mode (SCE_USBPSPCM_RDWR_WR_SEQ)</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_3_7">
<h3>
<a href="#Heading3_3"> 3. </a>7 
<!-- hp1 --><b>Operations When Resetting and Terminating Communications</b><br>
</a>
</h3>
<div style="margin-left:50px;">Using the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_RESET">SCE_USBPSPCM_RESET</a> command of the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoIoctl">sceIoIoctl</a>() function enables the communication channel to be reset without terminating communications. When resetting is executed, the reset is reported to the communication destination, and a reset of the communication channel is also executed by the destination.<br>When a reset from the communication destination is executed, if a <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a>, Write, or Ioctl function is executed before the reset is completed, the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_ERROR_RESETTING">SCE_USBPSPCM_ERROR_RESETTING</a> error occurs, and the fact that reset processing is in progress is known. Also, if any <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a>, Write, or Ioctl function is executed after the reset is completed, the <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_ERROR_RESET_END">SCE_USBPSPCM_ERROR_RESET_END</a> error is returned only once, and the fact that the reset was completed is known.<br><br>When the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceIoClose">sceIoClose</a>() function is executed, communication is terminated and the fact that communication was terminated is reported to the communication destination.<br>When the termination of communication is reported from the communication destination, if a <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a>, Write, or Ioctl function is executed before the device file is closed, an <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USBPSPCM_ERROR_CLOSED">SCE_USBPSPCM_ERROR_CLOSED</a> error occurs and the fact that communication was terminated is known.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_8">
<h3>
<a href="#Heading3_3"> 3. </a>8 
<!-- hp1 --><b>Using Software to Perform a Disconnect</b><br>
</a>
</h3>
<div style="margin-left:50px;">Executing the <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbDeactivate">sceUsbDeactivate</a>() function enables the same state to be set as when the USB cable was disconnected even when the USB cable remains connected.<br>Also, after <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbDeactivate">sceUsbDeactivate</a>() was executed, executing <a href="../peripheral/USB_PSPComm-Reference-English.htm#sceUsbActivate">sceUsbActivate</a>() with <a href="../peripheral/USB_PSPComm-Reference-English.htm#SCE_USB_PID_PSPCM">SCE_USB_PID_PSPCM</a> specified for the argument enables the same state to be set as when the USB cable is connected again without disconnecting and connecting the USB cable, and this enables the USB host to decide again whether or not to permit the connection.<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_4">
<h2>
 4 <!-- hp --><b>Precautions</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_4_1">
<h3>
<a href="#Heading3_4"> 4. </a>1 
<!-- hp1 --><b>Close Immediately After a Write</b><br>
</a>
</h3>
<div style="margin-left:50px;">A Write ends when the transfer ends at the hardware level, not when all data is received at the software level. Also, the endpoint used for the data transfer differs for <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a>/Write and Close.<br>Therefore, if a large amount of data is transferred using the Write function, and Close is executed immediately after the Write ends, a Close report may end up getting sent using a different endpoint before the receiving software finishes receiving all of the data, and a communication termination error may occur for the receiving side <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a>.<br><br>To avoid this problem, you can execute Close after the receiving side <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a> ends by executing a <a href="../peripheral/USB_PSPComm-Reference-English.htm#Read">Read</a> with an arbitrary size at the sending side after the Write ends and waiting until Close is reported from the receiving side.<br><br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-English008.gif">
</div>
<br>
<div style="margin-left:50px;"><br><br></div>
<p><p><hr>
<div ALIGN="right">
    &copy;2007 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
