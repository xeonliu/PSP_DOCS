<html lang="jp">
<head>
<title>USB_PSPComm-Overview</title>
<meta http-equiv="Content-Type" content= text/html; charset=Shift_JIS>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&reg; Programmer Tool Runtime Library Release 6.6.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
USB PSP&reg;コミュニケーションライブラリ
</h1></center>
</a>
<!-- sce_hd1 -->

<!-- sce_hd3 -->
<a name="Heading3_1">
<h2>
 1 <!-- hp --><b>概要</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_1_1">
<h3>
<a href="#Heading3_1"> 1. </a>1 
<!-- hp1 --><b>目的</b><br>
</a>
</h3>
<div style="margin-left:50px;">USB PSP&reg;コミュニケーションライブラリは、PSP&reg;のUSBを利用して、USBホストであるPlayStation&reg;2やPlayStation&reg;3と通信を行うためのライブラリです。PSP&reg;とUSBホストの通信に加え、USBホスト側のライブラリが中継器の役割を果たし、PSP&reg;とPSP&reg;の通信も行うことができます。<br><br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-Japanese001.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>図 1 通信の形態</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_2">
<h3>
<a href="#Heading3_1"> 1. </a>2 
<!-- hp1 --><b>主な特徴</b><br>
</a>
</h3>
<div style="margin-left:50px;">USB PSP&reg;コミュニケーションライブラリは、USBバスドライバと、USB PSP&reg;コミュニケーションドライバの2つのモジュールから構成されています。USB PSP&reg;コミュニケーションドライバは、USBプロトコルドライバの1つでありUSBバスドライバにプラグインすることで動作します（詳しくは、別ドキュメント「USBドライバ」をご覧ください）。<br>USB PSP&reg;コミュニケーションライブラリは、以下の2種類のインタフェースを提供します。<br><br></div>
</ol>
<div style="margin-left:40px;"><ul>
<li> IO/Fileアクセス<br>通信のためのインタフェース。通信開始要求の発行やデータの送受信などを行います。
<li> 挿抜通知<br>PSP&reg;の挿抜を通知するためのインタフェース。挿抜時の処理を行うスレッドを登録することで、PSP&reg;の挿抜が検出されるたびにそのスレッドが起動されます。
</ul></div>
<div style="margin-left:50px;"></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-Japanese002.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>図 2 ライブラリの構成概要</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_3">
<h3>
<a href="#Heading3_1"> 1. </a>3 
<!-- hp1 --><b>構成ファイル</b><br>
</a>
</h3>
<div style="margin-left:50px;">USB PSP&reg;コミュニケーションライブラリを使用するために必要なファイルは以下のとおりです。<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>カテゴリ</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>ファイル名</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;ヘッダファイル&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usb.h&nbsp;&nbsp;<br>&nbsp;&nbsp;usbpspcm.h&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;stubファイル&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usb_stub.a&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;モジュールファイル&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usbpspcm.prx&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_4">
<h3>
<a href="#Heading3_1"> 1. </a>4 
<!-- hp1 --><b>サンプルプログラム</b><br>
</a>
</h3>
<div style="margin-left:50px;">USB PSP&reg;コミュニケーションライブラリのサンプルプログラムとして以下のものがありますので、参照してください。<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_1_4_1"><h4>
(1)&nbsp;<b>devkit/sample/usb/usbpspcm/print/</b><br></h4>
</a></div>
<div style="margin-left:67px;">USBホストおよび他のPSP&reg;へ文字列を送信し、同時に受信した文字列をデバッガ上に表示するプログラムです。<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_1_4_2"><h4>
(2)&nbsp;<b>devkit/sample/usb/usbpspcm/file_transfer/</b><br></h4>
</a></div>
<div style="margin-left:67px;">USBホストおよび他のPSP&reg;との間でファイル転送を行うプログラムです。<br></div>

<!-- sce_hd3 -->
<a name="Heading3_2">
<h2>
 2 <!-- hp --><b>使用方法</b>
<hr noshade>
</h2>


<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1"><h4>
(1)&nbsp;<b>USB PSP&reg;コミュニケーションドライバのロード</b><br></h4>
</a></div>
<div style="margin-left:67px;">USB PSP&reg;コミュニケーションドライバのモジュールusbpspcm.prxをロードしてください。<br>モジュールのロード方法についてはサンプルプログラムを参照してください。<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2"><h4>
(2)&nbsp;<b>USBデバイスの始動</b><br></h4>
</a></div>
<div style="margin-left:67px;">以下の手順でUSBデバイスを始動してください。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>const unsigned char *title = "XXXXXXXXXX"; // タイトルチェック用文字列

// USBバスドライバの始動
if (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbStart">sceUsbStart</a>(SCE_USB_BUS_DRIVER_NAME, 0, NULL) &lt; 0) {
	// エラー処理
}

// USB"PSP"コミュニケーションドライバのプラグイン
if (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbStart">sceUsbStart</a>(<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_NAME">SCE_USBPSPCM_NAME</a>, sizeof(title), title) &lt; 0) {
	// エラー処理
}

// USBデバイスの始動
if (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbActivate">sceUsbActivate</a>(<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USB_PID_PSPCM">SCE_USB_PID_PSPCM</a>) &lt; 0) {
	// エラー処理
}

</font></pre></div>
<div style="margin-left:67px;">なお、USB PSP&reg;コミュニケーションドライバをプラグインする際には、64バイト以内のタイトルチェック用文字列が引数に必要です。<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3"><h4>
(3)&nbsp;<b>挿抜処理スレッドの生成</b><br></h4>
</a></div>
<div style="margin-left:67px;">PSP&reg;の挿抜が発生した時に処理を行うスレッドを生成してください。このスレッドでは、接続成功時の処理や接続失敗時のエラー処理、他のPSP&reg;の挿抜処理を行います。<br>なお、挿抜処理スレッドが終了するまでは、次の挿抜通知は行われません。そのため、このスレッド内では待ち状態になるAPIや、非常に時間のかかる処理は行わないようにしてください。<br>詳細は、次章の動作解説やリファレンスをご覧ください。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// 挿抜処理スレッド
int connection_detect_thread(SceSize argsize, void *arg)
{
	<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> *conn;

	conn = (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a> *)arg;

	if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a>) {
		// 自身の挿抜の場合
		if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>) {
			int addr = conn-&gt;addr;  // 自身のアドレス
			// 自身が挿された場合の処理
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>) {
			// 自身が抜かれた場合の処理
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_INVAL_TITLE">SCE_USBPSPCM_INVAL_TITLE</a>) {
			// タイトルチェックに失敗した場合
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_BUSY">SCE_USBPSPCM_BUSY</a>) {
			// USBホストが忙しい場合
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_WAIT">SCE_USBPSPCM_WAIT</a>) {
			// タイトルチェック待ちの場合
		} else if (conn-&gt;stat &amp; <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_VERSION_ERROR">SCE_USBPSPCM_VERSION_ERROR</a>) {
			// ライブラリのバージョンが合っていない場合
		} else {
			// "PSP"の接続台数が多すぎた場合
		}
	} else {
		// 他の"PSP"の挿抜の場合
		int addr = conn-&gt;addr;  // 挿抜された"PSP"のアドレス
		if (conn-&gt;stat &amp; SCE_USB_CONNECTED) {
			// 他の"PSP"が挿された場合の処理
		} else {
			// 他の"PSP"が抜かれた場合の処理
		}
	}

}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_4"><h4>
(4)&nbsp;<b>挿抜処理スレッドの登録</b><br></h4>
</a></div>
<div style="margin-left:67px;"><a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoDevctl">sceIoDevctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_REGISTER">SCE_USBPSPCM_REGISTER</a>コマンドを使って、生成した挿抜処理スレッドのIDをUSB PSP&reg;コミュニケーションドライバに登録してください。これで、自身の挿抜や他のPSP&reg;の挿抜が検出されるたびに、挿抜処理スレッドが起動されます。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>SceUID thid;
int ret;

// 挿抜処理関数を実行するスレッド生成
thid = <a href="../kernel/Thread_Manager-Reference-Japanese.htm#sceKernelCreateThread">sceKernelCreateThread</a>("ConnectionDetect", connection_detect_thread,
			     SCE_KERNEL_MODULE_INIT_PRIORITY, 0x1000,
			     SCE_KERNEL_TH_CLEAR_STACK, NULL);
if (thid &lt; 0) {
	// エラー処理
}

// 生成したスレッドIDを登録
ret = <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoDevctl">sceIoDevctl</a>(SCE_USBPSPCM_DEVNAME,
		   <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_REGISTER">SCE_USBPSPCM_REGISTER</a>,
		   &amp;thid, sizeof(SceUID), NULL, 0);
if (ret &lt; 0) {
	// エラー処理
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_5"><h4>
(5)&nbsp;<b>通信開始</b><br></h4>
</a></div>
<div style="margin-left:67px;">通信したい相手のアドレスを引数に指定し、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoDevctl">sceIoDevctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a>コマンドを実行することで通信開始要求を発行します。通信したい相手がUSBホストの場合は、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_HOST_ADDR">SCE_USBPSPCM_HOST_ADDR</a>をアドレスに指定してください。<br>通信開始要求が成功すると、このコマンドはデバイスファイル名を返します。そのデバイスファイルを<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoOpen">sceIoOpen</a>()関数でオープンすることで通信できる状態となります。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>#define BIND_TIMEOUT   2000000  // 2sec

<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmBind">SceUsbPspcmBind</a> bind;
SceUChar devname[SCE_USBPSPCM_DEVNAME_LENGTH];
SceUInt timeout = BIND_TIMEOUT;
SceUID fd;
int ret;

bind.size    = sizeof(<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmBind">SceUsbPspcmBind</a>);
bind.addr    = 1;                          // 通信したい相手のアドレス
bind.timeout = &amp;timeout;

// 通信開始要求の発行
ret = <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoDevctl">sceIoDevctl</a>(SCE_USBPSPCM_DEVNAME,
		    <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a>, 
		    &amp;bind, sizeof(bind), devname, sizeof(devname));
if (ret &lt; 0) {
	// エラー処理
}

// 割り当てられたユニット番号のデバイスファイルをオープン
fd = <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoOpen">sceIoOpen</a>(devname, SCE_O_RDWR, 0);
if (fd &lt; 0) {
	// エラー処理
}
</font></pre></div>
<div style="margin-left:67px;">なお、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a>コマンドでは、通信相手がハングアップした場合など異常時の対策としてタイムアウト時間を指定することができます。状況にもよりますが、通常はタイムアウト時間として2〜3秒といった秒単位の時間を指定してください。<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_6"><h4>
(6)&nbsp;<b>データ送受信</b><br></h4>
</a></div>
<div style="margin-left:67px;">デバイスファイルをオープンすると、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoWrite">sceIoWrite</a>()関数でデータ送信、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoRead">sceIoRead</a>()関数でデータ受信ができます。データ送受信時にはライブラリ内でキャッシュ操作を行いますので、送受信時に渡すバッファは64バイトアラインさせてください。<br>また、送信時に渡すバッファはメインメモリ上のアドレスを指定してください。メインメモリ以外のアドレスが指定された場合には、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_ERROR_INVAL">SCE_USBPSPCM_ERROR_INVAL</a>のエラーとなります。受信時に渡すバッファはメインメモリ以外のアドレスも指定できますが、ドライバ内部で一度メインメモリ上に転送してから指定されたアドレスへコピーするためパフォーマンスは低下します。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>#define BUF_SIZE    0x1000

char buf[BUF_SIZE] __attribute__ ((aligned (64)));  // 64バイトアライン
SceSSize len;

// データの受信
if ((len = <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoRead">sceIoRead</a>(fd, buf, BUF_SIZE)) &lt; 0) {
	// エラー処理
}

// データの送信
if ((len = <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoWrite">sceIoWrite</a>(fd, buf, BUF_SIZE)) &lt; 0) {
	// エラー処理
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_7"><h4>
(7)&nbsp;<b>通信路のリセット</b><br></h4>
</a></div>
<div style="margin-left:67px;">通信を終了せずに通信路をリセットしたい場合には、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoIoctl">sceIoIoctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RESET">SCE_USBPSPCM_RESET</a>コマンドを実行してください。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// 通信路のリセット
if (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoIoctl">sceIoIoctl</a>(fd, <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RESET">SCE_USBPSPCM_RESET</a>, NULL, 0, NULL, 0) &lt; 0) {
	// エラー処理
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_8"><h4>
(8)&nbsp;<b>通信終了</b><br></h4>
</a></div>
<div style="margin-left:67px;">通信を終了する時は、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoClose">sceIoClose</a>()関数でデバイスファイルをクローズしてください。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// 通信終了
if (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoClose">sceIoClose</a>(fd) &lt; 0) {
	// エラー処理
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_9"><h4>
(9)&nbsp;<b>挿抜処理スレッドの登録解除</b><br></h4>
</a></div>
<div style="margin-left:67px;">挿抜処理スレッドの登録を解除する時は、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoDevctl">sceIoDevctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_UNREGISTER">SCE_USBPSPCM_UNREGISTER</a>コマンドを使用してください。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>int ret;

// スレッドの登録を解除
ret = <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoDevctl">sceIoDevctl</a>(SCE_USBPSPCM_DEVNAME,
		    <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_UNREGISTER">SCE_USBPSPCM_UNREGISTER</a>,
		    &amp;thid, sizeof(SceUID), NULL, 0);
if (ret &lt; 0) {
	// エラー処理
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_10"><h4>
(10)&nbsp;<b>終了処理</b><br></h4>
</a></div>
<div style="margin-left:67px;">USBデバイスを停止する時は、以下の手順で処理してください。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// USBデバイスの停止
if (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbDeactivate">sceUsbDeactivate</a>() &lt; 0) {
	// エラー処理
}

// USB"PSP"コミュニケーションドライバのプラグアウト
if (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbStop">sceUsbStop</a>(<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_NAME">SCE_USBPSPCM_NAME</a>, 0, NULL) &lt; 0) {
	// エラー処理
}

// USBバスドライバの停止
if (<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbStop">sceUsbStop</a>(SCE_USB_BUS_DRIVER_NAME, 0, NULL) &lt; 0) {
	// エラー処理
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_11"><h4>
(11)&nbsp;<b>USBドライバモジュールのアンロード</b><br></h4>
</a></div>
<div style="margin-left:67px;">USB PSP&reg;コミュニケーションドライバのモジュールをアンロードしてください。<br>アンロード方法についてはサンプルプログラムを参照してください。<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_3">
<h2>
 3 <!-- hp --><b>動作解説</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_3_1">
<h3>
<a href="#Heading3_3"> 3. </a>1 
<!-- hp1 --><b>タイトルチェック</b><br>
</a>
</h3>
<div style="margin-left:50px;">PSP&reg;をUSBホストへ接続した際にタイトルチェックが行われます。USB PSP&reg;コミュニケーションドライバをプラグインする際、引数に指定した64バイト以内の文字列がタイトルとしてPSP&reg;からUSBホストへ送信されます。<br>USBホストは、この文字列により新たに接続されたPSP&reg;のゲームタイトルを特定します。そのため文字列には、品番に基づいたPSP&reg;のゲームを特定できるような固有の文字列にしてください。TRCにもタイトルチェック用文字列についての記述がありますので参照してください。<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_2">
<h3>
<a href="#Heading3_3"> 3. </a>2 
<!-- hp1 --><b>PSP&reg;の挿抜通知</b><br>
</a>
</h3>
<div style="margin-left:50px;">USB PSP&reg;コミュニケーションライブラリは、登録された挿抜処理スレッドを起動することで、USBケーブルの挿抜や他のPSP&reg;の挿抜を通知します。挿抜処理スレッドの登録には<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoDevctl">sceIoDevctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_REGISTER">SCE_USBPSPCM_REGISTER</a>コマンドを使用します。<br>挿抜処理スレッドの引数には、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a>構造体が渡され、その構造体のメンバ<i>stat</i>の値から、どのような通知であるかを判断することができます。<br>自分自身の挿抜に関する通知の場合には、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a>と以下の値の論理和をとった値が<i>stat</i>の値となります。<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td bgcolor="#cccccc" valign="top">&nbsp;<b>マクロ</b>&nbsp;</td>
<td bgcolor="#cccccc" valign="top">&nbsp;<b>説明</b>&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>&nbsp;</td>
<td valign="top">&nbsp;自分自身が接続された&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>&nbsp;</td>
<td valign="top">&nbsp;自分自身の接続が切断された&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_VERSION_ERROR">SCE_USBPSPCM_VERSION_ERROR</a>&nbsp;</td>
<td valign="top">&nbsp;ライブラリのバージョンが&nbsp;<br>&nbsp;USBホスト側と合っていない&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_INVAL_TITLE">SCE_USBPSPCM_INVAL_TITLE</a>&nbsp;</td>
<td valign="top">&nbsp;タイトルチェックに失敗した&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_BUSY">SCE_USBPSPCM_BUSY</a>&nbsp;</td>
<td valign="top">&nbsp;USBホスト側が忙しい&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_WAIT">SCE_USBPSPCM_WAIT</a>&nbsp;</td>
<td valign="top">&nbsp;タイトルチェック待ち&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_EXCEEDED">SCE_USBPSPCM_EXCEEDED</a>&nbsp;</td>
<td valign="top">&nbsp;接続されているPSP&reg;の台数が多すぎた&nbsp;</td>
</tr></table>
</div>
<br>
<br>
<div style="margin-left:50px;">他のPSP&reg;の挿抜に関する通知の場合には、<i>stat</i>は以下の値となります。<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td bgcolor="#cccccc" valign="top">&nbsp;<b>マクロ</b>&nbsp;</td>
<td bgcolor="#cccccc" valign="top">&nbsp;<b>説明</b>&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>&nbsp;</td>
<td valign="top">&nbsp;他のPSP&reg;が接続された&nbsp;</td>
</tr>
<tr>
<td valign="top">&nbsp;<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>&nbsp;</td>
<td valign="top">&nbsp;他のPSP&reg;の接続が切断された&nbsp;</td>
</tr></table>
</div>
<br>
<br>
<div style="margin-left:50px;">次に接続時に挿抜処理スレッドとPSP&reg;およびUSBホストとの間で行われる動作を示します。<br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-Japanese003.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>図 3 接続時の動作</b><br>
</div>
<br>
<div style="margin-left:50px;">PSP&reg;とUSBホストがUSBで接続されると、初めにPSP&reg;とUSBホストのお互いのライブラリのバージョンチェックが行われます。このバージョンチェックでエラーとなった場合には、挿抜処理スレッドが起動され、引数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a>構造体の<i>stat</i>には(<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a> | <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_VERSION_ERROR">SCE_USBPSPCM_VERSION_ERROR</a>)の値が代入されます。<br><br>次にPSP&reg;からUSBホストへタイトルチェック用文字列が送信されます。USBホスト側はPSP&reg;から送られた文字列や接続されているPSP&reg;の台数、USBホスト側の状態などから新たに接続されたPSP&reg;の接続を許可するかどうかを判断します。<br>接続を拒否する場合にはエラー要因がUSBホストからPSP&reg;へ送信され、挿抜処理スレッドが起動されます。その際、引数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a>構造体の<i>stat</i>には、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a>とエラー要因の論理和をとった値が代入されます。<br>接続を許可する場合には接続されたPSP&reg;にアドレスが割り当てられ、そのアドレスがUSBホストからPSP&reg;へ送信されます。そして、挿抜処理スレッドが起動され、引数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a>構造体の<i>addr</i>には割り当てられたアドレス、<i>stat</i>には(<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a> | <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>)の値がそれぞれ代入されます。<br>その後、接続中の全てのPSP&reg;のアドレスがUSBホストから各PSP&reg;へ送信されます。そして他に接続されているPSP&reg;がある場合には、一台毎に挿抜処理スレッドが起動され、接続通知が順番に行われます。その際、引数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a>構造体の<i>addr</i>にはそのPSP&reg;のアドレス、<i>stat</i>には<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_CONNECTED">SCE_USBPSPCM_CONNECTED</a>の値がそれぞれ代入されます。<br><br>既にUSBホストに接続された状態で挿抜処理スレッドを登録した場合にも、上記と同様に、まず自分自身が接続されていることが通知された後、他のPSP&reg;の接続通知が順番に行われます。<br><br>次に、PSP&reg;切断時に行われる動作を示します。<br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-Japanese004.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>図 4 USB切断時の動作</b><br>
</div>
<br>
<div style="margin-left:50px;">他のPSP&reg;の接続が切断された場合、接続中の全てのPSP&reg;のアドレスが、USBホストからPSP&reg;へ送信されます。その送信された情報と、以前の情報を比較することで、どのPSP&reg;が抜かれたのかが判断され、そのPSP&reg;の切断通知が行われます。その際、引数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a>構造体の<i>addr</i>にはそのPSP&reg;のアドレス、<i>stat</i>には<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>の値がそれぞれ代入されます。<br>自分自身の接続が切断された場合には、他のPSP&reg;との接続は必ず切断されるため、自分自身の切断通知のみが行われます。その際、挿抜処理スレッドの引数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SceUsbPspcmConnect">SceUsbPspcmConnect</a>構造体の<i>stat</i>には(<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_OWN">SCE_USBPSPCM_OWN</a> | <a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_DISCONNECTED">SCE_USBPSPCM_DISCONNECTED</a>)の値が代入されます。<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_3">
<h3>
<a href="#Heading3_3"> 3. </a>3 
<!-- hp1 --><b>通信開始時の動作</b><br>
</a>
</h3>
<div style="margin-left:50px;">USB PSP&reg;コミュニケーションライブラリは、アプリケーションから<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoDevctl">sceIoDevctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a>コマンドで発行される通信開始要求を受け取ると、通信相手からも同様に通信開始要求が発行されるのを待ちます。両方からの通信開始要求がそろうと、空いるデバイスファイルのユニット番号を割り当てて通信路を確立します。<br>通信路の確立に成功すると、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_BIND">SCE_USBPSPCM_BIND</a>コマンドは割り当てられたユニット番号のデバイスファイル名を返します。そのデバイスファイルを<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoOpen">sceIoOpen</a>()関数でオープンすることで、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoRead">sceIoRead</a>()関数でデータ受信、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoWrite">sceIoWrite</a>()関数でデータ送信を行うことができます。<br>データ送受信時にはライブラリ内でキャッシュ操作を行いますので、送受信時に渡すバッファは64バイトアラインさせてください。また、送信時に渡すバッファはメインメモリ上のアドレスを指定してください。メインメモリ以外のアドレスが指定された場合には、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_ERROR_INVAL">SCE_USBPSPCM_ERROR_INVAL</a>のエラーとなります。受信時に渡すバッファはメインメモリ以外のアドレスも指定できますが、ドライバ内部で一度メインメモリ上に転送してから指定されたアドレスへコピーしますので、パフォーマンスが低下します。<br>なお、同じアドレスへ複数の開始要求を同時に発行することはできません。同じアドレスに対して複数の通信路を確立したい場合には、前の開始要求で通信路の確立が成功したことを確認してから次の開始要求を発行するようにしてください。<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_4">
<h3>
<a href="#Heading3_3"> 3. </a>4 
<!-- hp1 --><b>通常のデータ送受信(Write/Read)方法</b><br>
</a>
</h3>
<div style="margin-left:50px;">デフォルトでは<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>/<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Writeモード">Writeモード</a>が通常モードの<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RDWR_NORMAL">SCE_USBPSPCM_RDWR_NORMAL</a>に設定されています。このモードでは1回のWriteデータを一塊のデータとして扱い、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>は一塊のデータを読み終わった時点で終了します。もし、一塊のデータの残りのサイズと、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoRead">sceIoRead</a>()関数の引数<i>nbyte</i>の値が等しかった場合には、次の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>が0バイトで終了します。<br>受信側アプリケーションでは、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoRead">sceIoRead</a>()関数の引数<i>nbyte</i>に指定した値よりも、返り値の受信データサイズの方が小さかった時点で、一塊のデータを受信し終わったと判断することができます。そのため、送られるデータサイズが不明な場合にも、確実に一塊のデータの終了を知ることができます。<br><br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-Japanese005.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>図 5 通常モード(SCE_USBPSPCM_RDWR_NORMAL)</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_3_5">
<h3>
<a href="#Heading3_3"> 3. </a>5 
<!-- hp1 --><b>最大サイズが分かっている場合のデータ受信方法</b><br>
</a>
</h3>
<div style="margin-left:50px;">あらかじめ受信するデータの最大サイズが分かっている場合には、一塊のデータの残りのサイズと、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoRead">sceIoRead</a>()関数の引数<i>nbyte</i>の値が等しかった場合でも、受信側アプリケーションはそこで一塊のデータが終了であることが分かります。そのため、次の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>が0Byteで終了する処理は冗長な処理となります。<br>このような場合には、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoIoctl">sceIoIoctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RDWR_MODE">SCE_USBPSPCM_RDWR_MODE</a>コマンドを使って、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>モードを<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RDWR_RD_SEQ">SCE_USBPSPCM_RDWR_RD_SEQ</a>に設定することで、上記の場合でも次の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>は0Byteで終了せず、続けて次の一塊のデータを読むことができるようになります。<br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-Japanese006.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>図 6 RD_SEQモード(SCE_USBPSPCM_RDWR_RD_SEQ)</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_3_6">
<h3>
<a href="#Heading3_3"> 3. </a>6 
<!-- hp1 --><b>大きなサイズのデータ分割送信方法</b><br>
</a>
</h3>
<div style="margin-left:50px;">データサイズが大きい場合、1回のWriteで転送しようとすると送信側アプリケーションの負荷が大きくなってしまいます。このような場合には、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoIoctl">sceIoIoctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RDWR_MODE">SCE_USBPSPCM_RDWR_MODE</a>コマンドを使って、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Writeモード">Writeモード</a>を<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RDWR_WR_SEQ">SCE_USBPSPCM_RDWR_WR_SEQ</a>に設定することで、一塊のデータを複数回のWriteで分割して送信する事ができます。<br>このモードでは、１回のWriteのサイズが4KByteの整数倍である場合に限り、ライブラリは一塊のデータがまだ終わりではなく、続きのデータがあるものと判断します。そのため、送信側アプリケーションでは、1回のWriteのサイズを4KByteの整数倍になるようにしてください。<br>また、一塊のデータの最後のWriteだけは、通常モード(<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RDWR_NORMAL">SCE_USBPSPCM_RDWR_NORMAL</a>)に戻してからWriteするようにしてください。もし、WR_SEQモードのままで、最後のWriteサイズが4KByteの整数倍であった場合、ライブラリは続きのデータがあるものと判断してしまい、受信側で一塊のデータの最後を正しく判断することができなくなります。<br><br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-Japanese007.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>図 7 WR_SEQモード(SCE_USBPSPCM_RDWR_WR_SEQ)</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_3_7">
<h3>
<a href="#Heading3_3"> 3. </a>7 
<!-- hp1 --><b>リセットおよび通信終了時の動作</b><br>
</a>
</h3>
<div style="margin-left:50px;"><a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoIoctl">sceIoIoctl</a>()関数の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_RESET">SCE_USBPSPCM_RESET</a>コマンドを使用することで、通信を終了せずに通信路をリセットすることができます。リセットを実行すると通信相手にリセットが通知され、相手側でも通信路のリセットが実行されます。<br>通信相手からリセットされた場合は、リセット完了前に<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a> / Write / Ioctlのいずれかを実行すると<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_ERROR_RESETTING">SCE_USBPSPCM_ERROR_RESETTING</a>のエラーが返り、リセット中であることが分かります。また、リセット完了後は、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a> / Write / Ioctlのいずれかを実行した時に、一度だけ<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_ERROR_RESET_END">SCE_USBPSPCM_ERROR_RESET_END</a>のエラーが返り、リセットが完了したことが分かります。<br><br><a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceIoClose">sceIoClose</a>()関数を実行すると通信が終了し、通信相手に通信が終了したことが通知されます。<br>通信相手から通信の終了が通知された場合は、デバイスファイルをクローズするまで、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a> / Write / Ioctlを実行した時に<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USBPSPCM_ERROR_CLOSED">SCE_USBPSPCM_ERROR_CLOSED</a>のエラーが返り、通信が終了したことが分かります。<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_8">
<h3>
<a href="#Heading3_3"> 3. </a>8 
<!-- hp1 --><b>ソフトウェアによる接続の切断方法</b><br>
</a>
</h3>
<div style="margin-left:50px;"><a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbDeactivate">sceUsbDeactivate</a>()を実行することで、USBケーブルを接続したままでも、USBケーブルが抜かれた時と同じ状態にすることができます。<br>また、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbDeactivate">sceUsbDeactivate</a>()後に<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#SCE_USB_PID_PSPCM">SCE_USB_PID_PSPCM</a>を引数に指定して<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#sceUsbActivate">sceUsbActivate</a>()を実行することで、USBケーブルを抜き挿しすることなく、USBケーブルが再び挿された時と同じ状態にすることができ、USBホストによる接続の可否判断からやり直すことができます。<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_4">
<h2>
 4 <!-- hp --><b>注意事項</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_4_1">
<h3>
<a href="#Heading3_4"> 4. </a>1 
<!-- hp1 --><b>Write直後のCloseについて</b><br>
</a>
</h3>
<div style="margin-left:50px;">Writeは受信側がソフトウェアレベルでデータを全て受信してから終了するのではなく、ハードウェアレベルでの転送が終了した時点で終了します。また、<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>/WriteとCloseでは、データ転送に用いるエンドポイントが異なっています。<br>そのため、多くのデータをWriteで転送し、Write終了後すぐにCloseを実行すると、受信側のソフトウェアがデータを全て受信し終わる前に、別のエンドポイントを使用したCloseの通知が先に行われ、受信側の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>が通信終了のエラーとなってしまう可能性があります。<br><br>この問題の回避策としては、送信側でWrite終了後に任意のサイズの<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>を実行し、受信側からCloseされるまで待つことで、受信側の<a href="../peripheral/USB_PSPComm-Reference-Japanese.htm#Read">Read</a>が終了してからCloseすることができます。<br><br></div>

<div align=center>
<p>
<img src="gif/USB_PSPComm-Overview-Japanese008.gif">
</div>
<br>
<div style="margin-left:50px;"><br><br></div>
<p><p><hr>
<div ALIGN="right">
    &copy;2007 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
