<html lang="en">
<head>
<title>USB_Camera-Overview</title>
<meta http-equiv="Content-Type" content= text/html; charset=iso-8859-1>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&trade; Programmer Tool Runtime Library Release 6.3.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
USB Camera Overview
</h1></center>
</a>
<!-- sce_hd1 -->

<!-- sce_hd3 -->
<a name="Heading3_1">
<h2>
 1 <!-- hp --><b>Library Overview</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_1_1">
<h3>
<a href="#Heading3_1"> 1. </a>1 
<!-- hp1 --><b>Overview</b><br>
</a>
</h3>
<div style="margin-left:50px;">The USB Camera library can capture JPEG image data and PCM data from a camera via the USB port. The camera is one of the USB accessories for the PSP&trade;.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_1_2">
<h3>
<a href="#Heading3_1"> 1. </a>2 
<!-- hp1 --><b>Library Configuration</b><br>
</a>
</h3>
<div style="margin-left:50px;">The USB Camera library consists of the following three modules.<br></div>
<div style="margin-left:40px;"><ul>
<li> USB bus driver (resident module)<br>Serves as the base of the PSP&trade; USB.
<li> USB accessory base driver <br>Performs processing common to USB accessories 
<li> USB camera driver<br>Provides an interface for controlling the camera
</ul></div>
<div style="margin-left:50px;"><br>For information about the USB bus driver, refer to the USB_Driver-Overview and USB_Driver-Reference.<br>The USB Camera library by itself allows both camera and mic functions to be used.<br>Note that by loading the USB Camera library separately from the USB Mic library, the USB camera hardware itself can be used just like the USB mic hardware.<br>However, the USB Camera library and USB Mic library cannot be used at the same time.<br>For information about the USB mic, refer to the &quot;USB_Mic-Overview&quot; and &quot;USB_Mic-Reference&quot;.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_1_3">
<h3>
<a href="#Heading3_1"> 1. </a>3 
<!-- hp1 --><b>Main Functions of the USB Camera Library</b><br>
</a>
</h3>
<div style="margin-left:50px;">For image data<br></div>
<div style="margin-left:40px;"><ul>
<li> The image data format that can be obtained is a JPEG image for which the source data is YUV420 or YUV422
<li> For video (consecutive JPEG images), resolutions of 640x480(VGA), 480x272(PSP1), 360x272(PSP2), 352x288(CIF), 320x240(QVGA), 176x144(QCIF), and 160x120(QQVGA) and frame rates of 60fps, 30fps, 20fps, 15fps, 10fps, 7.5fps, 5fps, and 3.75fps are supported. However, the 60fps frame rate is valid only for resolutions up to 320x240.
<li> For still images, resolutions of 1280x960(SXGA), 1024x768(XGA), 640x480(VGA),480x272(PSP1), 360x272(PSP2), 352x288(CIF), 320x240(QVGA), 176x144(QCIF), and 160x120(QQVGA) can be selected. However, only YUV422 is supported for 1280x960 and 1024x768.
<li> Brightness, saturation, contrast, and sharpness can be changed
<li> The file size to be obtained can be specified
<li> Exposure compensation and white balance can be specified
<li> Zoom is supported
</ul></div>
<div style="margin-left:50px;"><br>For audio data<br></div>
<div style="margin-left:40px;"><ul>
<li> The audio data format that can be obtained is 16-bit PCM, and the monaural sampling frequency can be either 44100 [Hz], 22050 [Hz], or 11025 [Hz]
<li> The input gain can be adjusted manually
<li> Auto level control of the input gain (ALC)
<li> Built-in noise gate function during ALC 
</ul></div>

<!-- sce_hd4 -->
<a name="Heading4_1_4">
<h3>
<a href="#Heading3_1"> 1. </a>4 
<!-- hp1 --><b>Related Files</b><br>
</a>
</h3>
<div style="margin-left:50px;">The following files are required to use the USB Camera library.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Category</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Filename</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Header file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usb.h&nbsp;&nbsp;<br>&nbsp;&nbsp;usbacc.h&nbsp;&nbsp;<br>&nbsp;&nbsp;usbcam.h&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Stub file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usb_stub.a&nbsp;&nbsp;<br>&nbsp;&nbsp;usbacc_stub.a or usbacc_stub_weak.a&nbsp;&nbsp;<br>&nbsp;&nbsp;usbcam_stub.a or usbcam_stub_weak.a&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Module file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;usbacc.prx&nbsp;&nbsp;<br>&nbsp;&nbsp;usbcam.prx&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_5">
<h3>
<a href="#Heading3_1"> 1. </a>5 
<!-- hp1 --><b>Sample Programs</b><br>
</a>
</h3>
<div style="margin-left:50px;">The following USB Camera library sample programs are available for reference.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_1_5_1"><h4>
(1)&nbsp;<b>devkit/sample/usb/accessory/usbcam/simplemovie</b><br></h4>
</a></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_1_5_2"><h4>
(2)&nbsp;<b>devkit/sample/usb/accessory/usbcam/simplestill</b><br></h4>
</a></div>
<div style="margin-left:67px;"><br></div>

<!-- sce_hd3 -->
<a name="Heading3_2">
<h2>
 2 <!-- hp --><b>Overview of Usage Procedure</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_2_1">
<h3>
<a href="#Heading3_2"> 2. </a>1 
<!-- hp1 --><b>Load USB Drivers</b><br>
</a>
</h3>
<div style="margin-left:50px;">Load the USB accessory base driver and the USB camera driver using the USB module utility.<br>To see how to load these modules, refer to the sample programs.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_2">
<h3>
<a href="#Heading3_2"> 2. </a>2 
<!-- hp1 --><b>Initialize USB Drivers </b><br>
</a>
</h3>
<div style="margin-left:50px;">Start each USB driver by executing <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStart">sceUsbStart</a>() in the following order.<br></div>
<div style="margin-left:67px;"><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Start USB bus driver
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStart">sceUsbStart</a>(SCE_USB_BUS_DRIVER_NAME, 0, NULL) &lt; 0) {
	// Error handling
}

// Start USB accessory base driver
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStart">sceUsbStart</a>(SCE_USBACC_NAME, 0, NULL) &lt; 0) {
	// Error handling
}

// Start USB camera driver
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStart">sceUsbStart</a>(<a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_NAME">SCE_USBCAM_NAME</a>, 0, NULL) &lt; 0) {
	// Error handling
}

// Start USB camera mic driver
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStart">sceUsbStart</a>(<a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAMMIC_NAME">SCE_USBCAMMIC_NAME</a>, 0, NULL) &lt; 0) {
	// Error handling
}
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_2_3">
<h3>
<a href="#Heading3_2"> 2. </a>3 
<!-- hp1 --><b>Activate USB Device</b><br>
</a>
</h3>
<div style="margin-left:50px;">Call <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbActivate">sceUsbActivate</a>() to activate the USB device. At this time, power to the USB camera will be automatically started. Specify <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USB_PID_CAM">SCE_USB_PID_CAM</a> for the argument to <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbActivate">sceUsbActivate</a>().<br></div>
<div style="margin-left:67px;"><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Activate USB device
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbActivate">sceUsbActivate</a>(<a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USB_PID_CAM">SCE_USB_PID_CAM</a>) &lt; 0) {
	// Error handling
}
</font></pre></div>
<div style="margin-left:50px;"><br>Before the USB device is activated, only <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupVideo">sceUsbCamSetupVideo</a>() and <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupStill">sceUsbCamSetupStill</a>(), which initialize camera input and set parameters, and <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupMic">sceUsbCamSetupMic</a>(), which initializes mic input and sets codec parameters, can be called. The parameters that are set are maintained until the USB camera driver is stopped.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_4">
<h3>
<a href="#Heading3_2"> 2. </a>4 
<!-- hp1 --><b>Controlling Camera Input</b><br>
</a>
</h3>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_4_1"><h4>
(1)&nbsp;<b>Connection/disconnection processing</b><br></h4>
</a></div>
<div style="margin-left:67px;">Detect USB camera connection/disconnection. Although the library can detect disconnection, it cannot detect connection.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
// Detect USB camera
#define USBSTS_WAIT    0
#define USBSTS_CONNECT 1
int UsbStat;
int ret, is_acc =0;
while(1){
   unsigned int usb_state;
   switch(UsbStat){
   case USBSTS_WAIT:
       usb_state = <a href="../peripheral/USB_Driver-Reference-English.htm#sceUsbGetState">sceUsbGetState</a>();
       if ((usb_state &amp; SCE_USB_STATE_MASK) == SCE_USB_CONFIGURED){
         ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbAccGetAuthStat">sceUsbAccGetAuthStat</a>();
         if(ret &lt; 0){
            if( ret == (int)<a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBACC_ERROR_NOT_ACCESSORY">SCE_USBACC_ERROR_NOT_ACCESSORY</a> ){
               //Display a warning message since device is not a PSP&trade; accessory
                 is_acc = 0;
            }
            else{
               //Other errors
               break;
            }
         }
       }
       else{
          is_acc = 1;
       }
       UsbStat = USBSTS_CONNECT;
       printf(&quot;Connected Usb Camera \n&quot;);
       break;

   case USBSTS_CONNECT:
      if(is_acc){
         //Obtain image or audio from  USB camera
         if(disconnection is detected by library)
            UsbStat = USBSTS_WAIT;
      }
      else{
         usb_state = <a href="../peripheral/USB_Driver-Reference-English.htm#sceUsbGetState">sceUsbGetState</a>();
         if ((usb_state &amp; SCE_USB_CONN_MASK) == SCE_USB_DISCONNECTED){
            UsbStat = USBSTS_WAIT;
         }
         else{
            //Display warning until USB device that is not a PSP&trade; accessory is disconnected
         }
      }
      break;
   }
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_4_2"><h4>
(2)&nbsp;<b>Obtaining video</b><br></h4>
</a></div>
<div style="margin-left:67px;">Assign parameters and work memory that will be used by calling <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupVideo">sceUsbCamSetupVideo</a>(). The <i>target_file_size</i> member is specified with the average image size per frame, which is an approximate value for the size of the image. As a result, the image size that is obtained may exceed <i>target_file_size</i>. However, it will not exceed <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_FRAME_MAXSIZE">SCE_USBCAM_VIDEO_FRAME_MAXSIZE</a>. <br>When the image size exceeds <i>target_file_size</i>, the exposed subject may be significantly changed such as when the subject enters the photographic range.<br>As a rule of thumb, the work memory should be approximately twice the size of the image to be obtained.<br>Specifically, although <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_WORK_MAXSIZE">SCE_USBCAM_VIDEO_WORK_MAXSIZE</a> is a defined value indicating the maximum amount of work memory to be used, if the value of the <i>target_file_size</i> member of the <a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamVideoParam">SceUsbCamVideoParam</a> structure does not exceed 32KiB, a value twice this size will be used as the maximum amount of work memory.<br>Allocate the work memory with 64-byte alignment.<br><br>Two APIs are provided for obtaining video. One is synchronous and the other is asynchronous.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Obtain video from the USB camera (synchronous)
#define USBCAM_WORKSIZE <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_WORK_MAXSIZE">SCE_USBCAM_VIDEO_WORK_MAXSIZE</a>
#define JPEG_SIZE 24*1024
static unsigned char camwork[USBCAM_WORKSIZE] __attribute__((aligned(64)));
static unsigned char jpegbuf[<a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_FRAME_MAXSIZE">SCE_USBCAM_VIDEO_FRAME_MAXSIZE</a>] __attribute__((aligned(64)));
int ret;
<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamVideoParam">SceUsbCamVideoParam</a> param;
param.size           = sizeof(<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamVideoParam">SceUsbCamVideoParam</a>);
param.resolution     = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_RESOLUTION_PSP1">SCE_USBCAM_RESOLUTION_PSP1</a>;
param.frame_rate     = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_FRAME_RATE_30_FPS">SCE_USBCAM_FRAME_RATE_30_FPS</a>;
param.white_balance  = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_WB_AUTO">SCE_USBCAM_WB_AUTO</a>;
param.saturation     = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_SATURATION_LV_DEFAULT">SCE_USBCAM_SATURATION_LV_DEFAULT</a>;
param.brightness     = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_BRIGHTNESS_LV_DEFAULT">SCE_USBCAM_BRIGHTNESS_LV_DEFAULT</a>;
param.contrast       = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_CONTRAST_LV_DEFAULT">SCE_USBCAM_CONTRAST_LV_DEFAULT</a>;
param.sharpness      = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_SHARPNESS_LV_DEFAULT">SCE_USBCAM_SHARPNESS_LV_DEFAULT</a>;
param.effect_mode    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_EFFECT_MODE_NORMAL">SCE_USBCAM_EFFECT_MODE_NORMAL</a>;
param.target_file_size    = JPEG_SIZE;
param.sensitivity    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_SENSITIVITY_ISO100">SCE_USBCAM_SENSITIVITY_ISO100</a>;
param.evlevel = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_EVLEVEL_00">SCE_USBCAM_EVLEVEL_00</a>;
param.zoom    = 10;

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupVideo">sceUsbCamSetupVideo</a>(&amp;param,camwork,USBCAM_WORKSIZE)
if (ret &lt; 0){
   //Error handling
}
ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStartVideo">sceUsbCamStartVideo</a>();
if (ret &lt; 0){
   //Error handling
}
while(1){
   SceSize jpegsize;
   if(termination decision == true){
      <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStopVideo">sceUsbCamStopVideo</a>();
      break;
   }
   ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamReadVideoFrameBlocking">sceUsbCamReadVideoFrameBlocking</a>(jpegbuf,sizeof(jpegbuf));
   if(ret &lt; 0){
      if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
         // USB camera was disconnected
         break;
      }
      else{
         //Error handling
            if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_BUFFER_SIZE">SCE_USBCAM_ERROR_BUFFER_SIZE</a>) {
               //Only as much JPEG data that will fit in jpegbuf was stored.
            }
      }
   }
   jpegsize = (SceSize)ret;
      if(jpegsize &gt; 0){
         // Perform operations on the Jpeg data
      }
}

// Obtain video from USB camera (asynchronous)
SceSize size,jpegsize;
unsigned char *jpegbuf[2];
unsigned char *camwork;
int i,ret;
<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamVideoParam">SceUsbCamVideoParam</a> param;

camwork = memalign(64, <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_WORK_MAXSIZE">SCE_USBCAM_VIDEO_WORK_MAXSIZE</a>);

for(i=0; i&lt;2; i++){
   jpegbuf[i] = memalign(64, <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_FRAME_MAXSIZE">SCE_USBCAM_VIDEO_FRAME_MAXSIZE</a>);
}
param.size           = sizeof(<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamVideoParam">SceUsbCamVideoParam</a>);
param.resolution     = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_RESOLUTION_PSP1">SCE_USBCAM_RESOLUTION_PSP1</a>;
param.frame_rate     = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_FRAME_RATE_30_FPS">SCE_USBCAM_FRAME_RATE_30_FPS</a>;
param.white_balance  = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_WB_AUTO">SCE_USBCAM_WB_AUTO</a>;
param.saturation     = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_SATURATION_LV_DEFAULT">SCE_USBCAM_SATURATION_LV_DEFAULT</a>;
param.brightness     = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_BRIGHTNESS_LV_DEFAULT">SCE_USBCAM_BRIGHTNESS_LV_DEFAULT</a>;
param.contrast       = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_CONTRAST_LV_DEFAULT">SCE_USBCAM_CONTRAST_LV_DEFAULT</a>;
param.sharpness      = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_SHARPNESS_LV_DEFAULT">SCE_USBCAM_SHARPNESS_LV_DEFAULT</a>;
param.effect_mode    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_EFFECT_MODE_NORMAL">SCE_USBCAM_EFFECT_MODE_NORMAL</a>;
param.target_file_size    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_FRAME_MAXSIZE">SCE_USBCAM_VIDEO_FRAME_MAXSIZE</a>;
param.sensitivity    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_SENSITIVITY_ISO100">SCE_USBCAM_SENSITIVITY_ISO100</a>;
param.evlevel = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_EVLEVEL_00">SCE_USBCAM_EVLEVEL_00</a>;
param.zoom    = 10;

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupVideo">sceUsbCamSetupVideo</a>(&amp;param, camwork, <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_WORK_MAXSIZE">SCE_USBCAM_VIDEO_WORK_MAXSIZE</a>);
if (ret &lt; 0){
   //Error handling
}

jpegsize = 0;
for(i=0;;i^=0x01){
   ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamReadVideoFrame">sceUsbCamReadVideoFrame</a>(jpegbuf[i], <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_VIDEO_FRAME_MAXSIZE">SCE_USBCAM_VIDEO_FRAME_MAXSIZE</a>);
   if(ret &lt; 0){
      if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
         // USB camera was disconnected
         break;
      }
      else {
         //Error handling
      }
   }

if(termination decision == true){
   <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStopVideo">sceUsbCamStopVideo</a>();
   break;
}

if (jpegsize &gt; 0) {
   //Process JPEG data that was obtained. jpegbuf[i^0x01]is target
}

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamWaitReadVideoFrameEnd">sceUsbCamWaitReadVideoFrameEnd</a>();
if(ret &lt; 0){
   if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
      // USB camera was disconnected
      break;
   }
   else {
      //Error handling
      if (ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_BUFFER_SIZE">SCE_USBCAM_ERROR_BUFFER_SIZE</a>) {
         //Only as much JPEG data that will fit in jpegbuf was stored.
      }
   }
}
   jpegsize = ret;
}

</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_4_3"><h4>
(3)&nbsp;<b>Obtaining still images</b><br></h4>
</a></div>
<div style="margin-left:67px;">Assign parameters that will be used by <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupStill">sceUsbCamSetupStill</a>().Two APIs are provided for obtaining still images. One is synchronous and the other is asynchronous.<br>Although the size of the data to be obtained can be specified by a parameter, picture quality can be given priority by specifying the compression ratio. If <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStartVideo">sceUsbCamStartVideo</a>() was previously called, be sure to call <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStopVideo">sceUsbCamStopVideo</a>() before obtaining still images. Still images cannot be obtained at the same time as videos. To obtain a still image with SXGA or XGA resolution, change the parameter for taking movies to 15fps or less.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Obtain still image (synchronous)
#define JPEG_SIZE SCE_USBCAM_MAXSIZE
static unsigned char jpegbuf[JPEG_SIZE] __attribute__((aligned(64)));
int ret;
<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamStillParam">SceUsbCamStillParam</a> param;

param.size          = sizeof(param);
param.resolution    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_RESOLUTION_VGA">SCE_USBCAM_RESOLUTION_VGA</a>;
param.target_size   = sizeof(jpegbuf);
param.flip_mirror   = 0;
param.self_timer    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_SELFTIMER_NO">SCE_USBCAM_SELFTIMER_NO</a>;
param.comp_qs       = 10;

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupStill">sceUsbCamSetupStill</a>(&amp;param);
if (ret &lt; 0){
   //Error handling
}

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStillInputBlocking">sceUsbCamStillInputBlocking</a>(stillbuf, sizeof(stillbuf));
if(ret &lt; 0){
   if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
      // USB camera was disconnected
   }
   else {
      //Error handling
      if (ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_BUFFER_SIZE">SCE_USBCAM_ERROR_BUFFER_SIZE</a>) {
         //Only as much JPEG data that will fit in stillbuf was stored.
      }
   }
}

if(ret &gt; 0){
   //JPEG data was successfully obtained. Process the data.
}

//Obtain still image (asynchronous)
#define  STILLBUF_SIZE  32*1024
unsigned char *jpegbuf;
int ret;
SceSize size = STILLBUF_SIZE+1024;
<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamStillParam">SceUsbCamStillParam</a> param;

param.size          = sizeof(param);
param.resolution    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_RESOLUTION_VGA">SCE_USBCAM_RESOLUTION_VGA</a>;
param.target_file_size   = STILLBUF_SIZE;
param.flip_mirror   = 0;
param.self_timer    = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_SELFTIMER_NO">SCE_USBCAM_SELFTIMER_NO</a>;
parma.comp_qs       = 1;

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupStill">sceUsbCamSetupStill</a>(&amp;param);
if (ret &lt; 0){
   //Error handling
   }
jpegbuf = memalign(64, size);

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStillInput">sceUsbCamStillInput</a>(jpegbuf, size);
if(ret &lt; 0){
   if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
      // USB camera was disconnected
   }
   else {
      //Error handling
   }
}
while(1){
   ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStillPollInputEnd">sceUsbCamStillPollInputEnd</a>();
   if(ret &lt; 0){
      if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
         // USB camera was disconnected
      }
      else {
         //Error handling
         if (ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_BUFFER_SIZE">SCE_USBCAM_ERROR_BUFFER_SIZE</a>) {
            //Only as much JPEG data that will fit in stillbuf was stored.
         }
      }
   }
   else if(ret &gt; 0){
      size = (SceSize)ret;
      break;
   }
   else {
      //JPEG could not be obtained yet.
   }
}
   //Process JPEG data that was obtained
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_4_4"><h4>
(4)&nbsp;<b>Obtaining audio</b><br></h4>
</a></div>
<div style="margin-left:67px;">Assign parameters and work memory that you want to use for <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupMic">sceUsbCamSetupMic</a>(). Allocate the work area with 64-byte alignment, and with a size to suit the sampling rate and the length of the acquisition interval. As a rule of thumb, the work area size is (sampling rate [Hz]*2)*(acquisition interval [sec]). Two APIs are provided for obtaining audio. One is synchronous and the other is asynchronous.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Obtain audio (synchronous)
#define SAMPLE_RATE   44100
#define MICWORK_SIZE  ((SAMPLE_RATE*2)/30) //Allocate memory for 1/30 sec worth of data
static unsigned char micwork[MICWORK_SIZE];
int ret;
unsigned char pcmbuf[MICWORK_SIZE];
<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamMicParam">SceUsbCamMicParam</a> param;
param.alc  = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_MIC_ALC_OFF">SCE_USBCAM_MIC_ALC_OFF</a>;
param.gain = 0;
param.noiz = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_MIC_NOISE_GATE_OFF">SCE_USBCAM_MIC_NOISE_GATE_OFF</a>;
param.freq = SAMPLE_RATE;

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupMic">sceUsbCamSetupMic</a>(&amp;param, micwork, MICWORK_SIZE);
if(ret &lt; 0){
   //Error handling
}

while(1){
   ret = UsbCamReadMicBlocking(pcmbuf, sizeof(pcmbuf));
   if(ret &lt; 0){
      if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
         // USB camera was disconnected
         break;
      }
      else {
         //Error handling
      }
   }
   else if( ret &gt; 0){
      //Process PCM data
   }
}

// Obtain audio (asynchronous)
#define SAMPLE_RATE   44100
#define MICWORK_SIZE  ((SAMPLE_RATE*2)/30) // Allocate memory for 1/30 sec worth of data
static unsigned char micwork[MICWORK_SIZE];
int i,ret;
SceSize size;
unsigned char pcmbuf[2][MICWORK_SIZE];
<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamMicParam">SceUsbCamMicParam</a> param;

param.size = sizeof(<a href="../peripheral/USB_Camera-Reference-English.htm#SceUsbCamMicParam">SceUsbCamMicParam</a>);
param.alc  = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_MIC_ALC_OFF">SCE_USBCAM_MIC_ALC_OFF</a>;;
param.gain = 0;
param.noiz = <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_MIC_NOISE_GATE_OFF">SCE_USBCAM_MIC_NOISE_GATE_OFF</a>;
param.freq = SAMPLE_RATE;

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupMic">sceUsbCamSetupMic</a>(&amp;param, micwork, MICWORK_SIZE);
if(ret &lt; 0){
   //Error handling
}
size = 0;
for(i=0;;i^=0x01){
   ret = UsbCamReadMic(pcmbuf[i], sizeof(pcmbuf[0]));
      if(ret &lt; 0){
         if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
            // USB camera was disconnected
            break;
         }
         else {
            //Error handling
         }
      }
      if( size &gt; 0 ){
         //Process PCM data. pcmbuf[i^0x01]is target
      }

   ret = UsbCamWaitReadMicEnd();
      if(ret &lt; 0){
         if(ret == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a>){ 
            // USB camera was disconnected
            break;
         }
         else {
            //Error handling
         }
      }
      size = (SceSize)ret;
}
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_2_5">
<h3>
<a href="#Heading3_2"> 2. </a>5 
<!-- hp1 --><b>Detecting USB Camera Reversal</b><br>
</a>
</h3>
<div style="margin-left:50px;">USB camera reversal can be detected by registering a callback. Use <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetReverseMode">sceUsbCamSetReverseMode</a>() to reverse the image up and down (flip) or reverse it right and left (mirror) according to the camera direction.<br>Although <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetReverseMode">sceUsbCamSetReverseMode</a>() can also be used while video is being obtained, care is required since the frame immediately after the one when this function is called may be corrupted.<br>If <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamAutoImageReverseSW">sceUsbCamAutoImageReverseSW</a>() is used to enable automatic reversal, the image will be reversed as necessary by the driver and hardware. Note that automatic reversal is only performed when taking video. Image reversal is triggered when the camera starts taking video, or if the camera is rotated while video is being taken.<br>If <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetReverseMode">sceUsbCamSetReverseMode</a>() is used to overwrite the setting, it will take precedence over automatic reversal, however, overwriting will be canceled by the causes described above.<br><br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Callback function
SceUID sema;
static int UsbCamRotNotifyCB(int count, int arg, void *common){
   <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSignalSema">sceKernelSignalSema</a>(sema, 1);
}

// Main thread
int ret;
SceUID cbid;
ret = <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateSema">sceKernelCreateSema</a>(&quot;CamRotSig&quot;, SCE_KERNEL_SA_THPRI, 0, 1, NULL);
if(ret &lt; 0){
   //Error handling
}
sema = (SceUID)ret;

ret = <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelCreateCallback">sceKernelCreateCallback</a>(&quot;CamRotCB&quot;, UsbCamRotNotifyCB, NULL);
if(ret &lt; 0){
   //Error handling
}
cbid = (SceUID)ret;

ret = <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamRegisterLensRotationCallback">sceUsbCamRegisterLensRotationCallback</a>(cbid);
if(ret &lt; 0){
   //Error handling
}


while(1){
   <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelWaitSema">sceKernelWaitSema</a>(sema, 1, NULL);
   if(<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamGetLensDirection">sceUsbCamGetLensDirection</a>() == <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_LENSDIRECTION_OUT">SCE_USBCAM_LENSDIRECTION_OUT</a>){
      //Lens direction is facing outward (UMD&trade; side)
   }
   else{
      //Lens direction is facing inward (display side)
   }
}
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_2_6">
<h3>
<a href="#Heading3_2"> 2. </a>6 
<!-- hp1 --><b>Deactivate USB Device</b><br>
</a>
</h3>
<div style="margin-left:50px;">When <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbDeactivate">sceUsbDeactivate</a>() is executed, the USB device is deactivated, and the power supply to the USB camera is automatically stopped. Therefore, when camera input is not to be used for a while, power consumption can be reduced by deactivating the USB device in advance.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Deactivate USB device
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbDeactivate">sceUsbDeactivate</a>() &lt; 0) {
	      // Error handling
}
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_2_7">
<h3>
<a href="#Heading3_2"> 2. </a>7 
<!-- hp1 --><b>Stop USB Drivers</b><br>
</a>
</h3>
<div style="margin-left:50px;">Execute <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStop">sceUsbStop</a>() in the following order to stop each USB driver.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Stop USB camera mic driver
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStop">sceUsbStop</a>(<a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAMMIC_NAME">SCE_USBCAMMIC_NAME</a>, 0, NULL) &lt; 0) {
	      // Error handling
}

// Stop USB camera driver
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStop">sceUsbStop</a>(<a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_NAME">SCE_USBCAM_NAME</a>, 0, NULL) &lt; 0) {
	      // Error handling
}

// Stop USB accessory base driver
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStop">sceUsbStop</a>(SCE_USBACC_NAME, 0, NULL) &lt; 0) {
	      // Error handling
}

// Stop USB bus driver
if (<a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbStop">sceUsbStop</a>(SCE_USB_BUS_DRIVER_NAME, 0, NULL) &lt; 0) {
	      // Error handling
}
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_2_8">
<h3>
<a href="#Heading3_2"> 2. </a>8 
<!-- hp1 --><b>Unload USB Drivers</b><br>
</a>
</h3>
<div style="margin-left:50px;">Refer to the sample programs to see how to unload the USB drivers.<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_3">
<h2>
 3 <!-- hp --><b>Description of Operation</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_3_1">
<h3>
<a href="#Heading3_3"> 3. </a>1 
<!-- hp1 --><b>Connection/Disconnection</b><br>
</a>
</h3>
<div style="margin-left:50px;">Although the USB Camera library can detect a disconnection, the <a href="../peripheral/USB_Driver-Reference-English.htm#sceUsbGetState">sceUsbGetState</a>() function of the USB driver should be used to detect a connection. If the USB camera is disconnected while the USB Camera library is executing, <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a> is returned from the API.<br>If the <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_NOT_AVAILABLE">SCE_USBCAM_ERROR_NOT_AVAILABLE</a> error is returned by the USB Camera library, you should take some action such as displaying a dialog prompting the user to connect the USB camera.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_2">
<h3>
<a href="#Heading3_3"> 3. </a>2 
<!-- hp1 --><b>Connecting to a USB Accessory Not Supported by the USB Camera Library</b><br>
</a>
</h3>
<div style="margin-left:50px;">If the system is connected to a USB accessory that is not supported by the USB camera library, the USB accessory will not be recognized, and the system will be in the same state as if no USB accessory were connected at all.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_3">
<h3>
<a href="#Heading3_3"> 3. </a>3 
<!-- hp1 --><b>Connecting to a USB Host Other Than a USB Accessory </b><br>
</a>
</h3>
<div style="margin-left:50px;">When the USB Camera library is used, the PSP&trade; is viewed from a USB host as a combined device with an audio class USB speaker and three vendor-specific drivers. However, it does not operate as a USB speaker in the same way as the USB mic.<br><br>Whether the PSP&trade; is connected to a USB accessory specifically for the PSP&trade; or to another USB host can be determined by using the <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbAccGetAuthStat">sceUsbAccGetAuthStat</a>() function.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_4">
<h3>
<a href="#Heading3_3"> 3. </a>4 
<!-- hp1 --><b>Size of JPEG Data That is Obtained</b><br>
</a>
</h3>
<div style="margin-left:50px;">Depending on the properties of the USB camera, it might be possible to obtain JPEG data that is larger than the data size specified in <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupVideo">sceUsbCamSetupVideo</a>() and <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupStill">sceUsbCamSetupStill</a>().<br>When the size of the JPEG data that is obtained is larger than the size that was specified in <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupVideo">sceUsbCamSetupVideo</a>() or <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupStill">sceUsbCamSetupStill</a>(), it is possible to capture the data if the capture destination buffer is larger than the data size.<br>If the capture destination buffer is smaller than the image data that was obtained, the data is stored in the buffer such that the part that doesn't fit is cut off. In this case, <a href="../peripheral/USB_Camera-Reference-English.htm#SCE_USBCAM_ERROR_BUFFER_SIZE">SCE_USBCAM_ERROR_BUFFER_SIZE</a> is returned from a function such as <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamReadVideoFrameBlocking">sceUsbCamReadVideoFrameBlocking</a>().<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_5">
<h3>
<a href="#Heading3_3"> 3. </a>5 
<!-- hp1 --><b>Counter in JPEG Data</b><br>
</a>
</h3>
<div style="margin-left:50px;">A counter that loops from 0 to 255 is placed in the 11th byte of the JPEG data that is obtained from <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamReadVideoFrame">sceUsbCamReadVideoFrame</a>() or <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamReadVideoFrameBlocking">sceUsbCamReadVideoFrameBlocking</a>(). The counter is repeatedly incremented by 1 for each frame and returned to 0 when it reaches 255. The counter is designed to be used for detecting dropped frames.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_6">
<h3>
<a href="#Heading3_3"> 3. </a>6 
<!-- hp1 --><b>Changing Parameters While Obtaining Video</b><br>
</a>
</h3>
<div style="margin-left:50px;">By calling an API, it is possible to change image settings while processing is executing for obtaining video, however, care should be taken since the JPEG data immediately following the data at which the API is called may be corrupted.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_7">
<h3>
<a href="#Heading3_3"> 3. </a>7 
<!-- hp1 --><b>Acquiring Still Images</b><br>
</a>
</h3>
<div style="margin-left:50px;">A still image cannot be acquired while video is being obtained. Be sure to use <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStopVideo">sceUsbCamStopVideo</a>() to stop obtaining video before calling a function such as <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStillInput">sceUsbCamStillInput</a>(). Also, note that while a still image is being acquired, you cannot start obtaining video.<br>Note that when photographing still images, if a resolution is specified that has a different aspect ratio from the aspect ratio that was in effect when taking video, the photographic range will be changed.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_8">
<h3>
<a href="#Heading3_3"> 3. </a>8 
<!-- hp1 --><b>Parameters When Acquiring Still Images</b><br>
</a>
</h3>
<div style="margin-left:50px;">Parameters for brightness, saturation, contrast, sharpness, and zoom cannot be set by using <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupStill">sceUsbCamSetupStill</a>(). Be sure to call an API that sets these parameters before calling <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamStillInput">sceUsbCamStillInput</a>(). These settings are assumed to be dynamically selected when video is obtained.<br>To obtain a still image with a size of XGA or SXGA, set the frame rate for taking movies to 15fps or less.<br>The frame rate is related to various factors such as the sensor gain, shutter speed, exposure, and compression speed. Although these factors are common for both video and still image photography, they can only be set at the start of video photography. When photographing at XGA or SXGA resolution with a frame rate is 30 fps, there are restrictions on these settings, otherwise the upper limit on the hardware's performance would end up being exceeded.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_9">
<h3>
<a href="#Heading3_3"> 3. </a>9 
<!-- hp1 --><b>Detecting Camera Reversal</b><br>
</a>
</h3>
<div style="margin-left:50px;">If a callback is registered, the detection of camera reversal is reported to the callback when reversal is detected. The application being used is responsible for determining whether to reverse the acquired image.<br>If reversal is not set by <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamAutoImageReverseSW">sceUsbCamAutoImageReverseSW</a>(), the image will not be reversed by the library.<br>If automatic reversal is set by using <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamAutoImageReverseSW">sceUsbCamAutoImageReverseSW</a>(), then the library and USB camera perform mirror (left and right) reversal when your own side is being photographed or flip (up and down) and mirror (left and right) reversal when the destination side is being photographed.<br>If <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamGetLensDirection">sceUsbCamGetLensDirection</a>() is called to find out the camera direction immediately after the USB camera enters a Configured state, the library may not have finished acquiring the camera state. In this case, the API should be called again after a while.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_10">
<h3>
<a href="#Heading3_3"> 3. </a>10 
<!-- hp1 --><b>Exposure</b><br>
</a>
</h3>
<div style="margin-left:50px;">The USB camera autonomously determines the exposure based on the f-stop of the camera lens (f=2.8) and the ISO speed that is specified by <a href="../peripheral/USB_Camera-Reference-English.htm#sceUsbCamSetupVideo">sceUsbCamSetupVideo</a>(). This operation  tends to produce an image that is darker than the subject's appearance when the subject is white (bright) and brighter than the subject's appearance when the subject is black (dark).<br>If the EV value is increased when the subject is white or decreased when the subject is black, an image that is closer to the subject's appearance can be obtained.<br>The exposure is measured when a moving image is photographed. As a result, if no moving image is photographed at all so that no image is obtained, the correct exposure will not be reflected. Although independent still images can be photographed continuously, their exposure will be determined from the last time that moving images were photographed. If the light intensity on the subject changed during that time, a suitable exposure will not be obtained unless moving images are photographed.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_11">
<h3>
<a href="#Heading3_3"> 3. </a>11 
<!-- hp1 --><b>Zoom Function</b><br>
</a>
</h3>
<div style="margin-left:50px;">An image can be zoomed up to 8.0 times using digital zoom, however, the maximum magnification varies according to the photographed resolution and frame rate. The maximum magnification as a function of the frame rate and resolution is shown below.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>QQVGA</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>QCIF</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>QVGA</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>CIF</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>VGA</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>XGA</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>SXGA</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>PSP1</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>PSP2</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Less than or equal to 15fps&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;8.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;6.6&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;4.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;3.3&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;2.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1.3&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;2.8&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;3.6&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Greater than 15fps&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;4.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;3.3&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;2.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1.7&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1.0&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1.4&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1.8&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>
<div style="margin-left:50px;">Although the zoom magnification is common for moving images and still images, when a still image is obtained by specifying a higher resolution than that for a moving image, the zoom magnification may be reduced in accordance with the limit of the (higher) still image resolution. In other words, the photographic range for still images may be wider than that for moving images.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_12">
<h3>
<a href="#Heading3_3"> 3. </a>12 
<!-- hp1 --><b>USB Bandwidth Limit</b><br>
</a>
</h3>
<div style="margin-left:50px;">The maximum bandwidth allocated for video transfer when shooting video is 896 kBytes/sec and the maximum size per video frame is (896/frame rate) kBytes. If a larger frame size is specified, it may not be possible to maintain the specified frame rate.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_13">
<h3>
<a href="#Heading3_3"> 3. </a>13 
<!-- hp1 --><b>Automatic Detection of Flicker</b><br>
</a>
</h3>
<div style="margin-left:50px;">The camera performs a correction when automatic flicker detection is specified, however, when the frame rate is set to 3.75 fps or 60 fps, flicker will occur if there isn't enough light in the vicinity of the photographic subject.<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_4">
<h2>
 4 <!-- hp --><b>Precautions</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_4_1">
<h3>
<a href="#Heading3_4"> 4. </a>1 
<!-- hp1 --><b>USB Mic Library </b><br>
</a>
</h3>
<div style="margin-left:50px;">Although the USB camera hardware itself can be used in a similar manner as the USB mic hardware by using the USB Mic library, care should be taken since the USB Mic library cannot be used at the same time as the USB Camera library. <br></div>
<p><p><hr>
<div ALIGN="right">
    &copy;2009 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
