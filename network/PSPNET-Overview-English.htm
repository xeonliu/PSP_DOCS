<html lang="en">
<head>
<title>PSPNET-Overview</title>
<meta http-equiv="Content-Type" content= text/html; charset=iso-8859-1>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&trade; Programmer Tool Runtime Library Release 6.3.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
pspnet Overview
</h1></center>
</a>
<!-- sce_hd1 -->

<!-- sce_hd3 -->
<a name="Heading3_1">
<h2>
 1 <!-- hp --><b>Library Overview</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_1_1">
<h3>
<a href="#Heading3_1"> 1. </a>1 
<!-- hp1 --><b>Overview</b><br>
</a>
</h3>
<div style="margin-left:50px;">Built into every PSP&trade; is an IEEE 802.11 wireless LAN device. A group of network libraries is provided to support the use of this device. This group of network libraries is collectively referred to as PSPNET.<br>PSPNET is constructed out of multiple modules with the pspnet module as a base. PSPNET provides protocol stacks and APIs as well as network connectivity functions.<br>The wireless LAN device supports two operating modes, and PSPNET provides an independent protocol stack for each operating mode, as shown below.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Wireless LAN </b>&nbsp;&nbsp;<br>&nbsp;&nbsp;<b>Device</b>&nbsp;&nbsp;<br>&nbsp;&nbsp;<b>Operating Mode</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Protocol Stack</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>API</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Network</b>&nbsp;&nbsp;<br>&nbsp;&nbsp;<b>Connectivity</b>&nbsp;&nbsp;<br>&nbsp;&nbsp;<b>Functions</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Infrastructure&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;TCP/IP&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;BSD socket API&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;DHCP&nbsp;&nbsp;<br>&nbsp;&nbsp;PPPoE&nbsp;&nbsp;<br>&nbsp;&nbsp;Manual&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Ad hoc&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Dedicated (ad hoc&nbsp;&nbsp;<br>&nbsp;&nbsp;mode communication&nbsp;&nbsp;<br>&nbsp;&nbsp;protocol)&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;Ad hoc socket API&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;—&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_1_2">
<h3>
<a href="#Heading3_1"> 1. </a>2 
<!-- hp1 --><b>Related Files</b><br>
</a>
</h3>
<div style="margin-left:50px;">The following files are required to use the TCP/IP protocol.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Category</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Filename</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Header file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;pspnet.h&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_error.h&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_inet.h&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_apctl.h&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_ap_dialog_dummy.h (during development)&nbsp;&nbsp;<br>&nbsp;&nbsp;utility_module.h&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Module file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;pspnet_ap_dialog_dummy.prx (during development)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Stub library file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;pspnet_stub.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_inet_stub.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_apctl_stub.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_ap_dialog_dummy_stub.a&nbsp;&nbsp;<br>&nbsp;&nbsp;utility_stub.a&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Weak import&nbsp;&nbsp;<br>&nbsp;&nbsp;stub library file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;pspnet_stub_weak.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_inet_stub_weak.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_apctl_stub_weak.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_ap_dialog_dummy_stub_weak.a&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>
<div style="margin-left:50px;">The following files are required to use the dedicated ad hoc mode protocol.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Category</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Filename</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Header file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;pspnet.h&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_error.h&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_adhoc.h&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_adhocctl.h&nbsp;&nbsp;<br>&nbsp;&nbsp;utility_module.h&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Module file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;pspnet_stub.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_adhoc_stub.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_adhocctl_stub.a&nbsp;&nbsp;<br>&nbsp;&nbsp;utility_stub.a&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Weak import&nbsp;&nbsp;<br>&nbsp;&nbsp;stub library file&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;pspnet_stub_weak.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_adhoc_stub_weak.a&nbsp;&nbsp;<br>&nbsp;&nbsp;pspnet_adhocctl_stub_weak.a&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>
<div style="margin-left:50px;">The following modules are also provided to support development outside of the libraries.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Item</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Filename</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Program for displaying the result from scanning a&nbsp;&nbsp;<br>&nbsp;&nbsp;neighboring IBSS.&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;scan.prx&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Program for displaying the MAC address of a &nbsp;&nbsp;<br>&nbsp;&nbsp;WLAN interface.&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;show_macaddr.prx&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;Ad hoc ID check tool&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;adhoc_id_check.prx&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- sce_hd3 -->
<a name="Heading3_2">
<h2>
 2 <!-- hp --><b>Usage Overview</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_2_1">
<h3>
<a href="#Heading3_2"> 2. </a>1 
<!-- hp1 --><b>Loading and Unloading Modules</b><br>
</a>
</h3>
<div style="margin-left:50px;">Loading and unloading network modules is done using the module utility. The network modules are divided into module sets for each functional block and each module set is loaded and unloaded individually.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1_1"><h4>
(1)&nbsp;<b>The load process</b><br></h4>
</a></div>
        <div style="margin-left:80px;"><pre><font size=3>
// Load PSPNET common module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityLoadModule">sceUtilityLoadModule</a>(SCE_UTILITY_MODULE_NET_COMMON);
if (ret &lt; 0) {
	// Error handling
}

</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_1_2"><h4>
(2)&nbsp;<b>The unload process</b><br></h4>
</a></div>
        <div style="margin-left:80px;"><pre><font size=3>
// Unload PSPNET common module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityUnloadModule">sceUtilityUnloadModule</a>(SCE_UTILITY_MODULE_NET_COMMON);
if (ret &lt; 0) {
	// Error handling
}

</font></pre></div>
<div style="margin-left:50px;">For details on the module utility, see the Utility documentation.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_2_2">
<h3>
<a href="#Heading3_2"> 2. </a>2 
<!-- hp1 --><b>When Using TCP/IP Protocol</b><br>
</a>
</h3>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2_1"><h4>
(1)&nbsp;<b>The module load process</b><br></h4>
</a></div>
<div style="margin-left:67px;">This loads the module set required for using the TCP/IP protocol.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Load PSPNET common module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityLoadModule">sceUtilityLoadModule</a>(SCE_UTILITY_MODULE_NET_COMMON);
if (ret &lt; 0) {
	// Error handling
}
// Load PSPNET infrastructure module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityLoadModule">sceUtilityLoadModule</a>(SCE_UTILITY_MODULE_NET_INET);
if (ret &lt; 0) {
	// Error handling
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2_2"><h4>
(2)&nbsp;<b>Initialization</b><br></h4>
</a></div>
<div style="margin-left:67px;">Call the initialization function for each module.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
// Initialize pspnet module
ret = <a href="../network/PSPNET_Core-Reference-English.htm#sceNetInit">sceNetInit</a>(PSPNET_POOLSIZE, CALLOUT_SPL, 0, NETINTR_SPL, 0);
if(ret &lt; 0){
	// Error handling
}

// Initialize pspnet_inet module
ret = <a href="../network/PSPNET_Inet-Reference-English.htm#sceNetInetInit">sceNetInetInit</a>();
if(ret &lt; 0){
	// Error handling
}

// Initialize pspnet_apctl module
ret = <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlInit">sceNetApctlInit</a>(SCE_APCTL_STACKSIZE, SCE_APCTL_PRIO);
if(ret &lt; 0){
	// Error handling
}

// Initialize pspnet_ap_dialog_dummy dialog dummy module 
ret = <a href="../network/PSPNET_Ap_Dialog_Dummy-Reference-English.htm#sceNetApDialogDummyInit">sceNetApDialogDummyInit</a>();
if(ret &lt; 0){
	// Error handling
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2_3"><h4>
(3)&nbsp;<b>Connecting to the network</b><br></h4>
</a></div>
<div style="margin-left:67px;">After performing initialization, connect to the network. The following shows how to use the dummy dialog module to connect to the network.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
// Call connection function
// Specify SSID by using connection parameter ap_dialog_dummy_param
ret = <a href="../network/PSPNET_Ap_Dialog_Dummy-Reference-English.htm#sceNetApDialogDummyConnect">sceNetApDialogDummyConnect</a>(&amp;ap_dialog_dummy_param);
if(ret &lt; 0){
	// Error handling
}

while(1){
	// Poll connection status
	ret = <a href="../network/PSPNET_Ap_Dialog_Dummy-Reference-English.htm#sceNetApDialogDummyGetState">sceNetApDialogDummyGetState</a>(&amp;ap_dialog_dummy_state);
	if(ret == 0){
		// If connected or disconnected state, exit loop
		if(ap_dialog_dummy_state.state
			== <a href="../network/PSPNET_Ap_Dialog_Dummy-Reference-English.htm#SceNetApDialogDummyState_Connected">SceNetApDialogDummyState_Connected</a>
		||
		ap_dialog_dummy_state.state
			== <a href="../network/PSPNET_Ap_Dialog_Dummy-Reference-English.htm#SceNetApDialogDummyState_Disconnected">SceNetApDialogDummyState_Disconnected</a>)
				break;
	}
	// Sleep for polling interval
	<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>(1*1000*1000);
}
// If loop was exited because of disconnected state, perform error handling
if(ap_dialog_dummy_state.state
	== <a href="../network/PSPNET_Ap_Dialog_Dummy-Reference-English.htm#SceNetApDialogDummyState_Disconnected">SceNetApDialogDummyState_Disconnected</a>){
	// Error handling
}
// Connection completed
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2_4"><h4>
(4)&nbsp;<b>Communication by the application</b><br></h4>
</a></div>
<div style="margin-left:67px;">Use the BSD socket APIs to perform communication. The BSD socket APIs are also used in Unix. For details about the BSD socket APIs, refer to the reference documentation.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2_5"><h4>
(5)&nbsp;<b>Scanning</b><br></h4>
</a></div>
<div style="margin-left:67px;">In infrastructure mode, you can perform a scan to search for nearby access points. You can select an access point to connect to or save it in a network configuration based on the results of the scan.<br><br>A scan can be executed at any time. However, since communication is blocked during a scan, if scans are performed indiscriminately, libraries and utilities that manage the network, as well as application communication, will not work properly. If you need to call scan functions repetitively, be sure to call them as infrequently as possible.<br><br>A scan request is issued by the <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlScanSSID2">sceNetApctlScanSSID2</a>() function. This function reports the scan request to the internal thread and returns immediately without blocking.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>int <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlScanSSID2">sceNetApctlScanSSID2</a>(const char *ssid);
</font></pre></div>
<div style="margin-left:67px;"><br>When the internal thread receives the scan request, it executes scanning in the state in effect at that time. When scanning has completed, the internal thread transitions to the same state together with an <a href="../network/PSPNET_Apctl-Reference-English.htm#SCE_NET_APCTL_EVENT_SCAN2">SCE_NET_APCTL_EVENT_SCAN2</a> event. Note that a transition to Scanning state or an <a href="../network/PSPNET_Apctl-Reference-English.htm#SCE_NET_APCTL_EVENT_SCAN_COMPLETED">SCE_NET_APCTL_EVENT_SCAN_COMPLETED</a> or <a href="../network/PSPNET_Apctl-Reference-English.htm#SCE_NET_APCTL_EVENT_ERROR">SCE_NET_APCTL_EVENT_ERROR</a> event is not visible because these states and events are for internal use.<br>After a scan request, an application must wait for a state transition which accompanies an <a href="../network/PSPNET_Apctl-Reference-English.htm#SCE_NET_APCTL_EVENT_SCAN2">SCE_NET_APCTL_EVENT_SCAN2</a> event. If an error occurred during the scan, an error code is returned together with an <a href="../network/PSPNET_Apctl-Reference-English.htm#SCE_NET_APCTL_EVENT_SCAN2">SCE_NET_APCTL_EVENT_SCAN2</a> event.<br><br>The result of the scan is represented as a list of BSS descriptors, where one BSS descriptor corresponds to one access point. The number of BSS descriptors in the list varies depending on the number of access points that were detected.<br><br>The scan result is maintained by pspnet_apctl. To receive the scan result and obtain the number of BSS descriptors and the list of IDs, use the <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlGetBSSDescIDList2">sceNetApctlGetBSSDescIDList2</a>() function.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>int <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlGetBSSDescIDList2">sceNetApctlGetBSSDescIDList2</a>(int *buflen, struct <a href="../network/PSPNET_Apctl-Reference-English.htm#SceNetApctlBSSDescID">SceNetApctlBSSDescID</a> *buf);
</font></pre></div>
<div style="margin-left:67px;"><br>Sample code for performing a scan and getting a scan result list is shown below.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>void
scan(
    void
)
{
    int ret = 0, buflen;
    struct <a href="../network/PSPNET_Apctl-Reference-English.htm#SceNetApctlBSSDescID">SceNetApctlBSSDescID</a> *bssdesc;

    /* Execute scan */
    ret = <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlScanSSID2">sceNetApctlScanSSID2</a>(NULL);
    if(ret &lt; 0){
       /* Error handling */
    }

    /* Wait for scan completion event */

    /* Get size of scan result */
    ret = <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlGetBSSDescIDList2">sceNetApctlGetBSSDescIDList2</a>(&amp;buflen, NULL);
    if(ret &lt; 0){
       /* Error handling */
    }

    /* Allocate memory with a size of buflen and store a pointer to it in bssdesc */
    ...

    /* Get the BSS descriptor ID list */
    ret = <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlGetBSSDescIDList2">sceNetApctlGetBSSDescIDList2</a>(&amp;buflen, bssdesc);
    if(ret &lt; 0){
       /* Error handling */
    }

    /* Keep as a list with bssdesc at the beginning */
}

</font></pre></div>
<div style="margin-left:67px;">After getting the list of BSS descriptor IDs, you can get individual items from a given BSS descriptor by using the <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlGetBSSDescEntry2">sceNetApctlGetBSSDescEntry2</a>() function.<br>Sample code for getting the BSSID from a BSS descriptor is shown below.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>int
get_ssid_from_bssdesc(
    int bssdesc_id,
    char *bssid
    )
{
    int ret;
    union <a href="../network/PSPNET_Apctl-Reference-English.htm#SceNetApctlBSSDescEntry">SceNetApctlBSSDescEntry</a> bssdesc;

    ret = <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlGetBSSDescEntry2">sceNetApctlGetBSSDescEntry2</a>(bssdesc_id,
        <a href="../network/PSPNET_Apctl-Reference-English.htm#SCE_NET_APCTL_BSSDESC_BSSID">SCE_NET_APCTL_BSSDESC_BSSID</a>, &amp;bssdesc);
    if(ret &lt; 0){
       /* Error handling */
    }

    memcpy(bssid, bssdesc.bssid, sizeof(bssdesc.bssid));

    return ret;
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2_6"><h4>
(6)&nbsp;<b>Disconnecting from the network </b><br></h4>
</a></div>
<div style="margin-left:67px;">After communication is completed, disconnect from the network. Use <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlDisconnect">sceNetApctlDisconnect</a>() to disconnect from the network.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
// Call disconnection function
disconnected = 0;
ret = <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlDisconnect">sceNetApctlDisconnect</a>();
if(ret &lt; 0){
	// Error handling
}

// Wait for disconnection to be completed
// Wait for the event handler to receive a DISCONNECT event and set disconnected to 1
while(disconnected == 0){
	// Sleep for polling interval
	<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>(1*1000*1000);
}
// Disconnection completed
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2_7"><h4>
(7)&nbsp;<b>Termination</b><br></h4>
</a></div>
<div style="margin-left:67px;">Call the termination function for each module. At the same time, verify that no threads are calling the APIs of any of the modules.<br></div>
<div style="margin-left:80px;"><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Terminate the pspnet_ap_dialog_dummy dialog dummy module
<a href="../network/PSPNET_Ap_Dialog_Dummy-Reference-English.htm#sceNetApDialogDummyTerm">sceNetApDialogDummyTerm</a>();
// Delete the event handler registered in pspnet_apctl module
if(0 &lt;= handler_id)
	<a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlDelHandler">sceNetApctlDelHandler</a>(handler_id);
// Terminate the pspnet_apctl module
<a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlTerm">sceNetApctlTerm</a>();
// Terminate the pspnet_inet module
<a href="../network/PSPNET_Inet-Reference-English.htm#sceNetInetTerm">sceNetInetTerm</a>();
// Terminate the pspnet module
<a href="../network/PSPNET_Core-Reference-English.htm#sceNetTerm">sceNetTerm</a>();
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_2_8"><h4>
(8)&nbsp;<b>The module-unload process</b><br></h4>
</a></div>
<div style="margin-left:67px;">This unloads the module set.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Unload PSPNET infrastructure module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityUnloadModule">sceUtilityUnloadModule</a>(SCE_UTILITY_MODULE_NET_INET);
if (ret &lt; 0) {
	// Error handling
}
// Unload PSPNET common module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityUnloadModule">sceUtilityUnloadModule</a>(SCE_UTILITY_MODULE_NET_COMMON);
if (ret &lt; 0) {
	// Error handling
}
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_2_3">
<h3>
<a href="#Heading3_2"> 2. </a>3 
<!-- hp1 --><b>Using the Ad hoc Mode Communication Protocol</b><br>
</a>
</h3>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3_1"><h4>
(1)&nbsp;<b>The module-load process</b><br></h4>
</a></div>
<div style="margin-left:67px;">This loads the module set required for using the ad hoc mode communication protocol.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Load PSPNET common module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityLoadModule">sceUtilityLoadModule</a>(SCE_UTILITY_MODULE_NET_COMMON);
if (ret &lt; 0) {
	// Error handling
}
// Load PSPNET ad hoc module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityLoadModule">sceUtilityLoadModule</a>(SCE_UTILITY_MODULE_NET_ADHOC);
if (ret &lt; 0) {
	// Error handling
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3_2"><h4>
(2)&nbsp;<b>Initialization</b><br></h4>
</a></div>
<div style="margin-left:67px;">Call the initialization function for each module.<br></div>
<div style="margin-left:80px;"><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Initialize pspnet module
ret = <a href="../network/PSPNET_Core-Reference-English.htm#sceNetInit">sceNetInit</a>(PSPNET_POOLSIZE, CALLOUT_TPL, 0, NETINTR_TPL, 0);
if (ret &lt; 0) {
	// Error handling
}

// Initialize pspnet_adhoc module
ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocInit">sceNetAdhocInit</a>();
if (ret &lt; 0) {
	// Error handling
}

// Initialize pspnet_adhocctl module
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlInit">sceNetAdhocctlInit</a>(ADHOCCTL_STACKSIZE, ADHOCCTL_TPL, &amp;adhoc_id);
if (ret &lt; 0) {
	// Error handling
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3_3"><h4>
(3)&nbsp;<b>Registering an event handler</b><br></h4>
</a></div>
<div style="margin-left:67px;">Register an event handler for receiving event notifications from pspnet_adhocctl related to the network connection. pspnet_adhocctl.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
// Register pspnet_adhocctl event handler
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlAddHandler">sceNetAdhocctlAddHandler</a>(adhocctl_handler, NULL);
if (ret &lt; 0) {
	// Error handling
}
// Save handler ID
handlerId = ret;

</font></pre></div>
<div style="margin-left:67px;">The following is a sample event handler.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int error_code = 0;	// Location for storing error code
int evf = 0;		// Event flags

void
adhocctl_handler(int event, int error, void *arg)
{
	if (event == <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_ERROR">SCE_NET_ADHOCCTL_EVENT_ERROR</a>) {
		error_code = error;
		evf |= EVF_ERROR;
	}	
	else if (event == <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_CONNECT">SCE_NET_ADHOCCTL_EVENT_CONNECT</a>) {
		error_code = 0;
		evf |= EVF_CONNECT;
	}
	else if (event == <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_DISCONNECT">SCE_NET_ADHOCCTL_EVENT_DISCONNECT</a>) {
		error_code = 0;
		evf |= EVF_DISCONNECT;
	}
	else if (event == <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_SCAN">SCE_NET_ADHOCCTL_EVENT_SCAN</a>) {
		error_code = 0;
		evf |= EVF_SCAN;
	}
	
		return;
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3_4"><h4>
(4)&nbsp;<b>Processing ad hoc network connection </b><br></h4>
</a></div>

<!-- sce_hd6 -->
<a name="Heading6_2_3_4_1">
<div style="margin-left:63px;"><h4><b>When Using sceNetAdhocctlConnect()</b><br><br></h4></a></div>
<div style="margin-left:80px;"><a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlConnect">sceNetAdhocctlConnect</a>() enables a title application to connect to an IBSS without being concerned with creating or joining an IBSS.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Set group name (set to "test")
memset(&amp;group_name, 0, sizeof(struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlGroupName">SceNetAdhocctlGroupName</a>));
memcpy(&amp;group_name.data, &quot;test&quot;, sizeof(&quot;test&quot;));
// Call connection function
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlConnect">sceNetAdhocctlConnect</a>(&amp;group_name);
if (ret &lt; 0) {
	// Error handling
}
// Poll connection status
while (1) {
	// If connected state, exit from loop
	if (evf &amp; EVF_CONNECT) {
		break;
	}
	// Go to error handling
	if (evf &amp; EVF_ERROR) {
		// Error handling
	}
	
	// Sleep during the polling interval
	<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>(1*1000*1000);
}
// Connection completed
</font></pre></div>
<div style="margin-left:67px;"><br></div>
<div style="margin-left:80px;">To reconnect after an error, start again from <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlConnect">sceNetAdhocctlConnect</a>().<br></div>

<!-- sce_hd6 -->
<a name="Heading6_2_3_4_2">
<div style="margin-left:63px;"><h4><b>When Using a Combination of sceNetAdhocctlCreate() and sceNetAdhocctlJoin()</b><br><br></h4></a></div>
<div style="margin-left:80px;">After one peer uses <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlCreate">sceNetAdhocctlCreate</a>() to create an IBSS, another peer uses <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>() to join it.<br><br></div>
<div style="margin-left:40px;"><ul>
<li> For peer using <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlCreate">sceNetAdhocctlCreate</a>()
</ul></div>
<div style="margin-left:80px;">Specify a group name when creating an IBSS.<br></div>
<div style="margin-left:67px;"><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Set group name (set to "test")
memset(&amp;group_name, 0, sizeof(struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlGroupName">SceNetAdhocctlGroupName</a>));
memcpy(&amp;group_name.data, "test", sizeof("test"));
// Call IBSS creation function
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlCreate">sceNetAdhocctlCreate</a>(&amp;group_name);
if (ret &lt; 0) {
	// Error handling
}
// Poll connection status
while (1) {
	// Exit from loop if connection complete
	if (evf &amp; EVF_CONNECT) {
		break;
	}
	// Go to error handling
	if (evf &amp; EVF_ERROR) {
		// Error handling
	}
	
	// Sleep for polling interval 
	<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>(1*1000*1000);
}
// Connection complete

</font></pre></div>
<div style="margin-left:40px;"><ul>
<li> For peer using <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>()
</ul></div>
<div style="margin-left:80px;">Before calling <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>(), perform <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlScan">sceNetAdhocctlScan</a>() to detect the IBSS with the group name to which you want to connect.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int ret, buflen;
struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlScanInfo">SceNetAdhocctlScanInfo</a> *buf, *ptr;
struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlGroupName">SceNetAdhocctlGroupName</a> group_name;

// Scan the IBSS of group name "test" 
memset(&amp;group_name, 0x00, sizeof(group_name));
memcpy(group_name.data, "test", sizeof("test"));

// Scan Processing
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlScan">sceNetAdhocctlScan</a>();
if (ret &lt; 0) {
	// Error handling
}
// Poll scan status
while (1) {
	// If scan complete, exit the loop
	if (evf &amp; EVF_SCAN) {
		break;
	}
	// Go to Error processing
	if (evf &amp; EVF_ERROR) {
		// Error processing
	}
	
	//Sleep for polling interval
	<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>(1*1000*1000);
}
// Get the buffer size of the scan results
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetScanInfo">sceNetAdhocctlGetScanInfo</a>(&amp;buflen, NULL);
if (ret &lt; 0) {
	// Go to error handling
}
if (buflen == 0) {
	// Go to processing when scan result is 0
}

buf = (struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlScanInfo">SceNetAdhocctlScanInfo</a> *)malloc(buflen);
if (buf == NULL ) {
	// Go to error handling
}

// Get actual scan results
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetScanInfo">sceNetAdhocctlGetScanInfo</a>(&amp;buflen, buf);
if (ret &lt; 0) {
	// Go to error handling
}
for (ptr=buf; ptr!=NULL; ptr=ptr-&gt;next) {
	// Process list 
	// Specify group name to connect to the same IBSS.
	if (memcmp(&amp;ptr-&gt;group_name, &amp;group_name, sizeof(group_name)) == 0)
		break;
}

if (ptr == NULL)
	// Target IBSS was not found, so go to termination processing

// If the target SSID was found in the scan result list, then join the IBSS.
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>(ptr);
if (ret &lt; 0) {
	// Error handling
}
// Poll connection status
while (1) {
	// Exit from loop if connection complete
	if (evf &amp; EVF_CONNECT) {
		break;
	}
	// Go to error handling
	if (evf &amp; EVF_ERROR) {
		// Error handling
	}
	
	// Sleep for polling interval 
	<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>(1*1000*1000);
}
// Connection complete
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3_5"><h4>
(5)&nbsp;<b>Communication by Application</b><br></h4>
</a></div>
<div style="margin-left:67px;">Use ad hoc socket APIs for communication.<br>During this time, monitor the event handler for event notification periodically.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
// User program main loop
while (1) {
	…

	if (evf &amp; EVF_ERROR) {
		// Error handling
	}

	…
}
</font></pre></div>
<div style="margin-left:67px;"><br>If an error occurs, reconnect by restarting from the <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlConnect">sceNetAdhocctlConnect</a>() or <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlCreate">sceNetAdhocctlCreate</a>/Join() function.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3_6"><h4>
(6)&nbsp;<b>Disconnection from ad hoc network</b><br></h4>
</a></div>
<div style="margin-left:67px;">Disconnect from the network after communication is completed.<br></div>
<div style="margin-left:80px;"><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Call disconnect function
ret = <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlDisconnect">sceNetAdhocctlDisconnect</a>();
if (ret &lt; 0) {
	// Error handling
}

// Poll connection status
while (1) {
	// Exit from loop when disconnect complete
	if (evf &amp; EVF_DISCONNECT) {
		break;
	}
	
	// Sleep during polling interval
	<a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelDelayThread">sceKernelDelayThread</a>(1*1000*1000);
}
// Disconnect complete
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3_7"><h4>
(7)&nbsp;<b>Termination processing</b><br></h4>
</a></div>
<div style="margin-left:67px;">Call the termination function for each module. At the same time, confirm that no threads are calling the APIs of any of the modules.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Delete the pspnet_adhocctl event handler
<a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlDelHandler">sceNetAdhocctlDelHandler</a>(handlerId);
// Terminate the pspnet_adhocctl module
<a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlTerm">sceNetAdhocctlTerm</a>();
// Terminate the pspnet_adhoc module
<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocTerm">sceNetAdhocTerm</a>();
// Terminate the pspnet module
<a href="../network/PSPNET_Core-Reference-English.htm#sceNetTerm">sceNetTerm</a>();
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_3_8"><h4>
(8)&nbsp;<b>The module unload process</b><br></h4>
</a></div>
<div style="margin-left:67px;">This unloads the module set.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>// Unload PSPNET ad hoc module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityUnloadModule">sceUtilityUnloadModule</a>(SCE_UTILITY_MODULE_NET_ADHOC);
if (ret &lt; 0) {
	// Error handling
}
// Unload PSPNET common module set
ret = <a href="../utility/Utility-Reference-English.htm#sceUtilityUnloadModule">sceUtilityUnloadModule</a>(SCE_UTILITY_MODULE_NET_COMMON);
if (ret &lt; 0) {
	// Error handling
}
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_2_4">
<h3>
<a href="#Heading3_2"> 2. </a>4 
<!-- hp1 --><b>Ad hoc Socket API Sample Code</b><br>
</a>
</h3>
<div style="margin-left:50px;">This section gives sample code for showing how to use the socket APIs with the PDP and PTP ad hoc mode communication protocols.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_4_1"><h4>
(1)&nbsp;<b>Sample code that uses PDP to echo back data ("/usr/local/psp/devkit/sample/net/adhoc/pdp_echo")</b><br></h4>
</a></div>
<div style="margin-left:67px;">echo_server_func() receives data over a PDP socket and echoes it back to the sender.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>static void
echo_server_func(
	void
	)
{
	int ret, len;
	int id = 0;
	struct <a href="../network/PSPNET_Core-Reference-English.htm#SceNetEtherAddr">SceNetEtherAddr</a> server_addr, client_addr;
	<a href="../kernel/Types-Reference-English.htm#SceUShort16">SceUShort16</a> client_port;
	char etherstr[18];
	char server_buf[SERVER_BUFSIZE];

	// Get local MAC address
	ret = <a href="../network/PSPNET_Core-Reference-English.htm#sceNetGetLocalEtherAddr">sceNetGetLocalEtherAddr</a>(&amp;server_addr);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Core-Reference-English.htm#sceNetGetLocalEtherAddr">sceNetGetLocalEtherAddr</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}

	// Create PDP socket
	// Specify local address and port number
	ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPdpCreate">sceNetAdhocPdpCreate</a>(&amp;server_addr, SERVER_PORT, SERVER_BUFSIZE, 0);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPdpCreate">sceNetAdhocPdpCreate</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}
	// Save socket ID in id
	id = ret;

	<a href="../network/PSPNET_Core-Reference-English.htm#sceNetEtherNtostr">sceNetEtherNtostr</a>(&amp;server_addr, etherstr);
	printf("server started at addr %s, port %d.\n", etherstr, SERVER_PORT);

	while (1) {
		// Store buffer size in len
		len = SERVER_BUFSIZE;
		// Receive data
		ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPdpRecv">sceNetAdhocPdpRecv</a>(id, &amp;client_addr, &amp;client_port,
				server_buf, &amp;len, 0, 0);
		if (ret &lt; 0) {
			printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPdpRecv">sceNetAdhocPdpRecv</a>() failed. ret = 0x%x\n", ret);
			break;
		}
		// Source address and port number of sender are returned in
		// client_addr and client_port, and receive data size is returned
		// in len
		<a href="../network/PSPNET_Core-Reference-English.htm#sceNetEtherNtostr">sceNetEtherNtostr</a>(&amp;client_addr, client);
		printf("Received from %s, port %d, len = %d\n",
			client, client_port, len);
		// Echo received data back to sender
		ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPdpSend">sceNetAdhocPdpSend</a>(id, &amp;client_addr, client_port,
			server_buf, len, 0, 0);
		if (ret &lt; 0) {
			printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPdpSend">sceNetAdhocPdpSend</a>() failed. ret = 0x%x\n", ret);
			break;
		}
	}

bad:
	if (id &gt; 0) 
		// Delete socket
		<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPdpDelete">sceNetAdhocPdpDelete</a>(id, 0);

	printf("echo server terminated.\n");
}
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_2_4_2"><h4>
(2)&nbsp;<b>Sample code that uses PTP to get a file ("/usr/local/psp/devkit/sample/net/adhoc/ptp_ftp")</b><br></h4>
</a></div>

<!-- sce_hd6 -->
<a name="Heading6_2_4_2_1">
<div style="margin-left:63px;"><h4><b>Server (sending side)</b><br><br></h4></a></div>
<div style="margin-left:80px;">server_func() waits for a PTP connection to be established then sends data from a file over the connection.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>static void
server_func(
	void
	)
{
	int ret, len;
	int fd = 0, id0 = 0, id = 0;
	unsigned int datasize, leftsize;
	char *server_buf = NULL;
	struct SceIoStat stat;
	struct <a href="../network/PSPNET_Core-Reference-English.htm#SceNetEtherAddr">SceNetEtherAddr</a> server_addr, client_addr;
	<a href="../kernel/Types-Reference-English.htm#SceUShort16">SceUShort16</a> client_port;
	char etherstr[18];

	// Allocate send buffer
	server_buf = (char *)malloc(SERVER_BUFSIZE);
	if (server_buf == NULL) {
		printf("malloc() failed.\n");
		goto bad;
	}

	// Open file to be sent
	ret = sceIoOpen(filename, SCE_O_RDONLY, 0644);
	if (ret &lt; 0) {
		printf("sceIoOpen() failed. ret = 0x%x\n", ret);
		goto bad;
	}
	// Save file descriptor in fd
	fd = ret;

	// Get file information
	ret = sceIoGetstat(filename, &amp;stat);
	if (ret &lt; 0) {
		printf("sceIoGetstat() failed. ret = 0x%x\n", ret);
		goto bad;
	}

	// Get local MAC address
	ret = <a href="../network/PSPNET_Core-Reference-English.htm#sceNetGetLocalEtherAddr">sceNetGetLocalEtherAddr</a>(&amp;server_addr);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Core-Reference-English.htm#sceNetGetLocalEtherAddr">sceNetGetLocalEtherAddr</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}

	// Create PTP socket and wait for connection to be established
	ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpListen">sceNetAdhocPtpListen</a>(&amp;server_addr, SERVER_PORT,
			TXBUFLEN, RXBUFLEN, REXMT_INTERVAL, REXMT_COUNT, 1, 0);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpListen">sceNetAdhocPtpListen</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}
	// Save socket ID in id0
	id0 = ret;

	<a href="../network/PSPNET_Core-Reference-English.htm#sceNetEtherNtostr">sceNetEtherNtostr</a>(&amp;server_addr, etherstr);
	printf("server started at addr %s, port %d.\n", etherstr, SERVER_PORT);

	// Wait for connection to be established
	ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpAccept">sceNetAdhocPtpAccept</a>(id0, &amp;client_addr, &amp;client_port, 0, 0);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpAccept">sceNetAdhocPtpAccept</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}
	// Save new socket ID in id
	id = ret;

	// Connection source address and port number are returned in 
	// client_addr and client_port
	<a href="../network/PSPNET_Core-Reference-English.htm#sceNetEtherNtostr">sceNetEtherNtostr</a>(&amp;client_addr, client);
	printf("Accepted from %s, port %d\n", client, client_port);

	// Send file size (network byte order)
	datasize = <a href="../network/PSPNET_Core-Reference-English.htm#sceNetHtonl">sceNetHtonl</a>(stat.st_size);
	len = sizeof(datasize);
	ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpSend">sceNetAdhocPtpSend</a>(id, (void *)&amp;datasize, &amp;len, 0, 0);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpSend">sceNetAdhocPtpSend</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}

	// Set the file size as the initialization value for the remaining data size
	leftsize = stat.st_size;
	while (leftsize &gt; 0) {
		// Read data from file into send buffer
		ret = sceIoRead(fd, server_buf, SERVER_BUFSIZE);
		if (ret &lt; 0) {
			printf("sceIoRead() failed. ret = 0x%x\n", ret);
			goto bad;
		}
		// Set size of data that was read in len
		len = ret;
		// Send data
		<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpSend">sceNetAdhocPtpSend</a>(id, server_buf, &amp;len, 0, 0);
		if (ret &lt; 0) {
			printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpSend">sceNetAdhocPtpSend</a>() failed. ret = 0x%x\n", ret);
			goto bad;
		}
		// Update remaining data size
		leftsize -= len;
	}

	// Wait for send to complete
	ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpFlush">sceNetAdhocPtpFlush</a>(id, 0, 0);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpFlush">sceNetAdhocPtpFlush</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}

bad:
	if (id &gt; 0)
		// Disconnect connection and close socket
		<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpClose">sceNetAdhocPtpClose</a>(id, 0);
	if (id0 &gt; 0)
		// Also close socket that had been waiting for a connection 
		<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpClose">sceNetAdhocPtpClose</a>(id0, 0);
	if (fd &gt; 0)
		// Close file
		sceIoClose(fd);
	if (server_buf)
		// Free send buffer
		free(server_buf);

	printf("server_func() terminated.\n");
}
</font></pre></div>

<!-- sce_hd6 -->
<a name="Heading6_2_4_2_2">
<div style="margin-left:63px;"><h4><b>Client (receiving side)</b><br><br></h4></a></div>
<div style="margin-left:80px;">client_func() initiates a PTP connection and receives file data after the connection is established.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>static void
client_func(
	void
	)
{
	int ret, len, offset;
	int fd = 0, id = 0;
	unsigned int datasize, leftsize;
	struct <a href="../network/PSPNET_Core-Reference-English.htm#SceNetEtherAddr">SceNetEtherAddr</a> server_addr, client_addr;
	char *receiver_buf = NULL;

	// Allocate receive buffer
	client_buf = (char *)malloc(SENDER_BUFSIZE);
	if (client_buf == NULL) {
		printf("malloc() failed.\n");
		goto bad;
	}

	// Open file for saving receive data
	ret = sceIoOpen(filename, SCE_O_WRONLY|SCE_O_CREAT|SCE_O_TRUNC, 0644);
	if (ret &lt; 0) {
		printf("sceIoOpen() failed. ret = 0x%x\n", ret);
		goto bad;
	}
	// Save file descriptor in fd
	fd = ret;

	// Get local MAC address
	ret = <a href="../network/PSPNET_Core-Reference-English.htm#sceNetGetLocalEtherAddr">sceNetGetLocalEtherAddr</a>(&amp;client_addr);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Core-Reference-English.htm#sceNetGetLocalEtherAddr">sceNetGetLocalEtherAddr</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}

	// Convert server (sending side) address server_addr_str("XX:XX:XX:XX:XX:XX")
	// to server_addr
	<a href="../network/PSPNET_Core-Reference-English.htm#sceNetEtherStrton">sceNetEtherStrton</a>(server_addr_str, &amp;server_addr);
	// Create PTP socket and connect to the server (sending side)
	ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpOpen">sceNetAdhocPtpOpen</a>(&amp;client_addr, 0, &amp;server_addr, SERVER_PORT,
			TXBUFLEN, RXBUFLEN, REXMT_INTERVAL, REXMT_COUNT, 0);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpOpen">sceNetAdhocPtpOpen</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}
	// Save socket ID in id
	id = ret;

	// Wait for connection
	ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpConnect">sceNetAdhocPtpConnect</a>(id, 0, 0);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpConnect">sceNetAdhocPtpConnect</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}

	printf("Connected to %s, port %d\n", server, SERVER_PORT);

	// Get file size (network byte order) in datasize
	len = sizeof(datasize);
	ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpRecv">sceNetAdhocPtpRecv</a>(id, (void *)&amp;datasize, &amp;len, 0, 0);
	if (ret &lt; 0) {
		printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpRecv">sceNetAdhocPtpRecv</a>() failed. ret = 0x%x\n", ret);
		goto bad;
	}

	// Set the file size as the initial value for the remaining data size
	leftsize = <a href="../network/PSPNET_Core-Reference-English.htm#sceNetNtohl">sceNetNtohl</a>(datasize);
	while (leftsize &gt; 0) {
		// Set receive buffer size in len
		len = CLIENT_BUFSIZE;
		// Receive data
		ret = <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpRecv">sceNetAdhocPtpRecv</a>(id, client_buf, &amp;len, 0, 0);
		if (ret &lt; 0) {
			printf("<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpRecv">sceNetAdhocPtpRecv</a>() failed. ret = 0x%x\n", ret);
			goto bad;
		}
		offset = 0;
		while (offset &lt; len) {
			// Write receive data to file
			ret = sceIoWrite(fd, client_buf + offset,  len - offset);
			if (ret &lt; 0) {
				printf("sceIoWrite() failed. ret = 0x%x\n", ret);
				goto bad;
			}
			offset += ret;
		}
		// Update remaining data size
		leftsize -= len;
	}
bad:
	if (id &gt; 0)
		// Disconnect connection and close socket
		<a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpClose">sceNetAdhocPtpClose</a>(id, 0);
	if (fd &gt; 0)
		// Close file
		sceIoClose(fd);
	if (client_buf)
		// Free receive buffer
		free(client_buf);

	printf("client_func() terminated.\n");
}
</font></pre></div>
<div style="margin-left:50px;"><br></div>

<!-- sce_hd3 -->
<a name="Heading3_3">
<h2>
 3 <!-- hp --><b>Connection Management With the TCP/IP Protocol</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_3_1">
<h3>
<a href="#Heading3_3"> 3. </a>1 
<!-- hp1 --><b>Overview</b><br>
</a>
</h3>
<div style="margin-left:50px;">To use the TCP/IP protocol in PSPNET, you must set a state in which communication is possible by connecting to the network and setting the IP address.<br>Managing the connection with TCP/IP is the responsibility of the pspnet_apctl library. The application must perform the following processing related to the connection.<br><br></div>
</ul>
<div style="margin-left:55px;"><ol>
<li VALUE=1> From disconnected state, start connecting and wait for the connection to be completed</li>
<li VALUE=2> In connected state after the connection is completed, monitor errors</li>
<li VALUE=3> From connected state, start disconnecting and wait for disconnection to be completed</li>
</ol></div>
<div style="margin-left:50px;"><br>The pspnet_apctl library functions are explained below.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_2">
<h3>
<a href="#Heading3_3"> 3. </a>2 
<!-- hp1 --><b>pspnet_apctl Library State Transition Diagram</b><br>
</a>
</h3>
<div style="margin-left:50px;">The pspnet_apctl library has an internal thread. This thread operates according to the following state transition diagram.<br><br></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English001.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 1 pspnet_apctl State Transition Diagram</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_3_3">
<h3>
<a href="#Heading3_3"> 3. </a>3 
<!-- hp1 --><b>pspnet_apctl Library Usage Procedure</b><br>
</a>
</h3>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_1"><h4>
(1)&nbsp;<b>Initialization</b><br></h4>
</a></div>
<div style="margin-left:67px;">Use <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlInit">sceNetApctlInit</a>() to perform initialization.<br>This function initializes the pspnet_apctl library and creates the internal thread.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlInit">sceNetApctlInit</a>(SceSize stacksize, int prio);
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_2"><h4>
(2)&nbsp;<b>Register Event Handler</b><br></h4>
</a></div>
<div style="margin-left:67px;">Events are generated when state transitions occur for the pspnet_apctl internal thread.<br>The application must register an event handler to receive the internal thread events. The registration function is <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlAddHandler">sceNetApctlAddHandler</a>().<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlAddHandler">sceNetApctlAddHandler</a>(sceNetApctlHandler handler, void *arg);
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_3"><h4>
(3)&nbsp;<b>Scan</b><br></h4>
</a></div>
<div style="margin-left:67px;">An application can perform a scan at any time.<br>For details, refer to "Usage Overview" - "When Using TCP/IP Protocol" - "Scanning".<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_4"><h4>
(4)&nbsp;<b>Connect</b><br></h4>
</a></div>
<div style="margin-left:67px;">Since the network configuration utility is used to connect from an application (during development a dummy dialog library can also be used), it is not necessary to deal directly with pspnet_apctl.<br>When the connection is completed, the internal thread transitions to IPObtained state via the appropriate states for the specified network settings.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_5"><h4>
(5)&nbsp;<b>Monitor Errors</b><br></h4>
</a></div>
<div style="margin-left:67px;">After the connection is completed for the TCP/IP connection, the state of the internal thread becomes IPObtained. However, if an error occurs, an ERROR event is generated, and the state transitions to Disconnected state. Errors that may occur from IPObtained state include the wireless LAN switch being turned off and the peer being disconnected from the access point.<br>The application must always monitor ERROR events from the event handler while the internal thread is in IPObtained state and deal with those events such as by displaying a dialog when an error occurs.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_6"><h4>
(6)&nbsp;<b>Obtain Connection Information</b><br></h4>
</a></div>
<div style="margin-left:67px;">When the internal thread is in IPObtained state, information related to the connection (such as the SSID of the connection destination access point or the IP address of the peer itself) can be obtained.<br>Use <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlGetInfo">sceNetApctlGetInfo</a>() to obtain this information.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlGetInfo">sceNetApctlGetInfo</a>(int code, union <a href="../network/PSPNET_Apctl-Reference-English.htm#SceNetApctlInfo">SceNetApctlInfo</a> *info);
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_7"><h4>
(7)&nbsp;<b>Disconnect</b><br></h4>
</a></div>
<div style="margin-left:67px;">Use <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlDisconnect">sceNetApctlDisconnect</a>() to issue a disconnection request to the internal thread. The internal thread that receives this request disconnects the TCP/IP connection and releases the IP address.<br>When the disconnection request is received, the internal thread starts disconnection processing, and when disconnection is completed, the internal thread transitions to Disconnected state. <b>After a disconnection request is issued, the application must wait for the internal thread to transition to Disconnected state due to a DISCONNECT event.</b><br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlDisconnect">sceNetApctlDisconnect</a>(void);
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_8"><h4>
(8)&nbsp;<b>Delete Event Handler</b><br></h4>
</a></div>
<div style="margin-left:67px;">Delete the event handler that was registered by using <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlAddHandler">sceNetApctlAddHandler</a>().<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlDelHandler">sceNetApctlDelHandler</a>(int id);
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_3_9"><h4>
(9)&nbsp;<b>Termination Processing</b><br></h4>
</a></div>
<div style="margin-left:67px;">Use <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlTerm">sceNetApctlTerm</a>() to perform termination processing for the pspnet_apctl library.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlTerm">sceNetApctlTerm</a>(void);
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_3_4">
<h3>
<a href="#Heading3_3"> 3. </a>4 
<!-- hp1 --><b>Dialog Display</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_3_4_1">
<div style="margin-left:40px;"><h4><b>Overview</b><br><br></h4></div></a>

<div style="margin-left:67px;">When PSPNET is used, dialogs must be displayed for the user when a connection is established or an error occurs. For a TCP/IP connection, GUI-based libraries and utilities that can be used by title applications are provided for these dialogs.<br>When a connection is established, the <b>network configuration utility</b> can be used, and when an error occurs, the <b>message dialog utility</b> can be used.<br>The network configuration utility has functions for displaying connection information in connected state (IPObtained state).<br>Since the time needed for a network disconnection is short, no dialog needs to be specifically displayed.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_3_4_2">
<div style="margin-left:40px;"><h4><b>Dialog When Connecting</b><br><br></h4></div></a>


<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_4_1"><h4>
(1)&nbsp;<b>The Network Configuration Utility</b><br></h4>
</a></div>
<div style="margin-left:67px;">The Network Configuration utility is used in infrastructure mode as a library for connecting to a TCP/IP network. Titles which use the TCP/IP protocol must use this library for connecting. Since the display of dialogs needed for connection is handled by the library, titles do not need to display these dialogs themselves. <br>In addition, dialogs for displaying information after the connection has been established, such as the IP address and DNS server, are also provided by the Network Configuration utility in infrastructure mode. <br>For information regarding use of the Network Configuration utility, refer to the Utility Service documentation.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_3_4_2"><h4>
(2)&nbsp;<b>The Dialog Dummy Library</b><br></h4>
</a></div>
<div style="margin-left:67px;">In order to make the development process more efficient, a non-GUI dialog dummy library (pspnet_ap_dialog_dummy) which supports connection is provided. The Dialog Dummy library can only be used during development.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_3_4_2_3">
<div style="margin-left:40px;"><h4><b>Error Display Dialog in Connected State</b><br><br></h4></div></a>

<div style="margin-left:67px;">If an ERROR event is generated in IPObtained state, the title application must display a message corresponding to the error for the user. The message display is performed using the message dialog utility. Refer to the Utility Services document for information regarding how to use the message dialog utility.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_3_5">
<h3>
<a href="#Heading3_3"> 3. </a>5 
<!-- hp1 --><b>Connection-Related Precautions</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_3_5_4">
<div style="margin-left:40px;"><h4><b>Event Wait During Disconnection</b><br><br></h4></div></a>

<div style="margin-left:67px;">After <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlDisconnect">sceNetApctlDisconnect</a>() is called to issue a disconnection request, processing must wait for the internal thread to transition to Disconnected state due to a DISCONNECT event. When this event is generated, disconnection processing is considered to be completed.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_3_5_5">
<div style="margin-left:40px;"><h4><b>Disconnecting While in Disconnected State</b><br><br></h4></div></a>

<div style="margin-left:67px;">If <a href="../network/PSPNET_Apctl-Reference-English.htm#sceNetApctlDisconnect">sceNetApctlDisconnect</a>() is used to issue a disconnect request while in Disconnected state, a normal DISCONNECT event is generated, and a transition to Disconnected state occurs. Note that this does not generate an error.<br>Also note that as with the precaution above, when transitioning to the Disconnected state due to a DISCONNECT event, you must always wait for the state to transition to Disconnected.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_3_5_6">
<div style="margin-left:40px;"><h4><b>Reconnecting After the AP Disconnects</b><br><br></h4></div></a>

<div style="margin-left:67px;">When in the Authenticating, KeyInfoExchanging, IPObtaining, and IPObtained states, if disconnected from the AP (because a Deauthentication frame or Disassociation frame was received), pspnet_apctl will attempt to reconnect to the AP. <br>The reconnection process is implemented as a RECONNECT event which causes a transition to the Joining state. If a reconnection occurs when in the IPObtained state, the reconnection will use the saved IP address and will skip the IPObtaining state.<br><br></div>

<!-- sce_hd3 -->
<a name="Heading3_4">
<h2>
 4 <!-- hp --><b>Connection Management Using Ad Hoc Mode Communication Protocol</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_4_1">
<h3>
<a href="#Heading3_4"> 4. </a>1 
<!-- hp1 --><b>Overview</b><br>
</a>
</h3>
<div style="margin-left:50px;">To use ad hoc mode in PSPNET, you must connect to the network and be in a state in which communication is possible.<br>Communications processing in ad hoc mode is handled using the pspnet_adhocctl library. At the application level, you must handle the following connection-related processes.<br><br></div>
<div style="margin-left:55px;"><ol>
<li VALUE=1> From disconnected state, start connecting and wait for the connection to be completed</li>
<li VALUE=2> In connected state after the connection is completed, monitor errors</li>
<li VALUE=3> From connected state, start disconnecting and wait for disconnection to be completed</li>
</ol></div>
<div style="margin-left:50px;"><br>The pspnet_adhocctl library functions are explained below. They are divided into the following categories: functions used when performing initialization and scanning neighboring IBSSs and functions used when establishing an ad hoc mode connection.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_4_2">
<h3>
<a href="#Heading3_4"> 4. </a>2 
<!-- hp1 --><b>Initialization Procedure</b><br>
</a>
</h3>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_4_2_1"><h4>
(1)&nbsp;<b>Initialization</b><br></h4>
</a></div>
<div style="margin-left:67px;">Use <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlInit">sceNetAdhocctlInit</a>() to perform initialization.<br>This function initializes the pspnet_adhocctl library and creates the internal thread.<br>Specify the ad hoc ID.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlInit">sceNetAdhocctlInit</a>(SceSize stacksize, int prio, struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlAdhocId">SceNetAdhocctlAdhocId</a> *adhoc_id);
</font></pre></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_4_2_2"><h4>
(2)&nbsp;<b>Register an Event Handler</b><br></h4>
</a></div>
<div style="margin-left:67px;">Events are generated when state transitions occur for the internal thread.<br>The application must register an event handler to receive the internal thread events. The registration function is <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlAddHandler">sceNetAdhocctlAddHandler</a>.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlAddHandler">sceNetAdhocctlAddHandler</a>(sceNetAdhocctlHandler handler, void *arg);
</font></pre></div>
<div style="margin-left:67px;"><br></div>
<div style="margin-left:50px;"></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English002.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 2 pspnet_adhocctl State Transition Diagram (Scanning and Ad hoc Mode Connection)</b><br>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_4_3">
<h3>
<a href="#Heading3_4"> 4. </a>3 
<!-- hp1 --><b>Scanning</b><br>
</a>
</h3>
<div style="margin-left:50px;"><a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlScan">sceNetAdhocctlScan</a>() can be used to scan for a neighboring IBSS having the same ad hoc ID. After scanning starts, the internal thread transitions to SCANNING state, and when scanning is completed, it transitions to DISCONNECTED state.<br>After scanning is completed, use <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetScanInfo">sceNetAdhocctlGetScanInfo</a>() to get the IBSS list obtained as the search result.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlScan">sceNetAdhocctlScan</a>(void);
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetScanInfo">sceNetAdhocctlGetScanInfo</a>(int *buflen, void *buf);
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_4_4">
<h3>
<a href="#Heading3_4"> 4. </a>4 
<!-- hp1 --><b>Ad hoc Mode Connection</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_4_4_7">
<div style="margin-left:40px;"><h4><b>Connect</b><br><br></h4></div></a>


<!-- sce_hd6 -->
<a name="Heading6_4_4_1">
<div style="margin-left:63px;"><h4><b>When Using sceNetAdhocctlConnect()</b><br><br></h4></a></div>
<div style="margin-left:80px;"><a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlConnect">sceNetAdhocctlConnect</a>() enables a title application to connect to an IBSS without being concerned with creating or joining an IBSS.<br>After the connection request is issued, wait for a CONNECTED event or ERROR event.<br>When connection is completed, the internal thread transitions to CONNECTED state.<br>To reconnect after a connection error occurs, start again from the <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlConnect">sceNetAdhocctlConnect</a>() function.<br></div>

<!-- sce_hd6 -->
<a name="Heading6_4_4_2">
<div style="margin-left:63px;"><h4><b>When Using a Combination of sceNetAdhocctlCreate() and sceNetAdhocctlJoin()</b><br><br></h4></a></div>
<div style="margin-left:80px;">After one peer (host) uses <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlCreate">sceNetAdhocctlCreate</a>() to create an IBSS, another peer (guest) uses <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>() to join it.<br><br>The following figure shows the entire connection processing flow.<br><br></div>
<div style="margin-left:67px;"></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English003.gif">
</div>
<br>
<div style="margin-left:67px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 3 Sample Use of sceNetAdhocctlCreate and sceNetAdhocctlJoin()</b><br>
</div>
<br>
</ol>
<div style="margin-left:40px;"><ul>
<li> For host peer using <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlCreate">sceNetAdhocctlCreate</a>()<br>After the connection request is issued, wait for a CONNECTED event or ERROR event.<br>When the connection is completed, the internal thread transitions to CONNECTED state.<br>To reconnect after a connection error occurs, start again from the <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlCreate">sceNetAdhocctlCreate</a>() function.
<li> For guest peer using <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>()<br>Before calling <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>(), perform <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlScan">sceNetAdhocctlScan</a>() to detect an IBSS with the group name to which you want to connect. For the desired IBSS within the search results, perform <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>().
</ul></div>
<div style="margin-left:80px;">After the connection request is issued, wait for a CONNECTED event or ERROR event.<br>When connection is completed, the internal thread transitions to CONNECTED state.<br>To reconnect after a connection error occurs, start again from the <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlJoin">sceNetAdhocctlJoin</a>() function.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_4_4_2_8">
<div style="margin-left:40px;"><h4><b>Monitor Errors</b><br><br></h4></div></a>

<div style="margin-left:67px;">After connection is completed for an ad hoc mode connection, the internal thread remains in CONNECTED state. However, if an error occurs, an ERROR event is generated, and the internal thread transitions to DISCONNECTED state.<br>Errors that may be generated from CONNECTED state include the wireless LAN switch being turned off or suspend processing occurring.<br>The application must always monitor ERROR events from the event handler while in CONNECTED state and deal with those events such as by displaying a dialog when an error occurs.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_4_4_2_9">
<div style="margin-left:40px;"><h4><b>Get Connection Information</b><br><br></h4></div></a>

<div style="margin-left:67px;">When in CONNECTED state, information related to the connection destination IBSS (such as the BSSID or channel) can be obtained.<br>Use <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetParameter">sceNetAdhocctlGetParameter</a>() to obtain this information.<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetParameter">sceNetAdhocctlGetParameter</a>(struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlParameter">SceNetAdhocctlParameter</a> *parameter);
</font></pre></div>

<!-- sce_title -->
<a Name ="HeadingT_4_4_2_10">
<div style="margin-left:40px;"><h4><b>Get Information About Other Peers</b><br><br></h4></div></a>

<div style="margin-left:67px;">When in CONNECTED state, information on the other peers that are connected to the same IBSS can be obtained. Use <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetPeerList">sceNetAdhocctlGetPeerList</a>() or <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetPeerInfo">sceNetAdhocctlGetPeerInfo</a>() to obtain this information.<br>Also, <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetAddrByName">sceNetAdhocctlGetAddrByName</a>() can be used to obtain the MAC address from the nickname of another peer, and <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetNameByAddr">sceNetAdhocctlGetNameByAddr</a>() can be used to obtain the nickname from the MAC address.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetPeerList">sceNetAdhocctlGetPeerList</a>(int *buflen, void *buf);
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetPeerInfo">sceNetAdhocctlGetPeerInfo</a>(struct <a href="../network/PSPNET_Core-Reference-English.htm#SceNetEtherAddr">SceNetEtherAddr</a> *addr, int size, struct 
<a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlPeerInfo">SceNetAdhocctlPeerInfo</a> *peer_info);
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetAddrByName">sceNetAdhocctlGetAddrByName</a>(struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlNickname">SceNetAdhocctlNickname</a> *nickname, 
int *buflen,  void *buf);
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlGetNameByAddr">sceNetAdhocctlGetNameByAddr</a>(struct <a href="../network/PSPNET_Core-Reference-English.htm#SceNetEtherAddr">SceNetEtherAddr</a> *addr, struct  
<a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlNickname">SceNetAdhocctlNickname</a> *nickname);
</font></pre></div>

<!-- sce_title -->
<a Name ="HeadingT_4_4_2_11">
<div style="margin-left:40px;"><h4><b>Disconnect</b><br><br></h4></div></a>

<div style="margin-left:67px;">Use <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlDisconnect">sceNetAdhocctlDisconnect</a>() to issue a disconnection request to the internal thread. The internal thread that receives this request disconnects the ad hoc mode connection.<br>When the internal thread receives the disconnection request, it starts disconnection processing, and when disconnection is completed, the internal thread transitions to DISCONNECTED state. <b>After a disconnection request is issued, the application must wait for a DISCONNECT event.</b><br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlDisconnect">sceNetAdhocctlDisconnect</a>(void);
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_4_5">
<h3>
<a href="#Heading3_4"> 4. </a>5 
<!-- hp1 --><b>Termination Procedure</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_4_5_12">
<div style="margin-left:40px;"><h4><b>Delete Event Handler</b><br><br></h4></div></a>

<div style="margin-left:67px;">Delete the event handler that was registered by using <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlAddHandler">sceNetAdhocctlAddHandler</a>().<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlDelHandler">sceNetAdhocctlDelHandler</a>(int id);
</font></pre></div>

<!-- sce_title -->
<a Name ="HeadingT_4_5_13">
<div style="margin-left:40px;"><h4><b>Termination Processing</b><br><br></h4></div></a>

<div style="margin-left:67px;">Use <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlTerm">sceNetAdhocctlTerm</a>() to perform pspnet_adhocctl library termination processing.<br></div>
        <div style="margin-left:80px;"><pre><font size=3>
int <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlTerm">sceNetAdhocctlTerm</a>(void);
</font></pre></div>

<!-- sce_hd4 -->
<a name="Heading4_4_6">
<h3>
<a href="#Heading3_4"> 4. </a>6 
<!-- hp1 --><b>Dialog Display</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_4_6_14">
<div style="margin-left:40px;"><h4><b>Overview</b><br><br></h4></div></a>

<div style="margin-left:67px;">When PSPNET is used, dialogs must be displayed for the user when a connection is established or an error occurs. For an ad hoc connection, GUI-based libraries and utilities that can be used by title applications are provided for these dialogs.<br>Since the time needed for a network disconnection is short, no dialog needs to be specifically displayed.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_4_6_15">
<div style="margin-left:40px;"><h4><b>When Using Ad hoc Mode Communication Protocol (Connection)</b><br><br></h4></div></a>

<div style="margin-left:67px;">A title application that uses the ad hoc mode communication protocol can select whether to use the <b>network configuration utility</b> to establish the network connection or to directly use the ad hoc network connection library to establish the network connection.<br></div>
</ul>
<div style="margin-left:55px;"><ol>
<li VALUE=1> Using the Network Configuration Utility<br>The ad hoc mode network configuration utility is provided as a library for use with an ad hoc network connection. A title application that uses the ad hoc mode communication protocol can use this utility when establishing a connection. Since the display of dialogs required when establishing a connection is included in the connection processing within the library, dialog display need not be performed separately by a title application.<br>For information related to the method of using the network configuration utility, refer to the utility service document.</li>
<li VALUE=2> Using the Ad Hoc Network Connection Library Directly<br>Details about dialog displays that are required in a title application when the ad hoc network connection library is directly used are explained below.</li>
</ol></div>

<!-- sce_hd6 -->
<a name="Heading6_4_6_1">
<div style="margin-left:63px;"><h4><b>Dialog Display Details</b><br><br></h4></a></div>
<div style="margin-left:80px;">After sceNetAdhocctl{Connect,Create,Join}() is called, the following message is displayed until an <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_CONNECT">SCE_NET_ADHOCCTL_EVENT_CONNECT</a> event is generated from the event handler.<br></div>
<div style="margin-left:50px;"></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English004.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 4 Sample State Display During Connection Processing</b><br>
</div>
<br>
<div style="margin-left:80px;">After sceNetAdhocctl{Connect,Create,Join}() is called, if an <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_ERROR">SCE_NET_ADHOCCTL_EVENT_ERROR</a> event is generated before an <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_CONNECT">SCE_NET_ADHOCCTL_EVENT_CONNECT</a> event from the event handler, the following messages are displayed according to the error code.<br><br></div>
</ol>
<div style="margin-left:70px;"><ul>
<li> <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_ADHOCCTL_WLAN_SWITCH_OFF">SCE_ERROR_NET_ADHOCCTL_WLAN_SWITCH_OFF</a>
<li> <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_WLAN_POWER_OFF">SCE_ERROR_NET_WLAN_POWER_OFF</a>
</ul></div>
<div style="margin-left:50px;"></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English005.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 5 Sample Error Display When Wireless LAN Switch is Turned Off</b><br>
</div>
<br>
<div style="margin-left:70px;"><ul>
<li> Other errors
<li> Invalid user operation, etc.
</ul></div>
<div style="margin-left:50px;"></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English006.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 6 Sample Error Display When Other Errors Occur</b><br><b>(XXXXXXXX is a hexadecimal representation of the error code)</b><br>
</div>
<br>
<div style="margin-left:80px;">To reconnect after an error, restart from the sceNetAdhocctl{Connect,Create,Join}() function.<br></div>

<!-- sce_hd6 -->
<a name="Heading6_4_6_2">
<div style="margin-left:63px;"><h4><b>Message Text</b><br><br></h4></a></div>
<div style="margin-left:80px;">The wording of displayed messages need not be identical to that shown here. Modification of the phrasing is perfectly acceptable provided that the meaning is the same.<br></div>

<!-- sce_hd6 -->
<a name="Heading6_4_6_3">
<div style="margin-left:63px;"><h4><b>Samples</b><br><br></h4></a></div>
<div style="margin-left:80px;">/usr/local/psp/devkit/sample/net/adhoc/adhoc_dialog is provided as a GUI sample of an ad hoc mode communication protocol dialog. Refer to the following samples, which actually use this adhoc_dialog sample as a dialog.<br></div>
<div style="margin-left:70px;"><ul>
<li> /usr/local/psp/devkit/sample/net/adhoc/network_flow
<li> /usr/local/psp/devkit/sample/net/adhoc/matching_room
</ul></div>

<!-- sce_title -->
<a Name ="HeadingT_4_6_3_16">
<div style="margin-left:40px;"><h4><b>When Using the Ad Hoc Mode Communication Protocol (Error Display After Connection is Completed)</b><br><br></h4></div></a>

<div style="margin-left:67px;">When the ad hoc mode communication protocol is used, a disconnection error can occur at any time after a network connection has completed.<br>For example, a disconnection error may occur if the user turns the wireless LAN switch off.<br>A disconnection error is reported by generating an <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_ERROR">SCE_NET_ADHOCCTL_EVENT_ERROR</a> event from the event handler that was registered with pspnet_adhocctl after the connection was completed. When the disconnection error occurs, the title application must display a corresponding error message. It is possible to select whether to use the <b>message dialog utility</b> for message display or to directly display messages on the screen.<br><br></div>
</ol>
<div style="margin-left:55px;"><ol>
<li VALUE=1> When using the message dialog utility<br>The message dialog utility can be used in PSPNET to display a message corresponding to the error code for a disconnection error.<br>The corresponding message can be displayed by specifying the error code that is passed together with the <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_ERROR">SCE_NET_ADHOCCTL_EVENT_ERROR</a> event from the event handler that was registered for pspnet_adhocctl.<br>For information related to the method of using the message dialog utility, refer to the utility service documentation.</li>
<li VALUE=2> When Directly Displaying Messages on the Screen<br>After network connection is completed, if an <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SCE_NET_ADHOCCTL_EVENT_ERROR">SCE_NET_ADHOCCTL_EVENT_ERROR</a> event is generated from the event handler, the following messages are displayed according to the error code.</li>
</ol></div>
<div style="margin-left:80px;"><br></div>
</ol>
<div style="margin-left:70px;"><ul>
<li> <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_ADHOCCTL_WLAN_SWITCH_OFF">SCE_ERROR_NET_ADHOCCTL_WLAN_SWITCH_OFF</a>
<li> <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_WLAN_POWER_OFF">SCE_ERROR_NET_WLAN_POWER_OFF</a>
</ul></div>
<div style="margin-left:67px;"><br></div>
<div style="margin-left:50px;"></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English007.gif">
</div>
<br>
<div style="margin-left:50px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 7 Sample Error Display When Wireless LAN Switch is Turned Off</b><br>
</div>
<br>
<div style="margin-left:67px;">When an error occurs, suspend or terminate all ad hoc socket API calls, and call <a href="../network/PSPNET_Adhocctl-Reference-English.htm#sceNetAdhocctlDisconnect">sceNetAdhocctlDisconnect</a>().<br>To subsequently reconnect, restart from the sceNetAdhocctl{Connect,Create,Join}() function.<br></div>

<!-- sce_hd6 -->
<a name="Heading6_4_6_4">
<div style="margin-left:63px;"><h4><b>Message Text</b><br><br></h4></a></div>
<div style="margin-left:80px;">The wording of displayed messages need not be identical to that shown here. Modification of the phrasing is perfectly acceptable provided that the meaning is the same.<br>However, proper nouns should be used as is.<br></div>
<div style="margin-left:70px;"><ul>
<li> Wireless LAN Switch
</ul></div>

<!-- sce_hd3 -->
<a name="Heading3_5">
<h2>
 5 <!-- hp --><b>Checking for Presence in Ad hoc Mode</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_5_1">
<h3>
<a href="#Heading3_5"> 5. </a>1 
<!-- hp1 --><b>Overview</b><br>
</a>
</h3>
<div style="margin-left:50px;">For networked game-play in ad hoc mode, while the game is running, the peer must be able to confirm that the remote peer is ready for communications. This is known as presence checking. The following is a description of presence checking for an ad hoc mode connection.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_5_2">
<h3>
<a href="#Heading3_5"> 5. </a>2 
<!-- hp1 --><b>Ad hoc Mode Connection</b><br>
</a>
</h3>
<div style="margin-left:50px;">Peer information (struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlPeerInfo">SceNetAdhocctlPeerInfo</a>) is used to perform presence checking for an ad hoc mode connection.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_5_2_1"><h4>
(1)&nbsp;<b>About peer information</b><br></h4>
</a></div>
<div style="margin-left:67px;">For a PSP&trade; that has successfully completed device authentication, Peer information is information about each peer that is saved internally by the PSPNET library.<br></div>

<!-- sce_hd6 -->
<a name="Heading6_5_2_1_1">
<div style="margin-left:63px;"><h4><b>Registration</b><br><br></h4></a></div>
<div style="margin-left:80px;">For an ad hoc mode connection, from the time the connection is completed until it is disconnected, the protocol performs device-level authentication between each PSP&trade;. Each peer broadcasts a &quot;begin-authentication&quot; packet once per second. When a peer receives one of these begin-authentication packets from a new peer, it begins the process of device authentication with that peer. Assuming it succeeds, that peer's information is registered.<br></div>

<!-- sce_hd6 -->
<a name="Heading6_5_2_1_2">
<div style="margin-left:63px;"><h4><b>Deletion</b><br><br></h4></a></div>
<div style="margin-left:80px;">Under any of the following circumstances, a peer will broadcast an end-authentication  packet.<br></div>
<div style="margin-left:70px;"><ul>
<li> During disconnect
<li> During suspend
<li> When the game ends because the PS button (HOME button) was pressed or the cover was opened.
</ul></div>
<div style="margin-left:80px;">When a peer receives an end-authentication packet, it immediately ends device-level authentication for the other peer and deletes that peer's information.<br>Also, a peer that has successfully performed device-level authentication will send out keep-alive packets at 30-second intervals, but if no such packet is received for five minutes or more, authentication is ended and that peer's information is deleted.<br></div>

<!-- sce_hd6 -->
<a name="Heading6_5_2_1_3">
<div style="margin-left:63px;"><h4><b>Updating packet-received time</b><br><br></h4></a></div>
<div style="margin-left:80px;">Within the peer information (struct <a href="../network/PSPNET_Adhocctl-Reference-English.htm#SceNetAdhocctlPeerInfo">SceNetAdhocctlPeerInfo</a>), <i>last_recv </i>indicates the system-clock time (the value obtained from <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetSystemTimeWide">sceKernelGetSystemTimeWide</a>()) of the last packet received from that peer. The packet triggering the update can be a user-transmission packet or a device-authentication protocol packet. For an ad hoc mode connection, because the begin-authentication packet is broadcast at one-second intervals for device authentication, it should be reasonable to expect that as long as the remote device is within communications range, then <i>last_recv </i>will be updated every second, even if the users are not communicating at all.<br></div>

<!-- sce_hd5 -->
<div style="margin-left:40px;"><a name="Heading5_5_2_2"><h4>
(2)&nbsp;<b>Presence-checking flow</b><br></h4>
</a></div>
<div style="margin-left:67px;">Presence checking for an ad hoc mode connection is determined by whether or not peer information is available along with the packet receive time, as discussed above.<br></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English008.gif">
</div>
<br>
<div style="margin-left:67px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 8 Presence-Checking Flow for Ad hoc Mode Connection</b><br>
</div>
<br>
<div style="margin-left:67px;">Set the required time frame for the comparison between <i>last_recv </i>and the current system clock to a value you consider appropriate for your game. Note that setting it too short (say, less than 10 seconds), could cause a misinterpretation of network congestion or temporary radio signal fluctuations as broken communications. As a rule of thumb, you should set this value to between 10 and 30 seconds to give the user enough time to cancel the operation, if necessary.<br></div>

<!-- sce_hd3 -->
<a name="Heading3_6">
<h2>
 6 <!-- hp --><b>Stack size</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_6_1">
<h3>
<a href="#Heading3_6"> 6. </a>1 
<!-- hp1 --><b>Overview</b><br>
</a>
</h3>
<div style="margin-left:50px;">The network modules required to use PSPNET are loaded from flash memory. These modules are subject to updating through the system-update mechanism.<br>To maintain forward compatibility in the PSPNET library, required stack sizes are set for each API call. Stack sizes allocated to callback functions are likewise determined on an individual basis.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_6_2">
<h3>
<a href="#Heading3_6"> 6. </a>2 
<!-- hp1 --><b>Stack Size Required for Calling the API</b><br>
</a>
</h3>
<div style="margin-left:50px;">Immediately after calling an API in PSPNET, a check is made to see if the remaining stack size of the calling thread is sufficient for that API. If it is not, the error <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_INSUFFICIENT_STACKSIZE">SCE_ERROR_NET_INSUFFICIENT_STACKSIZE</a> will be returned.<br>The required stack size for API calls is determined on a module-by-module basis, as follows.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Module name</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Stack size required for API calls (in bytes)</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;pspnet&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;1024 (SCE_NET_PSPNET_LEAST_STACK_SIZE)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;pspnet_inet&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;4096 (SCE_NET_INET_LEAST_STACK_SIZE)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;pspnet_apctl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;5120 (SCE_NET_APCTL_LEAST_STACK_SIZE)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;pspnet_adhoc&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;2048 (SCE_NET_PSPNET_ADHOC_LEAST_STACK_SIZE)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;pspnet_adhocctl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;3072 (SCE_NET_PSPNET_ADHOCCTL_LEAST_STACK_SIZE)&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- sce_hd4 -->
<a name="Heading4_6_3">
<h3>
<a href="#Heading3_6"> 6. </a>3 
<!-- hp1 --><b>Stack Size for the Internal Thread and Callback Functions</b><br>
</a>
</h3>
<div style="margin-left:50px;">With the pspnet_apctl and pspnet_adhoctl libraries, you can specify the stack size of the internal thread for each library during initialization. <b>Stack size should be set to the sum of the stack size to be used by the internal thread plus that used by the callback functions.</b> Stack size used by the internal thread is as follows.<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Module name</b>&nbsp;&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;&nbsp;<b>Stack size used by internal thread (in bytes)</b>&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;pspnet_apctl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;5120 (SCE_NET_APCTL_LEAST_STACK_SIZE)&nbsp;&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;&nbsp;pspnet_adhocctl&nbsp;&nbsp;</td>
<td valign="TOP">&nbsp;&nbsp;3072 (SCE_NET_PSPNET_ADHOCCTL_LEAST_STACK_SIZE)&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<br>
<br>

<!-- sce_hd3 -->
<a name="Heading3_7">
<h2>
 7 <!-- hp --><b>Precautions</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_7_1">
<h3>
<a href="#Heading3_7"> 7. </a>1 
<!-- hp1 --><b>Memory-Related Precautions</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_7_1_17">
<div style="margin-left:40px;"><h4><b>Memory Management</b><br><br></h4></div></a>

<div style="margin-left:67px;">When the pspnet module is initialized, PSPNET allocates an internal memory pool with the specified pool size. From then on, the following PSPNET library group uses this memory pool.<br></div>
<div style="margin-left:70px;"><ul>
<li> pspnet_core
<li> pspnet_adhoc
<li> pspnet_adhocctl
<li> pspnet_inet
<li> pspnet_apctl
</ul></div>
<div style="margin-left:67px;">The status of memory pool usage can be obtained by using <a href="../network/PSPNET_Core-Reference-English.htm#sceNetGetMallocStat">sceNetGetMallocStat</a>().<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_1_18">
<div style="margin-left:40px;"><h4><b>Memory Pool Size</b><br><br></h4></div></a>

<div style="margin-left:67px;">The size of the memory pool needed by the entire PSPNET varies depending on the communication state of the application. The maximum size of the memory pool used can be found by calling <a href="../network/PSPNET_Core-Reference-English.htm#sceNetGetMallocStat">sceNetGetMallocStat</a>(). Using this information, the size of the memory pool can be adjusted accordingly.<br>However, since internal memory is also used when packets are sent and received, if the usable amount of memory is reduced to the bare minimum, it is more likely that the application will fail when it sends and receives packets.<br>Note that in infrastructure mode, this may cause the interface to go down without exchanging DHCP address update packets or PPPoE LCP Echo packets.<br>In ad hoc mode, device authentication may fail, and communication may not be possible.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_7_2">
<h3>
<a href="#Heading3_7"> 7. </a>2 
<!-- hp1 --><b>Thread-Related Precautions</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_7_2_19">
<div style="margin-left:40px;"><h4><b>Thread-Specific Data</b><br><br></h4></div></a>

<div style="margin-left:67px;">PSPNET dynamically allocates and manages thread-specific data such as error codes or exclusive control information internally. This thread-specific data is not deleted dynamically and must be explicitly deleted by the application.<br>To delete thread-specific data, use <a href="../network/PSPNET_Core-Reference-English.htm#sceNetFreeThreadinfo">sceNetFreeThreadinfo</a>().<br></div>

<!-- sce_hd4 -->
<a name="Heading4_7_3">
<h3>
<a href="#Heading3_7"> 7. </a>3 
<!-- hp1 --><b>Precautions When Using TCP/IP</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_7_3_20">
<div style="margin-left:40px;"><h4><b>API Calls for the Same Socket From Multiple Threads</b><br><br></h4></div></a>

<div style="margin-left:67px;">pspnet_inet socket APIs do not perform exclusive control for calls from multiple threads. To call APIs from multiple threads for the same socket, use one of the following methods.<br></div>
<div style="margin-left:70px;"><ul>
<li> Use the socket in non-blocking mode
<li> Have the application perform exclusive control
</ul></div>
<div style="margin-left:67px;">Exclusive control needs to be performed for the socket manipulation functions, except <a href="../network/PSPNET_Inet-Reference-English.htm#sceNetInetSocketAbort">sceNetInetSocketAbort</a>().<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_3_21">
<div style="margin-left:40px;"><h4><b>Immediate Release of the TCP Connection State</b><br><br></h4></div></a>

<div style="margin-left:67px;">When <a href="../network/PSPNET_Inet-Reference-English.htm#sceNetInetCloseWithRST">sceNetInetCloseWithRST</a>() closes a TCP connection, it simultaneously sends a packet with the RST flag raised.<br>At that point, on the TC state transition diagram, the state transitions immediately to CLOSED state from TIME_WAIT state, where it normally should remain for 2 MSL (Maximum Segment Lifetime; with pspnet_inet, this is 60 seconds).<br>As a result, the memory area of the internal structure for maintaining the TCP connection state is released, which should reduce the amount of memory wasted when there are frequent connects and disconnects.<br>However, for an active close (the connection is closed from the local side), since a RST packet is sent without waiting for a FIN or ACK packet to arrive from the destination, to the destination it appears that the connection was reset without performing normal close processing.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_3_22">
<div style="margin-left:40px;"><h4><b>About the Netmask</b><br><br></h4></div></a>

<div style="margin-left:67px;">When 0.0.0.0 is specified for the netmask, the netmask that was calculated from the IP address class is applied.<br></div>
<div style="margin-left:70px;"><ul>
<li> For IP address 10.0.0.1 and netmask 0.0.0.0 <br>The netmask becomes 255.0.0.0.
<li> For IP address 192.168.0.1 and netmask 0.0.0.0 <br>The netmask becomes 255.255.255.0.
</ul></div>

<!-- sce_title -->
<a Name ="HeadingT_7_3_23">
<div style="margin-left:40px;"><h4><b>Broadcast Transmissions</b><br><br></h4></div></a>

<div style="margin-left:67px;">In pspnet_inet, the broadcast address is set as follows according to the address setting.<br><br></div>
<div style="margin-left:70px;"><ul>
<li> Manual setting of IP address<br>Address calculated from specified IP address and netmask.
<li> DHCP<br>Broadcast address specified from DHCP server. If no broadcast address is specified, the address is calculated from the acquired IP address and netmask.
</ul></div>
<div style="margin-left:67px;"><br>If data is sent to 255.255.255.255 as a broadcast, the destination address is converted to the above broadcast address by pspnet_inet.<br>To set the destination address to 255.255.255.255, use the <a href="../network/PSPNET_Inet-Reference-English.htm#SCE_NET_INET_SO_ONESBCAST">SCE_NET_INET_SO_ONESBCAST</a> socket option in <a href="../network/PSPNET_Inet-Reference-English.htm#sceNetInetSetsockopt">sceNetInetSetsockopt</a>().<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_3_24">
<div style="margin-left:40px;"><h4><b>ARP Resolution During UDP Transmission </b><br><br></h4></div></a>

<div style="margin-left:67px;">The pspnet_inet send functions are non-blocking for a UDP socket, and only ENOMEM is returned as an error. Note that the send functions will complete normally even if ARP resolution has not been completed for the destination.<br>pspnet_inet has enough space to keep only one unresolved ARP packet, and that packet is sent initially when an ARP reply packet is received. Since there is only one unresolved ARP packet, if the application thread continuously calls send functions before the internal thread finishes receiving the ARP reply packet, only the last packet will flow on the network.<br>To send packets continuously using UDP, be sure that the internal thread is given enough time to complete its operations.<br><br>Since UDP is an unreliable protocol, when packets get discarded because of unresolved ARP, that essentially amounts to packet loss on the communications channel.<br>With pspnet_inet, UDP properties such as the queueing of unresolved ARP packets on the protocol stack are lost, and moreover, when it is necessary to resend packets, it is the application's responsibility to do so.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_7_4">
<h3>
<a href="#Heading3_7"> 7. </a>4 
<!-- hp1 --><b>Precautions When Using Ad hoc Mode</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_7_4_25">
<div style="margin-left:40px;"><h4><b>Closing a PTP Connection</b><br><br></h4></div></a>

<div style="margin-left:67px;">If <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpClose">sceNetAdhocPtpClose</a>() is called to close a PTP connection from the local side, all data that is in the send and receive buffers is discarded and a FIN message is sent immediately. Therefore, in order to send all the data in the send buffer prior to closing the connection, be sure to use <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpFlush">sceNetAdhocPtpFlush</a>() to wait for the send to complete before closing the connection.<br>However, if the peer closes the PTP connection and a FIN message is received, it will not be possible to send any data that is still in the send buffer. Furthermore, any attempt to call <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpSend">sceNetAdhocPtpSend</a>() will return <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_ADHOC_DISCONNECTED">SCE_ERROR_NET_ADHOC_DISCONNECTED</a>. However, if there is still data remaining in the receive buffer, <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpRecv">sceNetAdhocPtpRecv</a>() can be called until all of the data is received.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_4_26">
<div style="margin-left:40px;"><h4><b>Retry Interval and Retry Count</b><br><br></h4></div></a>

<div style="margin-left:67px;">During a retry, PTP attempts to resend data using the fixed value for the retry interval that was specified in the API, without performing back-off processing. As a result, if the retry interval is specified to be too short, congestion may occur if there is a lot of traffic on the wireless LAN. Because the packet round trip time (RTT) varies according to the communication speed and congestion of the wireless LAN, setting the retry interval to a value less than 100ms is generally not recommended.<br>Also, if there is no reply from the destination within an interval of (retry interval) x (retry count + 1), PTP considers this to be a timeout and closes the connection. Even if the source and destination are within the range of communication, they may not be able to communicate continuously for up to several tens of seconds because conditions may be such that the strength of the wireless signal is too low, so for these reasons, be sure to leave some margin when setting the retry count.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_4_27">
<div style="margin-left:40px;"><h4><b>Number of Peers Connected to the Same IBSS</b><br><br></h4></div></a>

<div style="margin-left:67px;">The number of peers connected to an IBSS using the same group name is limited. Specifically, the number of peers that can be authenticated is limited to 16 excluding the peer itself. If 18 or more peers are connected to the same IBSS, each peer performs authentication processing for up to 16 of the other peers.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_4_28">
<div style="margin-left:40px;"><h4><b>Ad hoc Mode Channel Number Setting</b><br><br></h4></div></a>

<div style="margin-left:67px;">The ad hoc mode channel number setting can be obtained by specifying SCE_UTILITY_SYSTEM_PARAM_ADHOC_CHANNEL when calling the utility service's system information acquisition function <a href="../utility/Utility-Reference-English.htm#sceUtilityGetSystemParamInt">sceUtilityGetSystemParamInt</a>(). The value represents the channel number, and 0 means "automatic." The channel number setting can only be changed by system software. For details, refer to the utility service documentation.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_4_29">
<div style="margin-left:40px;"><h4><b>Connections Between Peers With Different Channel Number Settings</b><br><br></h4></div></a>

<div style="margin-left:67px;">It is assumed that a peer which has its channel number set to "automatic" will connect to a peer which also has its channel number set to "automatic." Note that a peer which has its channel number set to "1ch," "6ch," or "11ch" may or may not be able to connect to a peer which has its channel number set to "automatic" depending on the channel that the peer has automatically selected.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_4_30">
<div style="margin-left:40px;"><h4><b>Determining Timeouts when Changing Communications Groups and During Ad hoc Communication </b><br><br></h4></div></a>

<div style="margin-left:67px;">When changing communications groups in ad hoc mode (for example, when switching from a lobby group to a game-play group), you must temporarily disconnect and then reconnect. At this point, you will repeatedly undertake the following actions and use the timeout to determine success or failure:<br></div>
<div style="margin-left:70px;"><ul>
<li> Scan for a new communications group to join.
<li> After establishing a connection, send probe packets to check whether the peer is connected to the new group.
</ul></div>
<div style="margin-left:67px;">In this type of disconnect/connect/check connection process, <br></div>
<div style="margin-left:70px;"><ul>
<li> Begin connecting after a read operation from the UMD&trade;
<li> After the connection is completed, begin communicating to check the connection after performing a read operation from the UMD&trade;.
</ul></div>
<div style="margin-left:67px;">because UMD&trade; read operations can be time-consuming, the processing time for each peer can vary. Consequently, regardless of whether a proper connection has been made, it can be a problem trying to decide if a timeout has occurred.<br>Also, even during normal ad hoc communication (in situations such as when<br></div>
<div style="margin-left:70px;"><ul>
<li> The stage changes and data needs to be loaded from the UMD&trade; to advance the game, processing between peers will wait until the data has been loaded.
</ul></div>
<div style="margin-left:67px;">In such cases, the processing time may vary for each peer due to differences in the time required to read data from the UMD&trade;. As a result, it may appear as though a timeout has occurred, and the game may not be able to proceed.<br>Therefore,<br></div>
<div style="margin-left:70px;"><ul>
<li> Do not begin operations where the processing time can vary, such as UMD&trade; reads, during the disconnect/connect/check connection sequence.
<li> Set a relatively long timeout (60 seconds or more) to make allowances even if the peers do get out of sync. At the same time, you should give the user enough time to cancel out if necessary.
</ul></div>
<div style="margin-left:67px;">Generally write your code so that it is not dependent on application processing speed. To determine if a timeout has occurred, measure the absolute time as obtained from a function like <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelGetSystemTimeWide">sceKernelGetSystemTimeWide</a>(), rather than using a VSYNC-driven counter. In the latter case, the time obtained may differ from the expected timeout time because the frame rate may not remain constant if the drawing load gets to be large.<br></div>

<!-- sce_title -->
<a Name ="HeadingT_7_4_31">
<div style="margin-left:40px;"><h4><b>Thread Operation When Sending/Receiving a Packet</b><br><br></h4></div></a>

<div style="margin-left:67px;">Operation details for network-related threads when a packet is sent/received in ad hoc mode are described below.<br></div>
</ol>
<div style="margin-left:40px;"><ul>
<li> When a packet is sent <br>After the send API is called, the user thread gets a semaphore for the entire PSPNET within the library. It then assembles the packet by attaching headers etc., and for PDP, directly enqueues it in the interface send queue. Then, it calls <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSendMbx">sceKernelSendMbx</a>() to notify the sceWlanMac thread of the queuing of the send packet.
<li> For PTP, the user thread temporarily stores the packet in the transmission socket buffer, and if there is a packet that must be sent, it is enqueued in the interface send queue.
<li> When the sceWlanMac thread receives the notification, it fetches the send packet from the interface send queue, encrypts it and attaches a signature, and waits for a sendable interrupt to arrive. If it is already in a sendable state or when a sendable notification arrives from the sceWlanHal thread, the sceWlanMac thread sends the packet to the device and waits for the next task. Note that if the user thread priority is greater than the sceWlanMac thread priority of 39 (in other words, its priority is low), the user thread may not be able to return immediately after the <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSendMbx">sceKernelSendMbx</a>() call, and the sceWlanMac thread may have to wait for the send operation to complete.<br>
</ul></div>
<div style="margin-left:67px;"></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English009.gif">
</div>
<br>
<div style="margin-left:67px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 9 Thread Operation When Sending a Packet</b><br>
</div>
<br>
<div style="margin-left:40px;"><ul>
<li> When a packet is received <br>When a receive interrupt comes from a device, the sceWlanHal thread takes a packet into the receive buffer within the driver. Then, it enqueues the receive packet in the driver receive queue and calls <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSendMbx">sceKernelSendMbx</a>() to notify the sceWlanMac thread of the queuing of the receive packet.
<li> The sceWlanMac thread gets the receive packet from the driver receive queue, and after copying it to the PSPNET buffer area, enqueues it in the interface receive queue. Then it calls <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSetEventFlag">sceKernelSetEventFlag</a>() to notify the sceNetIntr thread.
<li> The sceNetIntr thread gets the receive packet from the interface receive queue, removes the headers after decrypting it and verifying the signature, and stores it in the receive socket buffer. At the same time, if there is a thread that is awaiting reception for the relevant socket, the sceNetIntr thread calls <a href="../kernel/Thread_Manager-Reference-English.htm#sceKernelSignalSema">sceKernelSignalSema</a>() to cancel blocking.
<li> After the receive API is called, the user thread gets a semaphore for the entire PSPNET within the library. If there is data in the receive socket buffer, the user thread copies the packet to the specified buffer area and returns. If there is no data, the user thread either waits for data to arrive or in the case of non-blocking mode, returns an error.
</ul></div>
<div style="margin-left:67px;"></div>

<div align=center>
<p>
<img src="gif/PSPNET-Overview-English010.gif">
</div>
<br>
<div style="margin-left:67px;"><br></div>

<!-- sce_fignum -->
<div align=center>
<p>
<b>Figure 10 Thread Operation When Receiving a Packet</b><br>
</div>
<br>

<!-- sce_title -->
<a Name ="HeadingT_7_4_32">
<div style="margin-left:40px;"><h4><b>SCE_ERROR_NET_ADHOC_INVALID_ADDR</b><br><br></h4></div></a>

<div style="margin-left:67px;">The following functions will return <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_ADHOC_INVALID_ADDR">SCE_ERROR_NET_ADHOC_INVALID_ADDR</a> if no connection has been established to the ad hoc network. Be sure to call these functions only after a connection is established.<br></div>
</ul>
<div style="margin-left:70px;"><ul>
<li> <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPdpCreate">sceNetAdhocPdpCreate</a>()
<li> <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpOpen">sceNetAdhocPtpOpen</a>()
<li> <a href="../network/PSPNET_Adhoc-Reference-English.htm#sceNetAdhocPtpListen">sceNetAdhocPtpListen</a>()
</ul></div>

<!-- sce_hd4 -->
<a name="Heading4_7_5">
<h3>
<a href="#Heading3_7"> 7. </a>5 
<!-- hp1 --><b>Suspend/Resume-Related Precautions</b><br>
</a>
</h3>
<div style="margin-left:50px;">PSPNET handles suspend and standby operations as errors. When the TCP/IP protocol is used, a required disconnection procedure is performed (for returning the IP address) before the suspend or standby operation.<br>For suspend, the error is reported to the higher layer via the event handler after resume processing. In this case, pspnet_apctl returns an error code of <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_APCTL_WLAN_SUSPENDED">SCE_ERROR_NET_APCTL_WLAN_SUSPENDED</a> and pspnet_adhocctl returns <a href="../network/PSPNET_Error-Reference-English.htm#SCE_ERROR_NET_ADHOCCTL_WLAN_SUSPENDED">SCE_ERROR_NET_ADHOCCTL_WLAN_SUSPENDED</a>.<br></div>

<!-- sce_hd3 -->
<a name="Heading3_8">
<h2>
 8 <!-- hp --><b>Resources Used</b>
<hr noshade>
</h2>


<!-- sce_hd4 -->
<a name="Heading4_8_1">
<h3>
<a href="#Heading3_8"> 8. </a>1 
<!-- hp1 --><b>Resources Used by TCP/IP</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_8_1_33">
<div style="margin-left:40px;"><h4><b>Threads</b><br><br></h4></div></a>

<div style="margin-left:67px;">wlan uses 2 internal threads.<br>pspnet uses 2 internal threads.<br>pspnet_apctl uses 1 internal thread.<br></div>

<!-- sce_hd4 -->
<a name="Heading4_8_2">
<h3>
<a href="#Heading3_8"> 8. </a>2 
<!-- hp1 --><b>Resources Used in Ad Hoc Mode</b><br>
</a>
</h3>

<!-- sce_title -->
<a Name ="HeadingT_8_2_34">
<div style="margin-left:40px;"><h4><b>Threads</b><br><br></h4></div></a>

<div style="margin-left:67px;">wlan uses 2 internal threads.<br>pspnet uses 2 internal threads.<br>pspnet_adhoc_auth uses 1 internal thread.<br>pspnet_adhocctl uses 1 internal thread.<br><br></div>
<p><p><hr>
<div ALIGN="right">
    &copy;2009 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
