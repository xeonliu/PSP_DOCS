<html lang="en">
<head>
<title>VFPU_Macro-Reference</title>
<meta http-equiv="Content-Type" content= text/html; charset=iso-8859-1>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&trade; Programmer Tool Runtime Library Release 6.3.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
psp-as VFPU Macro Reference
</h1></center>
</a>
<!-- sce_hd1 -->

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvi.s"></a>
<table width="100%"><td width="70%"><font size=6>lvi.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Load Immediate Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load immediate to VFPU (Scalar)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvi.s	vt, imm0

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Stores the single precision floating-point number indicated by <i>imm</i> as one element into the matrix register location indicated by <i>vt</i>.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0] &lt;- imm0<br>WriteMatrix( SINGLEWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvi.p"></a>
<table width="100%"><td width="70%"><font size=6>lvi.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Load Immediate Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load immediate to VFPU (2D vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvi.p	vt, [imm0,imm1]

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Stores the two single precision floating-point numbers indicated by <i>imm0</i> and <i>imm1</i> as two elements into the matrix register location indicated by <i>vt</i>.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0] &lt;- imm0<br>t[1] &lt;- imm1<br>WriteMatrix( PAIRWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvi.t"></a>
<table width="100%"><td width="70%"><font size=6>lvi.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Load Immediate Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load immediate to VFPU (3D vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvi.t	vt, [imm0,imm1,imm2]

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Stores the three single precision floating-point numbers indicated by <i>imm0</i>, <i>imm2</i>, and <i>imm3</i> as three elements into the matrix register location indicated by <i>vt</i>.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0] &lt;- imm0<br>t[1] &lt;- imm1<br>t[2] &lt;- imm2<br>WriteMatrix( TRIPLEWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvi.q"></a>
<table width="100%"><td width="70%"><font size=6>lvi.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Load Immediate Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load immediate to VFPU (4D vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvi.q	vt, [imm0,imm1,imm2,imm3]

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Stores the four single precision floating-point numbers indicated by <i>imm0</i>, <i>imm2</i>, <i>imm3</i>, and <i>imm4</i> as four elements into the matrix register location indicated by <i>vt</i>.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0] &lt;- imm0<br>t[1] &lt;- imm1<br>t[2] &lt;- imm2<br>t[3] &lt;- imm3<br>WriteMatrix( QUADWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvhi.s"></a>
<table width="100%"><td width="70%"><font size=6>lvhi.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Load Immediate Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load half-precision immediate to VFPU (2D vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvhi.s	vt, [imm0,imm1]

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Stores the two half precision floating-point numbers indicated by <i>imm0</i> and <i>imm1</i> as two elements into the matrix register location indicated by <i>vt</i>.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0].l &lt;- imm0<br>t[0].u &lt;- imm1<br>WriteMatrix( SINGLEWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvhi.p"></a>
<table width="100%"><td width="70%"><font size=6>lvhi.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Load Immediate Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load half-precision immediate to VFPU (4D vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvhi.p	vt, [imm0,imm1,imm2,imm3]

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">Stores the four half precision floating-point numbers indicated by <i>imm0</i>, <i>imm2</i>, <i>imm3</i>, and <i>imm4</i> as four elements into the matrix register location indicated by <i>vt</i>.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0].l &lt;- imm0<br>t[0].u &lt;- imm1<br>t[1].l &lt;- imm2<br>t[1].u &lt;- imm3<br>WriteMatrix( PAIRWORD, vt, t )<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lv.s"></a>
<table width="100%"><td width="70%"><font size=6>lv.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load address-extended single-word to VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lv.s	vt, offset32(rs)
lv.s	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If the offset of the lv.s instruction is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br>Subsequent operations are the same as those performed by lv.s on a 16-bit offset.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( SINGLEWORD, pAddr, vAddr, DATA );<br>WriteMatrix( SINGLEWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lv.p"></a>
<table width="100%"><td width="70%"><font size=6>lv.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load double-word to VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lv.p	vt, offset16(rs)
lv.p	vt, offset32(rs)
lv.p	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 16-bit offset16 is sign-extended and added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. A double-word value starting at the memory location corresponding to this address is read and stored in the location in the matrix register indicated by <i>vt</i>. <br><br>If the offset is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( PAIRWORD, pAddr, vAddr, DATA );<br>WriteMatrix( PAIRWORD, vt, memword );<br><br>Or:<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( PAIRWORD, pAddr, vAddr, DATA );<br>WriteMatrix( PAIRWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lv.t"></a>
<table width="100%"><td width="70%"><font size=6>lv.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load triple-word to VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lv.t	vt, offset16(rs)
lv.t	vt, offset32(rs)
lv.t	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 16-bit offset16 is sign-extended and added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. A triple-word value starting at the memory location corresponding to this address is read and stored in the location in the matrix register indicated by <i>vt</i>. <br><br>If the offset is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( TRIPLEWORD, pAddr, vAddr, DATA );<br>WriteMatrix( TRIPLEWORD, vt, memword );<br><br>Or:<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( TRIPLEWORD, pAddr, vAddr, DATA );<br>WriteMatrix( TRIPLEWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lv.q"></a>
<table width="100%"><td width="70%"><font size=6>lv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load address-extended quad-word to VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lv.q	vt, offset32(rs)
lv.q	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If the offset of the lv.q instruction is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, a 32-bit address32 is treated as a virtual address. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br>Subsequent operations are the same as those performed by lv.q on a 16-bit offset.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( QUADWORD, pAddr, vAddr, DATA );<br>WriteMatrix( QUADWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="ulv.s"></a>
<table width="100%"><td width="70%"><font size=6>ulv.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load unaligned single-word to VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>ulv.s	vt, offset16(rs)

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 16-bit offset16 is sign-extended and added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. A single-word value starting at the memory location corresponding to this address is read and stored in the location in the matrix register indicated by <i>vt</i>. <br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( SINGLEWORD, pAddr, vAddr, DATA );<br>WriteMatrix( SINGLEWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="ulv.q"></a>
<table width="100%"><td width="70%"><font size=6>ulv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load unaligned quad-word to VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>ulv.q	vt, offset16(rs)
ulv.q	vt, offset32(rs)
ulv.q	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 16-bit offset16 with the low-order two bits ignored is sign-extended and added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. A quad-word value starting at the memory location corresponding to this address is read and stored in the location in the matrix register indicated by <i>vt</i>. <br><br>The VFPU's <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#lv.q">lv.q</a> instruction requires 16-byte alignment, but since the ulv.q instruction repeats the <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#lv.s">lv.s</a> instruction four times, it can operate on addresses with 4-byte alignment. <br><br>If the offset is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:2],2'b0 ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( QUADWORD, pAddr, vAddr, DATA );<br>WriteMatrix( QUADWORD, vt, memword );<br><br>Or:<br><br>vAddr &lt;- offset32[31:2] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( QUADWORD, pAddr, vAddr, DATA );<br>WriteMatrix( QUADWORD, vt, memword );<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sv.s"></a>
<table width="100%"><td width="70%"><font size=6>sv.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store address-extended single-word from VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>sv.s	vt, offset32(rs)
sv.s	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If the offset of the sv.s instruction is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br>Subsequent operations are the same as those performed by sv.s on a 16-bit offset.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( SINGLEWORD, vt );<br>StoreMemory( SINGLEWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sv.p"></a>
<table width="100%"><td width="70%"><font size=6>sv.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store double-word from VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>sv.p	vt, offset16(rs)
sv.p	vt, offset32(rs)
sv.p	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 16-bit offset16 is sign-extended and added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. The single-word contents of the matrix register indicated by <i>vt</i> are stored at the memory location based on this address. <br><br>If the offset is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( PAIRWORD, vt );<br>StoreMemory( PAIRWORD, dataword, pAddr, vAddr, DATA );<br><br>Or:<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( PAIRWORD, vt );<br>StoreMemory( PAIRWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sv.t"></a>
<table width="100%"><td width="70%"><font size=6>sv.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store triple-word from VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>sv.t	vt, offset(rs)
sv.t	vt, offset32(rs)
sv.t	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 16-bit offset is sign-extended and added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. The single-word contents of the matrix register indicated by <i>vt</i> are stored at the memory location based on this address. <br><br>If the offset is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( TRIPLEWORD, vt );<br>StoreMemory( TRIPLEWORD, dataword, pAddr, vAddr, DATA );<br><br>Or:<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( TRIPLEWORD, vt );<br>StoreMemory( TRIPLEWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sv.q"></a>
<table width="100%"><td width="70%"><font size=6>sv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store address-extended quad-word from VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>sv.q	vt, offset32(rs)
sv.q	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">If the offset of the sv.q instruction is not in the range of signed 16-bit values, it is address-extended and handled as an offset32. Alternatively, the 32-bit address32 is treated as a virtual address. <br><br>Subsequent operations are the same as those performed by sv.q on a 16-bit offset.<br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( QUADWORD, vt );<br>StoreMemory( QUADWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="svl.q"></a>
<table width="100%"><td width="70%"><font size=6>svl.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store address-extended quad-word left from VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>svl.q	vt, offset32(rs)
svl.q	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 32-bit offset32 with the low-order two bits ignored is added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address.<br>Alternatively, the 32-bit address32 is treated as a virtual address. <br>Subsequent operations are the same as those performed by svl.q on a 16-bit offset.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="svr.q"></a>
<table width="100%"><td width="70%"><font size=6>svr.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store address-extended quad-word right from VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>svr.q	vt, offset32(rs)
svr.q	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 32-bit offset32 with the low-order two bits ignored is added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. <br>Alternatively, the 32-bit address32 is treated as a virtual address. <br>Subsequent operations are the same as those performed by svr.q on a 16-bit offset.<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="usv.s"></a>
<table width="100%"><td width="70%"><font size=6>usv.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store unaligned single-word from VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>usv.s	vt, offset16(rs)

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 16-bit offset16 is sign-extended and added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. The single-word contents of the matrix register indicated by <i>vt</i> are stored at the memory location based on this address. <br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( SINGLEWORD, vt );<br>StoreMemory( SINGLEWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="usv.q"></a>
<table width="100%"><td width="70%"><font size=6>usv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[Extended Load and Store Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store unaligned quad-word from VFPU<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>usv.q	vt, offset16(rs)
usv.q	vt, offset32(rs)
usv.q	vt, address32

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The 16-bit offset16 with the low-order two bits ignored is sign-extended and added to the contents of the general-purpose register specified by <i>rs</i> to create a virtual address. The quad-word contents of the matrix register indicated by <i>vt</i> are stored at the memory location based on this address.<br><br>The VFPU's <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#sv.q">sv.q</a> instruction requires 16-byte alignment, but since the usv.q instruction repeats the <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#sv.s">sv.s</a> instruction four times, it can operate on addresses with 4-byte alignment. <br><br></div>

<!-- Operations -->
<div style="margin-left:10px;"><b>Operations</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:2],2'b0 ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( QUADWORD, vt );<br>StoreMemory( QUADWORD, dataword, pAddr, vAddr, DATA );<br><br>Or:<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( QUADWORD, vt );<br>StoreMemory( QUADWORD, dataword, pAddr, vAddr, DATA );<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vdiv.p"></a>
<table width="100%"><td width="70%"><font size=6>vdiv.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vdiv Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Divide Pair Word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vdiv.p		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The floating-point values of two elements of the matrix register indicated by vs are divided by the floating-point values of two elements of the matrix register indicated by vt. The result is stored as a two-element floating-point value in the matrix register location indicated by vd.<br><br>The assembler processes vdiv.p as a macro instruction in which the vdiv.s instruction is repeated twice.<br>vdiv.p was originally a native VFPU instruction, however, it was deleted from the specifications since it caused a known bug in which a register could be destroyed when an <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#lv.q">lv.q</a> instruction that followed the vdiv.p caused a D-cache miss.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vdiv.p		c000, c100, c200
is equivalent to the following.
vdiv.s		s000, s100, s200
vdiv.s		s001, s101, s201


</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vdiv.t"></a>
<table width="100%"><td width="70%"><font size=6>vdiv.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vdiv Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Divide Triple Word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vdiv.t		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The floating-point values of three elements of the matrix register indicated by vs are divided by the floating-point values of three elements of the matrix register indicated by vt. The result is stored as a three-element floating-point value at the matrix register location indicated by vd.<br><br>The assembler processes vdiv.t as a macro instruction in which the vdiv.s instruction is repeated three times.<br>vdiv.t was originally a native VFPU instruction, however, it was deleted from the specifications since it caused a known bug in which a register could be destroyed when an <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#lv.q">lv.q</a> instruction that followed the vdiv.t caused a D-cache miss.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vdiv.t		c000, c100, c200
is equivalent to the following.
vdiv.s		s000, s100, s200
vdiv.s		s001, s101, s201
vdiv.s		s002, s102, s202


</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vdiv.q"></a>
<table width="100%"><td width="70%"><font size=6>vdiv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vdiv Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Divide Quad Word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vdiv.q		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The floating-point values of four elements of the matrix register indicated by vs are divided by the floating-point values of four elements of the matrix register indicated by vt. The result is stored as a four-element floating-point value at the matrix register location indicated by vd.<br><br>The assembler processes vdiv.q as a macro instruction in which the vdiv.s instruction is repeated four times.<br>vdiv.q was originally a native VFPU instruction, however, it was deleted from the specifications since it caused a known bug in which a register could be destroyed when an <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#lv.q">lv.q</a> instruction that followed the vdiv.q caused a D-cache miss.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vdiv.q		c000, c100, c200
is equivalent to the following.
vdiv.s		s000, s100, s200
vdiv.s		s001, s101, s201
vdiv.s		s002, s102, s202
vdiv.s		s003, s103, s203


</font></pre></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vcmmul.p"></a>
<table width="100%"><td width="70%"><font size=6>vcmmul.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply pair x pair matrix (for column major matrix)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vcmmul.p	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vd</i>, <i>vs</i>, and <i>vt</i> are all in column major matrix format, so for this instruction, the matrix registers are normally specified in e000 format. If they are specified in m000 format, this signifies a transposition. <br><br>This macro instruction causes the assembler to generate a vmmul.p instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. With the -vmmul-trans option, which is set by default, assembly is performed with the <i>vs</i> operand transposed (i.e., the <i>vt</i> operand prior to the operand switch). This allows assembly source code to be written in a format which matches the order of operations. <br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vcmmul.p	e000, e100, e200
is equivalent to 
vmmul.p		e000, e200, e100

Matrix <i>e200</i> is multiplied by matrix <i>e100</i> from the right and stored in matrix <i>e000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vcmmul.t"></a>
<table width="100%"><td width="70%"><font size=6>vcmmul.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply triple x triple matrix (for column major matrix)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vcmmul.t	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vd</i>, <i>vs</i>, and <i>vt</i> are all in column major matrix format, so for this instruction, the matrix registers are normally specified in e000 format. If they are specified in m000 format, this signifies a transposition. <br><br>This macro instruction causes the assembler to generate a vmmul.t instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. With the -vmmul-trans option, which is set by default, assembly is performed with the <i>vs</i> operand transposed (i.e., the <i>vt</i> operand prior to the operand switch). This allows assembly source code to be written in a format which matches the order of operations. <br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vcmmul.t	e000, e100, e200
is equivalent to 
vmmul.t		e000, e200, e100

Matrix <i>e200</i> is multiplied by matrix <i>e100</i> from the right and stored in the matrix <i>e000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vcmmul.q"></a>
<table width="100%"><td width="70%"><font size=6>vcmmul.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply quad x quad matrix (for column major matrix)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vcmmul.q	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vd</i>, <i>vs</i>, and <i>vt</i> are all in column major matrix format, so for this instruction, the matrix registers are normally specified in e000 format. If they are specified in m000 format, this signifies a transposition. <br><br>This macro instruction causes the assembler to generate a vmmul.q instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. With the -vmmul-trans option, which is set by default, assembly is performed with the <i>vs</i> operand transposed (i.e., the <i>vt</i> operand prior to the operand switch). This allows assembly source code to be written in a format which matches the order of operations. <br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vcmmul.q	e000, e100, e200
is equivalent to 
vmmul.q		e000, e200, e100

Matrix <i>e200</i> is multiplied by matrix <i>e100</i> from the right and stored in matrix <i>e000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrmmul.p"></a>
<table width="100%"><td width="70%"><font size=6>vrmmul.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply pair x pair matrix (for row major matrix)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrmmul.p	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vd</i>, <i>vs</i>, and <i>vt</i> are all in row major matrix format, so for this instruction, the matrix registers are normally specified in m000 format. If they are specified in e000 format, this signifies a transposition.<br><br>This macro instruction causes the assembler to generate a vmmul.p instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. With the -vmmul-trans option, which is set by default, assembly is performed with the <i>vs</i> operand transposed. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrmmul.p	m000, m100, m200
is equivalent to 
vmmul.p		m000, m100, m200

Matrix <i>m200</i> is multiplied by matrix <i>m100</i> from the right and stored in matrix <i>m000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrmmul.t"></a>
<table width="100%"><td width="70%"><font size=6>vrmmul.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply triple x triple matrix (for row major matrix)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrmmul.t	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vd</i>, <i>vs</i>, and <i>vt</i> are all in row major matrix format, so for this instruction, the matrix registers are normally specified in m000 format. If they are specified in e000 format, this signifies a transposition. <br><br>This macro instruction causes the assembler to generate a vmmul.t instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. With the -vmmul-trans option, which is set by default, assembly is performed with the <i>vs</i> operand transposed. This allows assembly source code to be written in a format which matches the order of operations. <br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrmmul.t	m000, m100, m200
is equivalent to 
vmmul.t		m000, m100, m200

Matrix <i>m200</i> is multiplied by matrix <i>m100</i> from the right and stored in matrix <i>m000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrmmul.q"></a>
<table width="100%"><td width="70%"><font size=6>vrmmul.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply quad x quad matrix (for row major matrix)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrmmul.q	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vd</i>, <i>vs</i>, and <i>vt</i> are all in row major matrix format, so for this instruction, the matrix registers are normally specified in m000 format. If they are specified in e000 format, this signifies a transposition. <br><br>This macro instruction causes the assembler to generate a vmmul.q instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. With the -vmmul-trans option, which is set by default, assembly is performed with the <i>vs</i> operand transposed. This allows assembly source code to be written in a format which matches the order of operations. <br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrmmul.q	m000, m100, m200
is equivalent to 
vmmul.q		m000, m100, m200

Matrix <i>m200</i> is multiplied by matrix <i>m100</i> from the right and stored in matrix <i>m000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxmmul.p"></a>
<table width="100%"><td width="70%"><font size=6>vxmmul.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply pair x pair matrix<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxmmul.p	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxmmul.p macro instruction generates a vmmul.p instruction assembled with the <i>vs</i> operand in transposed format, regardless of whether the -vmmul-trans option or the -no-vmmul-trans option is specified.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vxmmul.p	e000, e200, e100
is equivalent to 
vmmul.p		e000, e200, e100		// With -vmmul-trans specified
vmmul.p		e000, m200, e100		// With -no-vmmul-trans specified

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxmmul.t"></a>
<table width="100%"><td width="70%"><font size=6>vxmmul.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply triple x triple matrix<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxmmul.t	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxmmul.t macro instruction generates a vmmul.t instruction with the order of the <i>vs</i> and <i>vt</i> operands switched, regardless of whether the -vmmul-trans option or the -no-vmmul-trans option is specified.<br><br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vxmmul.t	e000, e200, e100
is equivalent to 
vmmul.t		e000, e200, e100		// With -vmmul-trans specified
vmmul.t		e000, m200, e100		// With -no-vmmul-trans specified

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxmmul.q"></a>
<table width="100%"><td width="70%"><font size=6>vxmmul.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmul Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply quad x quad matrix<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxmmul.q	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxmmul.q macro instruction generates a vmmul.q instruction with the order of the <i>vs</i> and <i>vt</i> operands switched, regardless of whether the -vmmul-trans option or the -no-vmmul-trans option is specified.<br><br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vxmmul.q	e000, e200, e100
is equivalent to 
vmmul.q		e000, e200, e100		// With -vmmul-trans specified
vmmul.q		e000, m200, e100		// With -no-vmmul-trans specified

</font></pre></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vctfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vctfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 2 double-word (column vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vctfm2.p		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in column major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in e000 format. If it is specified in m000 format, this signifies that a transposed matrix will be used for the transformation.<br><br>This macro instruction causes the assembler to generate a vtfm2.p instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. This allows assembly source code to be written in a format which matches the order of operations.<br><br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vctfm2.p		c000, e100, c200
is equivalent to 
vtfm2.p		c000, e100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vctfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vctfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 3 triple-word (column vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vctfm3.t		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in column major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in e000 format. If it is specified in m000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vtfm3.t instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vctfm3.t		c000, e100, c200
is equivalent to 
vtfm3.t		c000, e100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vctfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vctfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 4 quad-word (column vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vctfm4.q		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in column major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in e000 format. If it is specified in m000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vtfm4.q instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vctfm4.q		c000, e100, c200
is equivalent to 
vtfm4.q		c000, e100, c200

Vctor <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vrtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 2 double-word (row vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrtfm2.p		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in row major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in m000 format. If it is specified in e000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vtfm2.p instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrtfm2.p		r000, r100, m200
is equivalent to 
vtfm2.p		r000, m200, r100

<i>r100</i> is transformed using <i>m200</i> and stored in <i>r000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vrtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 3 triple-word (row vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrtfm3.t		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in row major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in m000 format. If it is specified in e000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vtfm3.t instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrtfm3.t		r000, r100, m200
is equivalent to 
vtfm3.t		r000, m200, r100

<i>r100</i> is transformed using <i>m200</i> and stored in <i>r000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vrtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 4 quad-word (row vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrtfm4.q		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in row major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in m000 format. If it is specified in e000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vtfm4.q instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrtfm4.q		r000, r100, m200
is equivalent to 
vtfm4.q		r000, m200, r100

<i>r100</i> is transformed using <i>m200</i> and stored in <i>r000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vxtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 2 double-word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxtfm2.p		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxtfm2.p macro instruction generates a vtfm2.p instruction assembled with the <i>vs</i> operand in transposed format, regardless of whether the -vtfm-trans option or the -no-vtfm-trans option is specified.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vxtfm2.p		c000, e100, c200
is equivalent to 
vtfm2.p		c000, m100, c200

Vctor <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vxtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 3 triple-word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxtfm3.t		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxtfm3.t macro instruction generates a vtfm3.t instruction assembled with the <i>vs</i> operand in transposed format, regardless of whether the -vtfm-trans option or the -no-vtfm-trans option is specified.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vxtfm3.t		c000, e100, c200
is equivalent to 
vtfm3.t		c000, m100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vxtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 4 quad-word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxtfm4.q		vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxtfm4.q macro instruction generates a vtfm4.q instruction assembled with the <i>vs</i> operand in transposed format, regardless of whether the -vtfm-trans option or the -no-vtfm-trans option is specified.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vxtfm4.q		c000, e100, c200
is equivalent to 
vtfm4.q		c000, m100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vchtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vchtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 2 double-word (for column vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vchtfm2.p	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in column major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in e000 format. If it is specified in m000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vhtfm2.p instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vchtfm2.p	c000, e100, c200
is equivalent to 
vhtfm2.p		c000, e100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vchtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vchtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 3 triple-word (for column vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vchtfm3.t	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in column major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in e000 format. If it is specified in m000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vhtfm3.t instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vchtfm3.t	c000, e100, c200
is equivalent to 
vhtfm3.t		c000, e100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vchtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vchtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 4 quad-word (for column vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vchtfm4.q	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in column major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in e000 format. If it is specified in m000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vhtfm4.q instruction without switching the order of the <i>vs</i> and <i>vt</i> operands. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vchtfm4.q	c000, e100, c200
is equivalent to 
vhtfm4.q		c000, e100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrhtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vrhtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 2 double-word (for row vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrhtfm2.p	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in row major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in m000 format. If it is specified in e000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vhtfm2.p instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrhtfm2.p	r000, r100, m200
is equivalent to 
vhtfm2.p		r000, m200, r100

<i>r100</i> is transformed using <i>m200</i> and stored in <i>r000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrhtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vrhtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 3 triple-word (for row vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrhtfm3.t	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in row major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in m000 format. If it is specified in e000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vtfm3.t instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrhtfm3.t	r000, r100, m200
is equivalent to 
vhtfm3.t		r000, m200, r100

<i>r100</i> is transformed using <i>m200</i> and stored in <i>r000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrhtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vrhtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 4 quad-word (for row vector)<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrhtfm4.q	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">This instruction multiplies the contents of the matrix register specified by <i>vt</i> by the contents of the matrix register specified by <i>vs</i>, from the right, and stores the result in the matrix register location specified by <i>vd</i>. <br>It is assumed that <i>vs</i> is in row major matrix format, so for this instruction, the <i>vs</i> operand is normally specified in m000 format. If it is specified in e000 format, this signifies that a transposed matrix will be used for the transformation. <br><br>This macro instruction causes the assembler to generate a vhtfm4.q instruction with the order of the <i>vs</i> and <i>vt</i> operands switched. This allows assembly source code to be written in a format which matches the order of operations.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vrhtfm4.q	r000, r100, m200
is equivalent to 
vhtfm4.q		r000, m200, r100

<i>r100</i> is transformed using <i>m200</i> and stored in <i>r000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxhtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vxhtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 2 double-word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxhtfm2.p	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxhtfm2.p macro instruction generates a <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#vxtfm2.p">vxtfm2.p</a> instruction assembled with the <i>vs</i> operand in transposed format, regardless of whether the -vtfm-trans option or the -no-vtfm-trans option is specified.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vxhtfm2.p	c000, e100, c200
is equivalent to 
vhtfm2.p		c000, m100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxhtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vxhtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 3 triple-word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxhtfm3.t	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxhtfm3.t macro instruction generates a <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#vxtfm3.t">vxtfm3.t</a> instruction assembled with the <i>vs</i> operand in transposed format, regardless of whether the -vtfm-trans option or the -no-vtfm-trans option is specified.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
        <div style="margin-left:50px;"><pre><font size=3>vxhtfm3.t	c000, e100, c200
is equivalent to 
vhtfm3.t		c000, m100, c200

Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.

</font></pre></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxhtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vxhtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfm Macro Instructions]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous transform 4 quad-word<br></div><br>

<!-- Syntax -->
<div style="margin-left:10px;"><b>Syntax</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxhtfm4.q	vd, vs, vt

</font></pre></div>

<!-- Description -->
<div style="margin-left:10px;"><b>Description</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">The vxhtfm4.q macro instruction generates a <a href="../fpu-vfpu/VFPU_Macro-Reference-English.htm#vxtfm4.q">vxtfm4.q</a> instruction assembled with the <i>vs</i> operand in transposed format, regardless of whether the -vtfm-trans option or the -no-vtfm-trans option is specified.<br><br></div>

<!-- Example -->
<div style="margin-left:10px;"><b>Example</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxhtfm4.q	c000, e100, c200<br>is equivalent to <br>vhtfm4.q		c000, m100, c200<br><br>Vector <i>c200</i> is transformed using matrix <i>e100</i> and stored in vector <i>c000</i>.<br><br><br></div>
<p><p><hr>
<div ALIGN="right">
    &copy;2008 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
