<html lang="jp">
<head>
<title>VFPU_Macro-Reference</title>
<meta http-equiv="Content-Type" content= text/html; charset=Shift_JIS>
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="Text/css>
<meta name="Author"Content=" Sony Computer Entertainment Inc.">
</head>
<body bgcolor="#ffffff" text="#000000" >
<a name=TOP></a>
<table WIDTH="100%">
<tr><td>
<h3>PSP&reg; Programmer Tool Runtime Library Release 6.6.0</h3>
</td>
</tr>
</table>
<hr noshade size=6>
<center><h1>
psp-as VFPUマクロ
</h1></center>
</a>
<!-- sce_hd1 -->

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvi.s"></a>
<table width="100%"><td width="70%"><font size=6>lvi.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[即値ロード]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Immediate to VFPU(Scalar)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvi.s	vt, imm0

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">imm0が示す1要素の単精度浮動小数をvtが指示するマトリクスレジスタの位置に格納します。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0] &lt;- imm0<br>WriteMatrix( SINGLEWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvi.p"></a>
<table width="100%"><td width="70%"><font size=6>lvi.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[即値ロード]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Immediate to VFPU(2D vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvi.p	vt, [imm0,imm1]

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">imm0, imm1が示す2要素の単精度浮動小数をvtが指示するマトリクスレジスタの位置に格納します。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0] &lt;- imm0<br>t[1] &lt;- imm1<br>WriteMatrix( PAIRWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvi.t"></a>
<table width="100%"><td width="70%"><font size=6>lvi.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[即値ロード]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Imeediate to VFPU(3D vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvi.t	vt, [imm0,imm1,imm2]

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">imm0, imm1, imm2が示す3要素の単精度浮動小数をvtが指示するマトリクスレジスタの位置に格納します。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0] &lt;- imm0<br>t[1] &lt;- imm1<br>t[2] &lt;- imm2<br>WriteMatrix( TRIPLEWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvi.q"></a>
<table width="100%"><td width="70%"><font size=6>lvi.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[即値ロード]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Immediate to VFPU(4D vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvi.q	vt, [imm0,imm1,imm2,imm3]

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">imm0, imm1, imm2, imm3が示す4要素の単精度浮動小数をvtが指示するマトリクスレジスタの位置に格納します。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0] &lt;- imm0<br>t[1] &lt;- imm1<br>t[2] &lt;- imm2<br>t[3] &lt;- imm3<br>WriteMatrix( QUADWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvhi.s"></a>
<table width="100%"><td width="70%"><font size=6>lvhi.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[即値ロード]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Half-precision Immediate to VFPU(2D vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvhi.s	vt, [imm0,imm1]

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">imm0, imm1が示す2要素の半精度浮動小数をvtが指示するマトリクスレジスタの位置に格納します。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0].l &lt;- imm0<br>t[0].u &lt;- imm1<br>WriteMatrix( SINGLEWORD, vt, t )<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lvhi.p"></a>
<table width="100%"><td width="70%"><font size=6>lvhi.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[即値ロード]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Half-precision Immediate to VFPU(4D vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lvhi.p	vt, [imm0,imm1,imm2,imm3]

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">imm0, imm1, imm2, imm3が示す4要素の半精度浮動小数をvtが指示するマトリクスレジスタの位置に格納します。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">t[0].l &lt;- imm0<br>t[0].u &lt;- imm1<br>t[1].l &lt;- imm2<br>t[1].u &lt;- imm3<br>WriteMatrix( PAIRWORD, vt, t )<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lv.s"></a>
<table width="100%"><td width="70%"><font size=6>lv.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Address-extended Load Single Word to VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lv.s	vt, offset32(rs)
lv.s	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">lv.s命令のオフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br>以降の動作は、16ビットオフセットに対するlv.sと同様です。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( SINGLEWORD, pAddr, vAddr, DATA );<br>WriteMatrix( SINGLEWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lv.p"></a>
<table width="100%"><td width="70%"><font size=6>lv.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Pair Word to VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lv.p	vt, offset16(rs)
lv.p	vt, offset32(rs)
lv.p	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">16ビットのoffset16を符号拡張してrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。その実行アドレスによるメモリ位置から2ワードの値を読み出し、vtが指示するマトリクスレジスタの位置に格納します。<br><br>オフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( PAIRWORD, pAddr, vAddr, DATA );<br>WriteMatrix( PAIRWORD, vt, memword );<br><br>または<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( PAIRWORD, pAddr, vAddr, DATA );<br>WriteMatrix( PAIRWORD, vt, memword );<br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lv.t"></a>
<table width="100%"><td width="70%"><font size=6>lv.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Triple Word to VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lv.t	vt, offset16(rs)
lv.t	vt, offset32(rs)
lv.t	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">16ビットのoffset16を符号拡張してrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。その実行アドレスによるメモリ位置から3ワードの値を読み出し、vtが指示するマトリクスレジスタの位置に格納します。<br><br>オフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( TRIPLEWORD, pAddr, vAddr, DATA );<br>WriteMatrix( TRIPLEWORD, vt, memword );<br><br>または、<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( TRIPLEWORD, pAddr, vAddr, DATA );<br>WriteMatrix( TRIPLEWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="lv.q"></a>
<table width="100%"><td width="70%"><font size=6>lv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Address-extended Load Quad Word to VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>lv.q	vt, offset32(rs)
lv.q	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">lv.q命令のオフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br>以降の動作は、16ビットオフセットに対するlv.qと同様です。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( QUADWORD, pAddr, vAddr, DATA );<br>WriteMatrix( QUADWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="ulv.s"></a>
<table width="100%"><td width="70%"><font size=6>ulv.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Unaligned Single Word to VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>ulv.s	vt, offset16(rs)

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">16ビットのoffset16を符号拡張してrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。その実行アドレスによるメモリ位置から1ワードの値を読み出し、vtが指示するマトリクスレジスタの位置に格納します。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( SINGLEWORD, pAddr, vAddr, DATA );<br>WriteMatrix( SINGLEWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="ulv.q"></a>
<table width="100%"><td width="70%"><font size=6>ulv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Load Unaligned Quad Word to VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>ulv.q	vt, offset16(rs)
ulv.q	vt, offset32(rs)
ulv.q	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">下位2ビットを無視した16ビットのoffset16を符号拡張してrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。その実行アドレスによるメモリ位置から4ワードの値を読み出し、vtが指示するマトリクスレジスタの位置に格納します。<br><br>VFPUの<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#lv.q">lv.q</a>命令は16バイトアラインメントを要求しますが、ulv.q命令は<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#lv.s">lv.s</a>命令を4回繰り返すため4バイトアラインメントのアドレスに対して動作することができます。<br><br>オフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:2],2'b0 ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( QUADWORD, pAddr, vAddr, DATA );<br>WriteMatrix( QUADWORD, vt, memword );<br><br>または<br><br>vAddr &lt;- offset32[31:2] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, LOAD );<br>memword &lt;- LoadMemory( QUADWORD, pAddr, vAddr, DATA );<br>WriteMatrix( QUADWORD, vt, memword );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sv.s"></a>
<table width="100%"><td width="70%"><font size=6>sv.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Address-extended Store Single Word from VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>sv.s	vt, offset32(rs)
sv.s	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">sv.s命令のオフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br>以降の動作は、16ビットオフセットに対するsv.sと同様です。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( SINGLEORD, vt );<br>StoreMemory( SINGLEWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sv.p"></a>
<table width="100%"><td width="70%"><font size=6>sv.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store Pair Word from VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>sv.p	vt, offset16(rs)
sv.p	vt, offset32(rs)
sv.p	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">16ビットのoffset16を符号拡張してrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。その実行アドレスによるメモリ位置にvtが指示するマトリクスレジスタの1ワードの内容を書き込みます。<br><br>オフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( PAIRWORD, vt );<br>StoreMemory( PAIRWORD, dataword, pAddr, vAddr, DATA );<br><br>または<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( PAIRWORD, vt );<br>StoreMemory( PAIRWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sv.t"></a>
<table width="100%"><td width="70%"><font size=6>sv.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store Triple Word from VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>sv.t	vt, offset(rs)
sv.t	vt, offset32(rs)
sv.t	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">16ビットのoffsetを符号拡張してrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。その実行アドレスによるメモリ位置にvtが指示するマトリクスレジスタの1ワードの内容を書き込みます。<br><br>オフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( TRIPLEWORD, vt );<br>StoreMemory( TRIPLEWORD, dataword, pAddr, vAddr, DATA );<br><br>または<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( TRIPLEWORD, vt );<br>StoreMemory( TRIPLEWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="sv.q"></a>
<table width="100%"><td width="70%"><font size=6>sv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Address-extended Store Quad Word from VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>sv.q	vt, offset32(rs)
sv.q	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">sv.q命令のオフセットが符号つき16ビットの範囲にない場合、offset32としてアドレス拡張された動作を行います。あるいは、32ビットのaddress32を仮想アドレスとします。<br><br>以降の動作は、16ビットオフセットに対するsv.qと同様です。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( QUADWORD, vt );<br>StoreMemory( QUADWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="svl.q"></a>
<table width="100%"><td width="70%"><font size=6>svl.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Address-extended Store Quad Word Left from VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>svl.q	vt, offset32(rs)
svl.q	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">下位2ビットを無視した32ビットのoffset32をrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。<br>あるいは、32ビットのaddress32を仮想アドレスとします。<br>以降の動作は、16ビットオフセットに対するsvl.qと同様です。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="svr.q"></a>
<table width="100%"><td width="70%"><font size=6>svr.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Address-extended Store Quad Word Right from VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>svr.q	vt, offset32(rs)
svr.q	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">下位2ビットを無視した32ビットのoffset32をrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。<br>あるいは、32ビットのaddress32を仮想アドレスとします。<br>以降の動作は、16ビットオフセットに対するsvr.qと同様です。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="usv.s"></a>
<table width="100%"><td width="70%"><font size=6>usv.s<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store Unaligned Single Word from VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>usv.s	vt, offset16(rs)

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">16ビットのoffset16を符号拡張してrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。その実行アドレスによるメモリ位置にvtが指示するマトリクスレジスタの1ワードの内容を書き込みます。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:0] ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( SINGLEWORD, vt );<br>StoreMemory( SINGLEWORD, dataword, pAddr, vAddr, DATA );<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="usv.q"></a>
<table width="100%"><td width="70%"><font size=6>usv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[拡張ロード/ストア命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Store Unaligned Quad Word from VFPU<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>usv.q	vt, offset16(rs)
usv.q	vt, offset32(rs)
usv.q	vt, address32

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">下位2ビットを無視した16ビットのoffset16を符号拡張してrsが指示するCPUの汎用レジスタの内容と加算し、仮想アドレスを生成します。その実行アドレスによるメモリ位置にvtが指示するマトリクスレジスタの4ワードの内容を書き込みます。<br><br>VFPUの<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#sv.q">sv.q</a>命令は16バイトアラインメントを要求しますが、usv.q命令は<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#sv.s">sv.s</a>命令を4回繰り返すため4バイトアラインメントのアドレスに対して動作することができます。<br><br></div>

<!-- オペレーション -->
<div style="margin-left:10px;"><b>オペレーション</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vAddr &lt;- sign_extend( offset16[15:2],2'b0 ) + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( QUADWORD, vt );<br>StoreMemory( QUADWORD, dataword, pAddr, vAddr, DATA );<br><br>または<br><br>vAddr &lt;- offset32[31:0] + GPR[rs];<br>pAddr &lt;- AddressTranslation( vAddr, DATA, STORE );<br>dataword &lt;- ReadMatrix( QUADWORD, vt );<br>StoreMemory( QUADWORD, dataword, pAddr, vAddr, DATA );<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vdiv.p"></a>
<table width="100%"><td width="70%"><font size=6>vdiv.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vdivマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Divide Pair Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vdiv.p		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの2要素の浮動小数点数をvtが指示するマトリクスレジスタの2要素の浮動小数点数によって除算し、結果をvdが指示するマトリクスレジスタの位置に2要素の浮動小数点数を格納します。<br><br>アセンブラはvdiv.pをvdiv.s命令を2回繰り返すマクロ命令として処理します。<br>VFPUが本来インストラクションとしてもっていたvdiv.p命令は、後続する<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#lv.q">lv.q</a>命令がDキャッシュミスした場合にレジスタ破壊をもたらす可能性があるというエラッタを誘発するため、仕様から削除されました。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vdiv.p		c000, c100, c200<br>は<br>vdiv.s		s000, s100, s200<br>vdiv.s		s001, s101, s201<br>と等価です。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vdiv.t"></a>
<table width="100%"><td width="70%"><font size=6>vdiv.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vdivマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Divide Triple Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vdiv.t		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの3要素の浮動小数点数をvtが指示するマトリクスレジスタの3要素の浮動小数点数によって除算し、結果をvdが指示するマトリクスレジスタの位置に3要素の浮動小数点数を格納します。<br><br>アセンブラはvdiv.tをvdiv.s命令を3回繰り返すマクロ命令として処理します。<br>VFPUが本来インストラクションとしてもっていたvdiv.t命令は、後続する<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#lv.q">lv.q</a>命令がDキャッシュミスした場合にレジスタ破壊をもたらす可能性があるというエラッタを誘発するため、仕様から削除されました。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vdiv.t		c000, c100, c200<br>は<br>vdiv.s		s000, s100, s200<br>vdiv.s		s001, s101, s201<br>vdiv.s		s002, s102, s202<br>と等価です。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vdiv.q"></a>
<table width="100%"><td width="70%"><font size=6>vdiv.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vdivマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Divide Quad Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vdiv.q		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの4要素の浮動小数点数をvtが指示するマトリクスレジスタの4要素の浮動小数点数によって除算し、結果をvdが指示するマトリクスレジスタの位置に4要素の浮動小数点数を格納します。<br><br>アセンブラはvdiv.qをvdiv.s命令を4回繰り返すマクロ命令として処理します。<br>VFPUが本来インストラクションとしてもっていたvdiv.q命令は、後続する<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#lv.q">lv.q</a>命令がDキャッシュミスした場合にレジスタ破壊をもたらす可能性があるというエラッタを誘発するため、仕様から削除されました。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vdiv.q		c000, c100, c200<br>は<br>vdiv.s		s000, s100, s200<br>vdiv.s		s001, s101, s201<br>vdiv.s		s002, s102, s202<br>vdiv.s		s003, s103, s203<br>と等価です。<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vcmmul.p"></a>
<table width="100%"><td width="70%"><font size=6>vcmmul.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Pair x Pair Matrix (for column major matrix)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vcmmul.p	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vd, vs, vtはいずれも列マトリクス(column major)形式であること想定しますので、この命令では通常e000形式でマトリクスレジスタを指定します。m000形式で指定した場合は転置を意味します。<br><br>アセンブラではvsとvtのオペランド順を入れ替えたvmmul.p命令を生成します。デフォルトで設定される-vmmul-transオプションにより、vsオペランド(入れ替える前のvtオペランド)は転置した形式でアセンブルが行われますので、演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vcmmul.p	e000, e100, e200<br>は<br>vmmul.p		e000, e200, e100<br>と等価です。<br><br>マトリクスe100にマトリクスe200を右側から乗じて、マトリクスe000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vcmmul.t"></a>
<table width="100%"><td width="70%"><font size=6>vcmmul.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Triple x Triple Matrix (for column major matrix)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vcmmul.t	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vd, vs, vtはいずれも列マトリクス(column major)形式であること想定しますので、この命令では通常e000形式でマトリクスレジスタを指定します。m000形式で指定した場合は転置を意味します。<br><br>アセンブラではvsとvtのオペランド順を入れ替えたvmmul.t命令を生成します。デフォルトで設定される-vmmul-transオプションにより、vsオペランド(入れ替える前のvtオペランド)は転置した形式でアセンブルが行われますので、演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vcmmul.t	e000, e100, e200<br>は<br>vmmul.t		e000, e200, e100<br>と等価です。<br><br>マトリクスe100にマトリクスe200を右側から乗じて、マトリクスe000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vcmmul.q"></a>
<table width="100%"><td width="70%"><font size=6>vcmmul.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Quad x Quad Matrix (for column major matrix)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vcmmul.q	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vd, vs, vtはいずれも列マトリクス(column major)形式であること想定しますので、この命令では通常e000形式でマトリクスレジスタを指定します。m000形式で指定した場合は転置を意味します。<br><br>アセンブラではvsとvtのオペランド順を入れ替えたvmmul.q命令を生成します。デフォルトで設定される-vmmul-transオプションにより、vsオペランド(入れ替える前のvtオペランド)は転置した形式でアセンブルが行われますので、演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vcmmul.q	e000, e100, e200<br>は<br>vmmul.q		e000, e200, e100<br>と等価です。<br><br>マトリクスe100にマトリクスe200を右側から乗じて、マトリクスe000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrmmul.p"></a>
<table width="100%"><td width="70%"><font size=6>vrmmul.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Pair x Pair Matrix (for row major matrix)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrmmul.p	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vd, vs, vtはいずれも行マトリクス(row major)形式であること想定しますので、この命令では通常m000形式でマトリクスレジスタを指定します。e000形式で指定した場合は転置を意味します。<br><br>アセンブラではvsとvtのオペランド順を入れ替えずにvmmul.p命令を生成します。デフォルトで設定される-vmmul-transオプションにより、vsオペランドは転置した形式でアセンブルが行われますので、演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrmmul.p	m000, m100, m200<br>は<br>vmmul.p		m000, m100, m200<br>と等価です。<br><br>マトリクスm100にマトリクスm200を右側から乗じて、マトリクスm000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrmmul.t"></a>
<table width="100%"><td width="70%"><font size=6>vrmmul.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Triple x Triple Matrix (for row major matrix)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrmmul.t	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vd, vs, vtはいずれも行マトリクス(row major)形式であること想定しますので、この命令では通常m000形式でマトリクスレジスタを指定します。e000形式で指定した場合は転置を意味します。<br><br>アセンブラではvsとvtのオペランド順を入れ替えずにvmmul.t命令を生成します。デフォルトで設定される-vmmul-transオプションにより、vsオペランドは転置した形式でアセンブルが行われますので、演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrmmul.t	m000, m100, m200<br>は<br>vmmul.t		m000, m100, m200<br>と等価です。<br><br>マトリクスm100にマトリクスm200を右側から乗じて、マトリクスm000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrmmul.q"></a>
<table width="100%"><td width="70%"><font size=6>vrmmul.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Quad x Quad Matrix (for row major matrix)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrmmul.q	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vd, vs, vtはいずれも行マトリクス(row major)形式であること想定しますので、この命令では通常m000形式でマトリクスレジスタを指定します。e000形式で指定した場合は転置を意味します。<br><br>アセンブラではvsとvtのオペランド順を入れ替えずにvmmul.q命令を生成します。デフォルトで設定される-vmmul-transオプションにより、vsオペランドは転置した形式でアセンブルが行われますので、演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrmmul.q	m000, m100, m200<br>は<br>vmmul.q		m000, m100, m200<br>と等価です。<br><br>マトリクスm100にマトリクスm200を右側から乗じて、マトリクスm000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxmmul.p"></a>
<table width="100%"><td width="70%"><font size=6>vxmmul.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Pair x Pair Matrix<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxmmul.p	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxmmul.pマクロ命令では-vmmul-trans / -no-vmmul-transオプションのいずれかが設定されているかに関わらず、vsオペランドを転置した形式でアセンブルしたvmmul.p命令を生成します。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxmmul.p	e000, e200, e100<br>は<br>vmmul.p		e000, e200, e100		// -vmmul-trans設定時<br>vmmul.p		e000, m200, e100		// -no-vmmul-trans設定時<br>と等価です。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxmmul.t"></a>
<table width="100%"><td width="70%"><font size=6>vxmmul.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Triple x Triple Matrix<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxmmul.t	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxmmul.t命令では、-vmmul-trans / -no-vmmul-transオプションのいずれかが設定されているかに関わらず、vsとvtのオペランド順を入れ替えたvmmul.t命令が生成されます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxmmul.t	e000, e200, e100<br>は<br>vmmul.t		e000, e200, e100		// -vmmul-trans設定時<br>vmmul.t		e000, m200, e100		// -no-vmmul-trans設定時<br>と等価です。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxmmul.q"></a>
<table width="100%"><td width="70%"><font size=6>vxmmul.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vmmulマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Multiply Quad x Quad Matrix<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxmmul.q	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxmmul.q命令では、-vmmul-trans / -no-vmmul-transオプションのいずれかが設定されているかに関わらず、vsとvtのオペランド順を入れ替えたvmmul.q命令が生成されます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxmmul.q	e000, e200, e100<br>は<br>vmmul.q		e000, e200, e100		// -vmmul-trans設定時<br>vmmul.q		e000, m200, e100		// -no-vmmul-trans設定時<br>と等価です。<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vctfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vctfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 2 Pair Word (for column vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vctfm2.p		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vsは列マトリクス(column major)形式であること想定しますので、この命令では通常vsオペランドをe000形式で指定します。m000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えずにvtfm2.p命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vctfm2.p		c000, e100, c200<br>は<br>vtfm2.p		c000, e100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vctfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vctfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 3 Triple Word (for column vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vctfm3.t		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vsは列マトリクス(column major)形式であること想定しますので、この命令では通常vsオペランドをe000形式で指定します。m000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えずにvtfm3.t命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vctfm3.t		c000, e100, c200<br>は<br>vtfm3.t		c000, e100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vctfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vctfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 4 Quad Word (for column vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vctfm4.q		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vsは列マトリクス(column major)形式であること想定しますので、この命令では通常vsオペランドをe000形式で指定します。m000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えずにvtfm4.q命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vctfm4.q		c000, e100, c200<br>は<br>vtfm4.q		c000, e100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vrtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 2 Pair Word (for row vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrtfm2.p		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vtは行マトリクス(row major)形式であること想定しますので、この命令では通常vsオペランドをm000形式で指定します。e000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えてvtfm2.p命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrtfm2.p		r000, r100, m200<br>は<br>vtfm2.p		r000, m200, r100<br>と等価です。<br><br>r100をm200によって変換し、r000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vrtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 3 Triple Word (for row vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrtfm3.t		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vtは行マトリクス(row major)形式であること想定しますので、この命令では通常vsオペランドをm000形式で指定します。e000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えてvtfm3.t命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrtfm3.t		r000, r100, m200<br>は<br>vtfm3.t		r000, m200, r100<br>と等価です。<br><br>r100をm200によって変換し、r000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vrtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 4 Quad Word (for row vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrtfm4.q		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vtは行マトリクス(row major)形式であること想定しますので、この命令では通常vsオペランドをm000形式で指定します。e000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えてvtfm4.q命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrtfm4.q		r000, r100, m200<br>は<br>vtfm4.q		r000, m200, r100<br>と等価です。<br><br>r100をm200によって変換し、r000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vxtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 2 Pair Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxtfm2.p		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxtfm2.pマクロ命令では-vtfm-trans / -no-vtfm-transオプションのいずれかが設定されているかに関わらず、vsオペランドを転置した形式でアセンブルしたvtfm2.p命令を生成します。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxtfm2.p		c000, e100, c200<br>は<br>vtfm2.p		c000, m100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vxtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 3 Triple Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxtfm3.t		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxtfm3.tマクロ命令では-vtfm-trans / -no-vtfm-transオプションのいずれかが設定されているかに関わらず、vsオペランドを転置した形式でアセンブルしたvtfm3.t命令を生成します。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxtfm3.t		c000, e100, c200<br>は<br>vtfm3.t		c000, m100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vxtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Transform 4 Quad Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxtfm4.q		vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxtfm4.qマクロ命令では-vtfm-trans / -no-vtfm-transオプションのいずれかが設定されているかに関わらず、vsオペランドを転置した形式でアセンブルしたvtfm4.q命令を生成します。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxtfm4.q		c000, e100, c200<br>は<br>vtfm4.q		c000, m100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>

<!-- sce_hd2 -->
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vchtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vchtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 2 Pair Word (for column vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vchtfm2.p	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vsは列マトリクス(column major)形式であること想定しますので、この命令では通常vsオペランドをe000形式で指定します。m000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えずにvhtfm2.p命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vchtfm2.p	c000, e100, c200<br>は<br>vhtfm2.p		c000, e100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vchtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vchtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 3 Triple Word (for column vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vchtfm3.t	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vsは列マトリクス(column major)形式であること想定しますので、この命令では通常vsオペランドをe000形式で指定します。m000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えずにvhtfm3.t命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vchtfm3.t	c000, e100, c200<br>は<br>vhtfm3.t		c000, e100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vchtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vchtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 4 Quad Word (for column vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vchtfm4.q	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vsは列マトリクス(column major)形式であること想定しますので、この命令では通常vsオペランドをe000形式で指定します。m000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えずにvhtfm4.q命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vchtfm4.q	c000, e100, c200<br>は<br>vhtfm4.q		c000, e100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrhtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vrhtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 4 Quad Word (for row vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrhtfm2.p	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vtは行マトリクス(row major)形式であること想定しますので、この命令では通常vsオペランドをm000形式で指定します。e000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えてvhtfm2.p命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrhtfm2.p	r000, r100, m200<br>は<br>vhtfm2.p		r000, m200, r100<br>と等価です。<br><br>r100をm200によって変換し、r000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrhtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vrhtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 3 Triple Word (for row vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrhtfm3.t	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vtは行マトリクス(row major)形式であること想定しますので、この命令では通常vsオペランドをm000形式で指定します。e000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えてvhtfm3.t命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrhtfm3.t	r000, r100, m200<br>は<br>vhtfm3.t		r000, m200, r100<br>と等価です。<br><br>r100をm200によって変換し、r000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vrhtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vrhtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 4 Quad Word (for row vector)<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vrhtfm4.q	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vsが指示するマトリクスレジスタの内容に、vtが指示するマトリクスレジスタの内容を右側から乗じ、vdが指定するマトリクスレジスタの位置に格納します。<br>vtは行マトリクス(row major)形式であること想定しますので、この命令では通常vsオペランドをm000形式で指定します。e000形式で指定した場合は転置したマトリクスを用いて変換することを意味します。<br><br>アセンブラでは、vsとvtのオペランド順を入れ替えてvhtfm4.q命令を生成します。これにより演算順序と一致した形式でアセンブリソースを記述することができます。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vrhtfm4.q	r000, r100, m200<br>は<br>vhtfm4.q		r000, m200, r100<br>と等価です。<br><br>r100をm200によって変換し、r000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxhtfm2.p"></a>
<table width="100%"><td width="70%"><font size=6>vxhtfm2.p<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 2 Pair Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxhtfm2.p	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxhtfm2.pマクロ命令では-vtfm-trans / -no-vtfm-transオプションのいずれかが設定されているかに関わらず、vsオペランドを転置した形式でアセンブルした<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#vxtfm2.p">vxtfm2.p</a>命令を生成します。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxhtfm2.p	c000, e100, c200<br>は<br>vhtfm2.p		c000, m100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxhtfm3.t"></a>
<table width="100%"><td width="70%"><font size=6>vxhtfm3.t<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 3 Triple Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxhtfm3.t	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxhtfm3.tマクロ命令では-vtfm-trans / -no-vtfm-transオプションのいずれかが設定されているかに関わらず、vsオペランドを転置した形式でアセンブルした<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#vxtfm3.t">vxtfm3.t</a>命令を生成します。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxhtfm3.t	c000, e100, c200<br>は<br>vhtfm3.t		c000, m100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<!-- sce_funcname -->
<hr noshade Size=6 >
<a name="vxhtfm4.q"></a>
<table width="100%"><td width="70%"><font size=6>vxhtfm4.q<br></font></a></td>
<td width="30%"valign="center"align="right"><b><font size=4>[vhtfmマクロ命令]</font></b></td></table>
<hr noshade Size=4 >
<!-- sce_function -->
<!-- hp -->
<div align=right>Homogeneous Transform 4 Quad Word<br></div><br>

<!-- 形式 -->
<div style="margin-left:10px;"><b>形式</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;"><pre><font size=3>vxhtfm4.q	vd, vs, vt

</font></pre></div>

<!-- 説明 -->
<div style="margin-left:10px;"><b>説明</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxhtfm4.qマクロ命令では-vtfm-trans / -no-vtfm-transオプションのいずれかが設定されているかに関わらず、vsオペランドを転置した形式でアセンブルした<a href="../fpu-vfpu/VFPU_Macro-Reference-Japanese.htm#vxtfm4.q">vxtfm4.q</a>命令を生成します。<br><br></div>

<!-- 例 -->
<div style="margin-left:10px;"><b>例</b></div>
<hr noshade align="left" size=2 width=20%>
<br>
<div style="margin-left:50px;">vxhtfm4.q	c000, e100, c200<br>は<br>vhtfm4.q		c000, m100, c200<br>と等価です。<br><br>ベクトルc200をマトリクスe100によって変換し、ベクトルc000に格納します。<br><br></div>
<p><p><hr>
<div ALIGN="right">
    &copy;2008 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
